/*!
 * jQuery JavaScript Library v1.11.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-28T16:19Z
 */

(function( global, factory ) {

    if ( typeof module === "object" && typeof module.exports === "object" ) {
        // For CommonJS and CommonJS-like environments where a proper window is present,
        // execute the factory and get jQuery
        // For environments that do not inherently posses a window with a document
        // (such as Node.js), expose a jQuery-making factory as module.exports
        // This accentuates the need for the creation of a real window
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info
        module.exports = global.document ?
            factory( global, true ) :
            function( w ) {
                if ( !w.document ) {
                    throw new Error( "jQuery requires a window with a document" );
                }
                return factory( w );
            };
    } else {
        factory( global );
    }

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

    var deletedIds = [];

    var slice = deletedIds.slice;

    var concat = deletedIds.concat;

    var push = deletedIds.push;

    var indexOf = deletedIds.indexOf;

    var class2type = {};

    var toString = class2type.toString;

    var hasOwn = class2type.hasOwnProperty;

    var support = {};



    var
        version = "1.11.3",

        // Define a local copy of jQuery
        jQuery = function( selector, context ) {
            // The jQuery object is actually just the init constructor 'enhanced'
            // Need init if jQuery is called (just allow error to be thrown if not included)
            return new jQuery.fn.init( selector, context );
        },

        // Support: Android<4.1, IE<9
        // Make sure we trim BOM and NBSP
        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

        // Matches dashed string for camelizing
        rmsPrefix = /^-ms-/,
        rdashAlpha = /-([\da-z])/gi,

        // Used by jQuery.camelCase as callback to replace()
        fcamelCase = function( all, letter ) {
            return letter.toUpperCase();
        };

    jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version,

        constructor: jQuery,

        // Start with an empty selector
        selector: "",

        // The default length of a jQuery object is 0
        length: 0,

        toArray: function() {
            return slice.call( this );
        },

        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function( num ) {
            return num != null ?

                // Return just the one element from the set
                ( num < 0 ? this[ num + this.length ] : this[ num ] ) :

                // Return all the elements in a clean array
                slice.call( this );
        },

        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function( elems ) {

            // Build a new jQuery matched element set
            var ret = jQuery.merge( this.constructor(), elems );

            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;
            ret.context = this.context;

            // Return the newly-formed element set
            return ret;
        },

        // Execute a callback for every element in the matched set.
        // (You can seed the arguments with an array of args, but this is
        // only used internally.)
        each: function( callback, args ) {
            return jQuery.each( this, callback, args );
        },

        map: function( callback ) {
            return this.pushStack( jQuery.map(this, function( elem, i ) {
                return callback.call( elem, i, elem );
            }));
        },

        slice: function() {
            return this.pushStack( slice.apply( this, arguments ) );
        },

        first: function() {
            return this.eq( 0 );
        },

        last: function() {
            return this.eq( -1 );
        },

        eq: function( i ) {
            var len = this.length,
                j = +i + ( i < 0 ? len : 0 );
            return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
        },

        end: function() {
            return this.prevObject || this.constructor(null);
        },

        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: deletedIds.sort,
        splice: deletedIds.splice
    };

    jQuery.extend = jQuery.fn.extend = function() {
        var src, copyIsArray, copy, name, options, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if ( typeof target === "boolean" ) {
            deep = target;

            // skip the boolean and the target
            target = arguments[ i ] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
            target = {};
        }

        // extend jQuery itself if only one argument is passed
        if ( i === length ) {
            target = this;
            i--;
        }

        for ( ; i < length; i++ ) {
            // Only deal with non-null/undefined values
            if ( (options = arguments[ i ]) != null ) {
                // Extend the base object
                for ( name in options ) {
                    src = target[ name ];
                    copy = options[ name ];

                    // Prevent never-ending loop
                    if ( target === copy ) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                        if ( copyIsArray ) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];

                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[ name ] = jQuery.extend( deep, clone, copy );

                        // Don't bring in undefined values
                    } else if ( copy !== undefined ) {
                        target[ name ] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    };

    jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

        // Assume jQuery is ready without the ready module
        isReady: true,

        error: function( msg ) {
            throw new Error( msg );
        },

        noop: function() {},

        // See test/unit/core.js for details concerning isFunction.
        // Since version 1.3, DOM methods and functions like alert
        // aren't supported. They return false on IE (#2968).
        isFunction: function( obj ) {
            return jQuery.type(obj) === "function";
        },

        isArray: Array.isArray || function( obj ) {
            return jQuery.type(obj) === "array";
        },

        isWindow: function( obj ) {
            /* jshint eqeqeq: false */
            return obj != null && obj == obj.window;
        },

        isNumeric: function( obj ) {
            // parseFloat NaNs numeric-cast false positives (null|true|false|"")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            // adding 1 corrects loss of precision from parseFloat (#15100)
            return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
        },

        isEmptyObject: function( obj ) {
            var name;
            for ( name in obj ) {
                return false;
            }
            return true;
        },

        isPlainObject: function( obj ) {
            var key;

            // Must be an Object.
            // Because of IE, we also have to check the presence of the constructor property.
            // Make sure that DOM nodes and window objects don't pass through, as well
            if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
                return false;
            }

            try {
                // Not own constructor property must be Object
                if ( obj.constructor &&
                    !hasOwn.call(obj, "constructor") &&
                    !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
                    return false;
                }
            } catch ( e ) {
                // IE8,9 Will throw exceptions on certain host objects #9897
                return false;
            }

            // Support: IE<9
            // Handle iteration over inherited properties before own properties.
            if ( support.ownLast ) {
                for ( key in obj ) {
                    return hasOwn.call( obj, key );
                }
            }

            // Own properties are enumerated firstly, so to speed up,
            // if last one is own, then all properties are own.
            for ( key in obj ) {}

            return key === undefined || hasOwn.call( obj, key );
        },

        type: function( obj ) {
            if ( obj == null ) {
                return obj + "";
            }
            return typeof obj === "object" || typeof obj === "function" ?
                class2type[ toString.call(obj) ] || "object" :
                typeof obj;
        },

        // Evaluates a script in a global context
        // Workarounds based on findings by Jim Driscoll
        // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
        globalEval: function( data ) {
            if ( data && jQuery.trim( data ) ) {
                // We use execScript on Internet Explorer
                // We use an anonymous function so that context is window
                // rather than jQuery in Firefox
                ( window.execScript || function( data ) {
                    window[ "eval" ].call( window, data );
                } )( data );
            }
        },

        // Convert dashed to camelCase; used by the css and data modules
        // Microsoft forgot to hump their vendor prefix (#9572)
        camelCase: function( string ) {
            return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
        },

        nodeName: function( elem, name ) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },

        // args is for internal usage only
        each: function( obj, callback, args ) {
            var value,
                i = 0,
                length = obj.length,
                isArray = isArraylike( obj );

            if ( args ) {
                if ( isArray ) {
                    for ( ; i < length; i++ ) {
                        value = callback.apply( obj[ i ], args );

                        if ( value === false ) {
                            break;
                        }
                    }
                } else {
                    for ( i in obj ) {
                        value = callback.apply( obj[ i ], args );

                        if ( value === false ) {
                            break;
                        }
                    }
                }

                // A special, fast, case for the most common use of each
            } else {
                if ( isArray ) {
                    for ( ; i < length; i++ ) {
                        value = callback.call( obj[ i ], i, obj[ i ] );

                        if ( value === false ) {
                            break;
                        }
                    }
                } else {
                    for ( i in obj ) {
                        value = callback.call( obj[ i ], i, obj[ i ] );

                        if ( value === false ) {
                            break;
                        }
                    }
                }
            }

            return obj;
        },

        // Support: Android<4.1, IE<9
        trim: function( text ) {
            return text == null ?
                "" :
                ( text + "" ).replace( rtrim, "" );
        },

        // results is for internal usage only
        makeArray: function( arr, results ) {
            var ret = results || [];

            if ( arr != null ) {
                if ( isArraylike( Object(arr) ) ) {
                    jQuery.merge( ret,
                        typeof arr === "string" ?
                            [ arr ] : arr
                    );
                } else {
                    push.call( ret, arr );
                }
            }

            return ret;
        },

        inArray: function( elem, arr, i ) {
            var len;

            if ( arr ) {
                if ( indexOf ) {
                    return indexOf.call( arr, elem, i );
                }

                len = arr.length;
                i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

                for ( ; i < len; i++ ) {
                    // Skip accessing in sparse arrays
                    if ( i in arr && arr[ i ] === elem ) {
                        return i;
                    }
                }
            }

            return -1;
        },

        merge: function( first, second ) {
            var len = +second.length,
                j = 0,
                i = first.length;

            while ( j < len ) {
                first[ i++ ] = second[ j++ ];
            }

            // Support: IE<9
            // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
            if ( len !== len ) {
                while ( second[j] !== undefined ) {
                    first[ i++ ] = second[ j++ ];
                }
            }

            first.length = i;

            return first;
        },

        grep: function( elems, callback, invert ) {
            var callbackInverse,
                matches = [],
                i = 0,
                length = elems.length,
                callbackExpect = !invert;

            // Go through the array, only saving the items
            // that pass the validator function
            for ( ; i < length; i++ ) {
                callbackInverse = !callback( elems[ i ], i );
                if ( callbackInverse !== callbackExpect ) {
                    matches.push( elems[ i ] );
                }
            }

            return matches;
        },

        // arg is for internal usage only
        map: function( elems, callback, arg ) {
            var value,
                i = 0,
                length = elems.length,
                isArray = isArraylike( elems ),
                ret = [];

            // Go through the array, translating each of the items to their new values
            if ( isArray ) {
                for ( ; i < length; i++ ) {
                    value = callback( elems[ i ], i, arg );

                    if ( value != null ) {
                        ret.push( value );
                    }
                }

                // Go through every key on the object,
            } else {
                for ( i in elems ) {
                    value = callback( elems[ i ], i, arg );

                    if ( value != null ) {
                        ret.push( value );
                    }
                }
            }

            // Flatten any nested arrays
            return concat.apply( [], ret );
        },

        // A global GUID counter for objects
        guid: 1,

        // Bind a function to a context, optionally partially applying any
        // arguments.
        proxy: function( fn, context ) {
            var args, proxy, tmp;

            if ( typeof context === "string" ) {
                tmp = fn[ context ];
                context = fn;
                fn = tmp;
            }

            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            if ( !jQuery.isFunction( fn ) ) {
                return undefined;
            }

            // Simulated bind
            args = slice.call( arguments, 2 );
            proxy = function() {
                return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
            };

            // Set the guid of unique handler to the same of original handler, so it can be removed
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;

            return proxy;
        },

        now: function() {
            return +( new Date() );
        },

        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    });

// Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
        class2type[ "[object " + name + "]" ] = name.toLowerCase();
    });

    function isArraylike( obj ) {

        // Support: iOS 8.2 (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = "length" in obj && obj.length,
            type = jQuery.type( obj );

        if ( type === "function" || jQuery.isWindow( obj ) ) {
            return false;
        }

        if ( obj.nodeType === 1 && length ) {
            return true;
        }

        return type === "array" || length === 0 ||
            typeof length === "number" && length > 0 && ( length - 1 ) in obj;
    }
    var Sizzle =
        /*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
        (function( window ) {

            var i,
                support,
                Expr,
                getText,
                isXML,
                tokenize,
                compile,
                select,
                outermostContext,
                sortInput,
                hasDuplicate,

                // Local document vars
                setDocument,
                document,
                docElem,
                documentIsHTML,
                rbuggyQSA,
                rbuggyMatches,
                matches,
                contains,

                // Instance-specific data
                expando = "sizzle" + 1 * new Date(),
                preferredDoc = window.document,
                dirruns = 0,
                done = 0,
                classCache = createCache(),
                tokenCache = createCache(),
                compilerCache = createCache(),
                sortOrder = function( a, b ) {
                    if ( a === b ) {
                        hasDuplicate = true;
                    }
                    return 0;
                },

                // General-purpose constants
                MAX_NEGATIVE = 1 << 31,

                // Instance methods
                hasOwn = ({}).hasOwnProperty,
                arr = [],
                pop = arr.pop,
                push_native = arr.push,
                push = arr.push,
                slice = arr.slice,
                // Use a stripped-down indexOf as it's faster than native
                // http://jsperf.com/thor-indexof-vs-for/5
                indexOf = function( list, elem ) {
                    var i = 0,
                        len = list.length;
                    for ( ; i < len; i++ ) {
                        if ( list[i] === elem ) {
                            return i;
                        }
                    }
                    return -1;
                },

                booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

                // Regular expressions

                // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
                whitespace = "[\\x20\\t\\r\\n\\f]",
                // http://www.w3.org/TR/css3-syntax/#characters
                characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

                // Loosely modeled on CSS identifier characters
                // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
                // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                identifier = characterEncoding.replace( "w", "w#" ),

                // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
                    // Operator (capture 2)
                    "*([*^$|!~]?=)" + whitespace +
                    // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
                    "*\\]",

                pseudos = ":(" + characterEncoding + ")(?:\\((" +
                    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                    // 1. quoted (capture 3; capture 4 or capture 5)
                    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
                    // 2. simple (capture 6)
                    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
                    // 3. anything else (capture 2)
                    ".*" +
                    ")\\)|)",

                // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                rwhitespace = new RegExp( whitespace + "+", "g" ),
                rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

                rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
                rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

                rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

                rpseudo = new RegExp( pseudos ),
                ridentifier = new RegExp( "^" + identifier + "$" ),

                matchExpr = {
                    "ID": new RegExp( "^#(" + characterEncoding + ")" ),
                    "CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
                    "TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
                    "ATTR": new RegExp( "^" + attributes ),
                    "PSEUDO": new RegExp( "^" + pseudos ),
                    "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                        "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                        "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
                    "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
                    // For use in libraries implementing .is()
                    // We use this for POS matching in `select`
                    "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                        whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
                },

                rinputs = /^(?:input|select|textarea|button)$/i,
                rheader = /^h\d$/i,

                rnative = /^[^{]+\{\s*\[native \w/,

                // Easily-parseable/retrievable ID or TAG or CLASS selectors
                rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

                rsibling = /[+~]/,
                rescape = /'|\\/g,

                // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
                funescape = function( _, escaped, escapedWhitespace ) {
                    var high = "0x" + escaped - 0x10000;
                    // NaN means non-codepoint
                    // Support: Firefox<24
                    // Workaround erroneous numeric interpretation of +"0x"
                    return high !== high || escapedWhitespace ?
                        escaped :
                        high < 0 ?
                            // BMP codepoint
                            String.fromCharCode( high + 0x10000 ) :
                            // Supplemental Plane codepoint (surrogate pair)
                            String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
                },

                // Used for iframes
                // See setDocument()
                // Removing the function wrapper causes a "Permission Denied"
                // error in IE
                unloadHandler = function() {
                    setDocument();
                };

// Optimize for push.apply( _, NodeList )
            try {
                push.apply(
                    (arr = slice.call( preferredDoc.childNodes )),
                    preferredDoc.childNodes
                );
                // Support: Android<4.0
                // Detect silently failing push.apply
                arr[ preferredDoc.childNodes.length ].nodeType;
            } catch ( e ) {
                push = { apply: arr.length ?

                        // Leverage slice if possible
                        function( target, els ) {
                            push_native.apply( target, slice.call(els) );
                        } :

                        // Support: IE<9
                        // Otherwise append directly
                        function( target, els ) {
                            var j = target.length,
                                i = 0;
                            // Can't trust NodeList.length
                            while ( (target[j++] = els[i++]) ) {}
                            target.length = j - 1;
                        }
                };
            }

            function Sizzle( selector, context, results, seed ) {
                var match, elem, m, nodeType,
                    // QSA vars
                    i, groups, old, nid, newContext, newSelector;

                if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
                    setDocument( context );
                }

                context = context || document;
                results = results || [];
                nodeType = context.nodeType;

                if ( typeof selector !== "string" || !selector ||
                    nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

                    return results;
                }

                if ( !seed && documentIsHTML ) {

                    // Try to shortcut find operations when possible (e.g., not under DocumentFragment)
                    if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
                        // Speed-up: Sizzle("#ID")
                        if ( (m = match[1]) ) {
                            if ( nodeType === 9 ) {
                                elem = context.getElementById( m );
                                // Check parentNode to catch when Blackberry 4.6 returns
                                // nodes that are no longer in the document (jQuery #6963)
                                if ( elem && elem.parentNode ) {
                                    // Handle the case where IE, Opera, and Webkit return items
                                    // by name instead of ID
                                    if ( elem.id === m ) {
                                        results.push( elem );
                                        return results;
                                    }
                                } else {
                                    return results;
                                }
                            } else {
                                // Context is not a document
                                if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
                                    contains( context, elem ) && elem.id === m ) {
                                    results.push( elem );
                                    return results;
                                }
                            }

                            // Speed-up: Sizzle("TAG")
                        } else if ( match[2] ) {
                            push.apply( results, context.getElementsByTagName( selector ) );
                            return results;

                            // Speed-up: Sizzle(".CLASS")
                        } else if ( (m = match[3]) && support.getElementsByClassName ) {
                            push.apply( results, context.getElementsByClassName( m ) );
                            return results;
                        }
                    }

                    // QSA path
                    if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
                        nid = old = expando;
                        newContext = context;
                        newSelector = nodeType !== 1 && selector;

                        // qSA works strangely on Element-rooted queries
                        // We can work around this by specifying an extra ID on the root
                        // and working up from there (Thanks to Andrew Dupont for the technique)
                        // IE 8 doesn't work on object elements
                        if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
                            groups = tokenize( selector );

                            if ( (old = context.getAttribute("id")) ) {
                                nid = old.replace( rescape, "\\$&" );
                            } else {
                                context.setAttribute( "id", nid );
                            }
                            nid = "[id='" + nid + "'] ";

                            i = groups.length;
                            while ( i-- ) {
                                groups[i] = nid + toSelector( groups[i] );
                            }
                            newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
                            newSelector = groups.join(",");
                        }

                        if ( newSelector ) {
                            try {
                                push.apply( results,
                                    newContext.querySelectorAll( newSelector )
                                );
                                return results;
                            } catch(qsaError) {
                            } finally {
                                if ( !old ) {
                                    context.removeAttribute("id");
                                }
                            }
                        }
                    }
                }

                // All others
                return select( selector.replace( rtrim, "$1" ), context, results, seed );
            }

            /**
             * Create key-value caches of limited size
             * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
             *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
             *	deleting the oldest entry
             */
            function createCache() {
                var keys = [];

                function cache( key, value ) {
                    // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                    if ( keys.push( key + " " ) > Expr.cacheLength ) {
                        // Only keep the most recent entries
                        delete cache[ keys.shift() ];
                    }
                    return (cache[ key + " " ] = value);
                }
                return cache;
            }

            /**
             * Mark a function for special use by Sizzle
             * @param {Function} fn The function to mark
             */
            function markFunction( fn ) {
                fn[ expando ] = true;
                return fn;
            }

            /**
             * Support testing using an element
             * @param {Function} fn Passed the created div and expects a boolean result
             */
            function assert( fn ) {
                var div = document.createElement("div");

                try {
                    return !!fn( div );
                } catch (e) {
                    return false;
                } finally {
                    // Remove from its parent by default
                    if ( div.parentNode ) {
                        div.parentNode.removeChild( div );
                    }
                    // release memory in IE
                    div = null;
                }
            }

            /**
             * Adds the same handler for all of the specified attrs
             * @param {String} attrs Pipe-separated list of attributes
             * @param {Function} handler The method that will be applied
             */
            function addHandle( attrs, handler ) {
                var arr = attrs.split("|"),
                    i = attrs.length;

                while ( i-- ) {
                    Expr.attrHandle[ arr[i] ] = handler;
                }
            }

            /**
             * Checks document order of two siblings
             * @param {Element} a
             * @param {Element} b
             * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
             */
            function siblingCheck( a, b ) {
                var cur = b && a,
                    diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                        ( ~b.sourceIndex || MAX_NEGATIVE ) -
                        ( ~a.sourceIndex || MAX_NEGATIVE );

                // Use IE sourceIndex if available on both nodes
                if ( diff ) {
                    return diff;
                }

                // Check if b follows a
                if ( cur ) {
                    while ( (cur = cur.nextSibling) ) {
                        if ( cur === b ) {
                            return -1;
                        }
                    }
                }

                return a ? 1 : -1;
            }

            /**
             * Returns a function to use in pseudos for input types
             * @param {String} type
             */
            function createInputPseudo( type ) {
                return function( elem ) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === type;
                };
            }

            /**
             * Returns a function to use in pseudos for buttons
             * @param {String} type
             */
            function createButtonPseudo( type ) {
                return function( elem ) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && elem.type === type;
                };
            }

            /**
             * Returns a function to use in pseudos for positionals
             * @param {Function} fn
             */
            function createPositionalPseudo( fn ) {
                return markFunction(function( argument ) {
                    argument = +argument;
                    return markFunction(function( seed, matches ) {
                        var j,
                            matchIndexes = fn( [], seed.length, argument ),
                            i = matchIndexes.length;

                        // Match elements found at the specified indexes
                        while ( i-- ) {
                            if ( seed[ (j = matchIndexes[i]) ] ) {
                                seed[j] = !(matches[j] = seed[j]);
                            }
                        }
                    });
                });
            }

            /**
             * Checks a node for validity as a Sizzle context
             * @param {Element|Object=} context
             * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
             */
            function testContext( context ) {
                return context && typeof context.getElementsByTagName !== "undefined" && context;
            }

// Expose support vars for convenience
            support = Sizzle.support = {};

            /**
             * Detects XML nodes
             * @param {Element|Object} elem An element or a document
             * @returns {Boolean} True iff elem is a non-HTML XML node
             */
            isXML = Sizzle.isXML = function( elem ) {
                // documentElement is verified for cases where it doesn't yet exist
                // (such as loading iframes in IE - #4833)
                var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                return documentElement ? documentElement.nodeName !== "HTML" : false;
            };

            /**
             * Sets document-related variables once based on the current document
             * @param {Element|Object} [doc] An element or document object to use to set the document
             * @returns {Object} Returns the current document
             */
            setDocument = Sizzle.setDocument = function( node ) {
                var hasCompare, parent,
                    doc = node ? node.ownerDocument || node : preferredDoc;

                // If no document and documentElement is available, return
                if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
                    return document;
                }

                // Set our document
                document = doc;
                docElem = doc.documentElement;
                parent = doc.defaultView;

                // Support: IE>8
                // If iframe document is assigned to "document" variable and if iframe has been reloaded,
                // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
                // IE6-8 do not support the defaultView property so parent will be undefined
                if ( parent && parent !== parent.top ) {
                    // IE11 does not have attachEvent, so all must suffer
                    if ( parent.addEventListener ) {
                        parent.addEventListener( "unload", unloadHandler, false );
                    } else if ( parent.attachEvent ) {
                        parent.attachEvent( "onunload", unloadHandler );
                    }
                }

                /* Support tests
	---------------------------------------------------------------------- */
                documentIsHTML = !isXML( doc );

                /* Attributes
	---------------------------------------------------------------------- */

                // Support: IE<8
                // Verify that getAttribute really returns attributes and not properties
                // (excepting IE8 booleans)
                support.attributes = assert(function( div ) {
                    div.className = "i";
                    return !div.getAttribute("className");
                });

                /* getElement(s)By*
	---------------------------------------------------------------------- */

                // Check if getElementsByTagName("*") returns only elements
                support.getElementsByTagName = assert(function( div ) {
                    div.appendChild( doc.createComment("") );
                    return !div.getElementsByTagName("*").length;
                });

                // Support: IE<9
                support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

                // Support: IE<10
                // Check if getElementById returns elements by name
                // The broken getElementById methods don't pick up programatically-set names,
                // so use a roundabout getElementsByName test
                support.getById = assert(function( div ) {
                    docElem.appendChild( div ).id = expando;
                    return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
                });

                // ID find and filter
                if ( support.getById ) {
                    Expr.find["ID"] = function( id, context ) {
                        if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
                            var m = context.getElementById( id );
                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            return m && m.parentNode ? [ m ] : [];
                        }
                    };
                    Expr.filter["ID"] = function( id ) {
                        var attrId = id.replace( runescape, funescape );
                        return function( elem ) {
                            return elem.getAttribute("id") === attrId;
                        };
                    };
                } else {
                    // Support: IE6/7
                    // getElementById is not reliable as a find shortcut
                    delete Expr.find["ID"];

                    Expr.filter["ID"] =  function( id ) {
                        var attrId = id.replace( runescape, funescape );
                        return function( elem ) {
                            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                            return node && node.value === attrId;
                        };
                    };
                }

                // Tag
                Expr.find["TAG"] = support.getElementsByTagName ?
                    function( tag, context ) {
                        if ( typeof context.getElementsByTagName !== "undefined" ) {
                            return context.getElementsByTagName( tag );

                            // DocumentFragment nodes don't have gEBTN
                        } else if ( support.qsa ) {
                            return context.querySelectorAll( tag );
                        }
                    } :

                    function( tag, context ) {
                        var elem,
                            tmp = [],
                            i = 0,
                            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                            results = context.getElementsByTagName( tag );

                        // Filter out possible comments
                        if ( tag === "*" ) {
                            while ( (elem = results[i++]) ) {
                                if ( elem.nodeType === 1 ) {
                                    tmp.push( elem );
                                }
                            }

                            return tmp;
                        }
                        return results;
                    };

                // Class
                Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
                    if ( documentIsHTML ) {
                        return context.getElementsByClassName( className );
                    }
                };

                /* QSA/matchesSelector
	---------------------------------------------------------------------- */

                // QSA and matchesSelector support

                // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                rbuggyMatches = [];

                // qSa(:focus) reports false when true (Chrome 21)
                // We allow this because of a bug in IE8/9 that throws an error
                // whenever `document.activeElement` is accessed on an iframe
                // So, we allow :focus to pass through QSA all the time to avoid the IE error
                // See http://bugs.jquery.com/ticket/13378
                rbuggyQSA = [];

                if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
                    // Build QSA regex
                    // Regex strategy adopted from Diego Perini
                    assert(function( div ) {
                        // Select is set to empty string on purpose
                        // This is to test IE's treatment of not explicitly
                        // setting a boolean content attribute,
                        // since its presence should be enough
                        // http://bugs.jquery.com/ticket/12359
                        docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
                            "<select id='" + expando + "-\f]' msallowcapture=''>" +
                            "<option selected=''></option></select>";

                        // Support: IE8, Opera 11-12.16
                        // Nothing should be selected when empty strings follow ^= or $= or *=
                        // The test attribute must be unknown in Opera but "safe" for WinRT
                        // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                        if ( div.querySelectorAll("[msallowcapture^='']").length ) {
                            rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
                        }

                        // Support: IE8
                        // Boolean attributes and "value" are not treated correctly
                        if ( !div.querySelectorAll("[selected]").length ) {
                            rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
                        }

                        // Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
                        if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
                            rbuggyQSA.push("~=");
                        }

                        // Webkit/Opera - :checked should return selected option elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        // IE8 throws error here and will not see later tests
                        if ( !div.querySelectorAll(":checked").length ) {
                            rbuggyQSA.push(":checked");
                        }

                        // Support: Safari 8+, iOS 8+
                        // https://bugs.webkit.org/show_bug.cgi?id=136851
                        // In-page `selector#id sibing-combinator selector` fails
                        if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
                            rbuggyQSA.push(".#.+[+~]");
                        }
                    });

                    assert(function( div ) {
                        // Support: Windows 8 Native Apps
                        // The type and name attributes are restricted during .innerHTML assignment
                        var input = doc.createElement("input");
                        input.setAttribute( "type", "hidden" );
                        div.appendChild( input ).setAttribute( "name", "D" );

                        // Support: IE8
                        // Enforce case-sensitivity of name attribute
                        if ( div.querySelectorAll("[name=d]").length ) {
                            rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
                        }

                        // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                        // IE8 throws error here and will not see later tests
                        if ( !div.querySelectorAll(":enabled").length ) {
                            rbuggyQSA.push( ":enabled", ":disabled" );
                        }

                        // Opera 10-11 does not throw on post-comma invalid pseudos
                        div.querySelectorAll("*,:x");
                        rbuggyQSA.push(",.*:");
                    });
                }

                if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
                    docElem.webkitMatchesSelector ||
                    docElem.mozMatchesSelector ||
                    docElem.oMatchesSelector ||
                    docElem.msMatchesSelector) )) ) {

                    assert(function( div ) {
                        // Check to see if it's possible to do matchesSelector
                        // on a disconnected node (IE 9)
                        support.disconnectedMatch = matches.call( div, "div" );

                        // This should fail with an exception
                        // Gecko does not error, returns false instead
                        matches.call( div, "[s!='']:x" );
                        rbuggyMatches.push( "!=", pseudos );
                    });
                }

                rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
                rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

                /* Contains
	---------------------------------------------------------------------- */
                hasCompare = rnative.test( docElem.compareDocumentPosition );

                // Element contains another
                // Purposefully does not implement inclusive descendent
                // As in, an element does not contain itself
                contains = hasCompare || rnative.test( docElem.contains ) ?
                    function( a, b ) {
                        var adown = a.nodeType === 9 ? a.documentElement : a,
                            bup = b && b.parentNode;
                        return a === bup || !!( bup && bup.nodeType === 1 && (
                            adown.contains ?
                                adown.contains( bup ) :
                                a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
                        ));
                    } :
                    function( a, b ) {
                        if ( b ) {
                            while ( (b = b.parentNode) ) {
                                if ( b === a ) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };

                /* Sorting
	---------------------------------------------------------------------- */

                // Document order sorting
                sortOrder = hasCompare ?
                    function( a, b ) {

                        // Flag for duplicate removal
                        if ( a === b ) {
                            hasDuplicate = true;
                            return 0;
                        }

                        // Sort on method existence if only one input has compareDocumentPosition
                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        if ( compare ) {
                            return compare;
                        }

                        // Calculate position if both inputs belong to the same document
                        compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
                            a.compareDocumentPosition( b ) :

                            // Otherwise we know they are disconnected
                            1;

                        // Disconnected nodes
                        if ( compare & 1 ||
                            (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

                            // Choose the first element that is related to our preferred document
                            if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
                                return -1;
                            }
                            if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
                                return 1;
                            }

                            // Maintain original order
                            return sortInput ?
                                ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                                0;
                        }

                        return compare & 4 ? -1 : 1;
                    } :
                    function( a, b ) {
                        // Exit early if the nodes are identical
                        if ( a === b ) {
                            hasDuplicate = true;
                            return 0;
                        }

                        var cur,
                            i = 0,
                            aup = a.parentNode,
                            bup = b.parentNode,
                            ap = [ a ],
                            bp = [ b ];

                        // Parentless nodes are either documents or disconnected
                        if ( !aup || !bup ) {
                            return a === doc ? -1 :
                                b === doc ? 1 :
                                    aup ? -1 :
                                        bup ? 1 :
                                            sortInput ?
                                                ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
                                                0;

                            // If the nodes are siblings, we can do a quick check
                        } else if ( aup === bup ) {
                            return siblingCheck( a, b );
                        }

                        // Otherwise we need full lists of their ancestors for comparison
                        cur = a;
                        while ( (cur = cur.parentNode) ) {
                            ap.unshift( cur );
                        }
                        cur = b;
                        while ( (cur = cur.parentNode) ) {
                            bp.unshift( cur );
                        }

                        // Walk down the tree looking for a discrepancy
                        while ( ap[i] === bp[i] ) {
                            i++;
                        }

                        return i ?
                            // Do a sibling check if the nodes have a common ancestor
                            siblingCheck( ap[i], bp[i] ) :

                            // Otherwise nodes in our document sort first
                            ap[i] === preferredDoc ? -1 :
                                bp[i] === preferredDoc ? 1 :
                                    0;
                    };

                return doc;
            };

            Sizzle.matches = function( expr, elements ) {
                return Sizzle( expr, null, null, elements );
            };

            Sizzle.matchesSelector = function( elem, expr ) {
                // Set document vars if needed
                if ( ( elem.ownerDocument || elem ) !== document ) {
                    setDocument( elem );
                }

                // Make sure that attribute selectors are quoted
                expr = expr.replace( rattributeQuotes, "='$1']" );

                if ( support.matchesSelector && documentIsHTML &&
                    ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
                    ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

                    try {
                        var ret = matches.call( elem, expr );

                        // IE 9's matchesSelector returns false on disconnected nodes
                        if ( ret || support.disconnectedMatch ||
                            // As well, disconnected nodes are said to be in a document
                            // fragment in IE 9
                            elem.document && elem.document.nodeType !== 11 ) {
                            return ret;
                        }
                    } catch (e) {}
                }

                return Sizzle( expr, document, null, [ elem ] ).length > 0;
            };

            Sizzle.contains = function( context, elem ) {
                // Set document vars if needed
                if ( ( context.ownerDocument || context ) !== document ) {
                    setDocument( context );
                }
                return contains( context, elem );
            };

            Sizzle.attr = function( elem, name ) {
                // Set document vars if needed
                if ( ( elem.ownerDocument || elem ) !== document ) {
                    setDocument( elem );
                }

                var fn = Expr.attrHandle[ name.toLowerCase() ],
                    // Don't get fooled by Object.prototype properties (jQuery #13807)
                    val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
                        fn( elem, name, !documentIsHTML ) :
                        undefined;

                return val !== undefined ?
                    val :
                    support.attributes || !documentIsHTML ?
                        elem.getAttribute( name ) :
                        (val = elem.getAttributeNode(name)) && val.specified ?
                            val.value :
                            null;
            };

            Sizzle.error = function( msg ) {
                throw new Error( "Syntax error, unrecognized expression: " + msg );
            };

            /**
             * Document sorting and removing duplicates
             * @param {ArrayLike} results
             */
            Sizzle.uniqueSort = function( results ) {
                var elem,
                    duplicates = [],
                    j = 0,
                    i = 0;

                // Unless we *know* we can detect duplicates, assume their presence
                hasDuplicate = !support.detectDuplicates;
                sortInput = !support.sortStable && results.slice( 0 );
                results.sort( sortOrder );

                if ( hasDuplicate ) {
                    while ( (elem = results[i++]) ) {
                        if ( elem === results[ i ] ) {
                            j = duplicates.push( i );
                        }
                    }
                    while ( j-- ) {
                        results.splice( duplicates[ j ], 1 );
                    }
                }

                // Clear input after sorting to release objects
                // See https://github.com/jquery/sizzle/pull/225
                sortInput = null;

                return results;
            };

            /**
             * Utility function for retrieving the text value of an array of DOM nodes
             * @param {Array|Element} elem
             */
            getText = Sizzle.getText = function( elem ) {
                var node,
                    ret = "",
                    i = 0,
                    nodeType = elem.nodeType;

                if ( !nodeType ) {
                    // If no nodeType, this is expected to be an array
                    while ( (node = elem[i++]) ) {
                        // Do not traverse comment nodes
                        ret += getText( node );
                    }
                } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
                    // Use textContent for elements
                    // innerText usage removed for consistency of new lines (jQuery #11153)
                    if ( typeof elem.textContent === "string" ) {
                        return elem.textContent;
                    } else {
                        // Traverse its children
                        for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                            ret += getText( elem );
                        }
                    }
                } else if ( nodeType === 3 || nodeType === 4 ) {
                    return elem.nodeValue;
                }
                // Do not include comment or processing instruction nodes

                return ret;
            };

            Expr = Sizzle.selectors = {

                // Can be adjusted by the user
                cacheLength: 50,

                createPseudo: markFunction,

                match: matchExpr,

                attrHandle: {},

                find: {},

                relative: {
                    ">": { dir: "parentNode", first: true },
                    " ": { dir: "parentNode" },
                    "+": { dir: "previousSibling", first: true },
                    "~": { dir: "previousSibling" }
                },

                preFilter: {
                    "ATTR": function( match ) {
                        match[1] = match[1].replace( runescape, funescape );

                        // Move the given value to match[3] whether quoted or unquoted
                        match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

                        if ( match[2] === "~=" ) {
                            match[3] = " " + match[3] + " ";
                        }

                        return match.slice( 0, 4 );
                    },

                    "CHILD": function( match ) {
                        /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                        match[1] = match[1].toLowerCase();

                        if ( match[1].slice( 0, 3 ) === "nth" ) {
                            // nth-* requires argument
                            if ( !match[3] ) {
                                Sizzle.error( match[0] );
                            }

                            // numeric x and y parameters for Expr.filter.CHILD
                            // remember that false/true cast respectively to 0/1
                            match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
                            match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

                            // other types prohibit arguments
                        } else if ( match[3] ) {
                            Sizzle.error( match[0] );
                        }

                        return match;
                    },

                    "PSEUDO": function( match ) {
                        var excess,
                            unquoted = !match[6] && match[2];

                        if ( matchExpr["CHILD"].test( match[0] ) ) {
                            return null;
                        }

                        // Accept quoted arguments as-is
                        if ( match[3] ) {
                            match[2] = match[4] || match[5] || "";

                            // Strip excess characters from unquoted arguments
                        } else if ( unquoted && rpseudo.test( unquoted ) &&
                            // Get excess from tokenize (recursively)
                            (excess = tokenize( unquoted, true )) &&
                            // advance to the next closing parenthesis
                            (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

                            // excess is a negative index
                            match[0] = match[0].slice( 0, excess );
                            match[2] = unquoted.slice( 0, excess );
                        }

                        // Return only captures needed by the pseudo filter method (type and argument)
                        return match.slice( 0, 3 );
                    }
                },

                filter: {

                    "TAG": function( nodeNameSelector ) {
                        var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
                        return nodeNameSelector === "*" ?
                            function() { return true; } :
                            function( elem ) {
                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                            };
                    },

                    "CLASS": function( className ) {
                        var pattern = classCache[ className + " " ];

                        return pattern ||
                            (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
                            classCache( className, function( elem ) {
                                return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
                            });
                    },

                    "ATTR": function( name, operator, check ) {
                        return function( elem ) {
                            var result = Sizzle.attr( elem, name );

                            if ( result == null ) {
                                return operator === "!=";
                            }
                            if ( !operator ) {
                                return true;
                            }

                            result += "";

                            return operator === "=" ? result === check :
                                operator === "!=" ? result !== check :
                                    operator === "^=" ? check && result.indexOf( check ) === 0 :
                                        operator === "*=" ? check && result.indexOf( check ) > -1 :
                                            operator === "$=" ? check && result.slice( -check.length ) === check :
                                                operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
                                                    operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                                                        false;
                        };
                    },

                    "CHILD": function( type, what, argument, first, last ) {
                        var simple = type.slice( 0, 3 ) !== "nth",
                            forward = type.slice( -4 ) !== "last",
                            ofType = what === "of-type";

                        return first === 1 && last === 0 ?

                            // Shortcut for :nth-*(n)
                            function( elem ) {
                                return !!elem.parentNode;
                            } :

                            function( elem, context, xml ) {
                                var cache, outerCache, node, diff, nodeIndex, start,
                                    dir = simple !== forward ? "nextSibling" : "previousSibling",
                                    parent = elem.parentNode,
                                    name = ofType && elem.nodeName.toLowerCase(),
                                    useCache = !xml && !ofType;

                                if ( parent ) {

                                    // :(first|last|only)-(child|of-type)
                                    if ( simple ) {
                                        while ( dir ) {
                                            node = elem;
                                            while ( (node = node[ dir ]) ) {
                                                if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
                                                    return false;
                                                }
                                            }
                                            // Reverse direction for :only-* (if we haven't yet done so)
                                            start = dir = type === "only" && !start && "nextSibling";
                                        }
                                        return true;
                                    }

                                    start = [ forward ? parent.firstChild : parent.lastChild ];

                                    // non-xml :nth-child(...) stores cache data on `parent`
                                    if ( forward && useCache ) {
                                        // Seek `elem` from a previously-cached index
                                        outerCache = parent[ expando ] || (parent[ expando ] = {});
                                        cache = outerCache[ type ] || [];
                                        nodeIndex = cache[0] === dirruns && cache[1];
                                        diff = cache[0] === dirruns && cache[2];
                                        node = nodeIndex && parent.childNodes[ nodeIndex ];

                                        while ( (node = ++nodeIndex && node && node[ dir ] ||

                                            // Fallback to seeking `elem` from the start
                                            (diff = nodeIndex = 0) || start.pop()) ) {

                                            // When found, cache indexes on `parent` and break
                                            if ( node.nodeType === 1 && ++diff && node === elem ) {
                                                outerCache[ type ] = [ dirruns, nodeIndex, diff ];
                                                break;
                                            }
                                        }

                                        // Use previously-cached element index if available
                                    } else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
                                        diff = cache[1];

                                        // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                    } else {
                                        // Use the same loop as above to seek `elem` from the start
                                        while ( (node = ++nodeIndex && node && node[ dir ] ||
                                            (diff = nodeIndex = 0) || start.pop()) ) {

                                            if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
                                                // Cache the index of each encountered element
                                                if ( useCache ) {
                                                    (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
                                                }

                                                if ( node === elem ) {
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                    // Incorporate the offset, then check against cycle size
                                    diff -= last;
                                    return diff === first || ( diff % first === 0 && diff / first >= 0 );
                                }
                            };
                    },

                    "PSEUDO": function( pseudo, argument ) {
                        // pseudo-class names are case-insensitive
                        // http://www.w3.org/TR/selectors/#pseudo-classes
                        // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                        // Remember that setFilters inherits from pseudos
                        var args,
                            fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                                Sizzle.error( "unsupported pseudo: " + pseudo );

                        // The user may use createPseudo to indicate that
                        // arguments are needed to create the filter function
                        // just as Sizzle does
                        if ( fn[ expando ] ) {
                            return fn( argument );
                        }

                        // But maintain support for old signatures
                        if ( fn.length > 1 ) {
                            args = [ pseudo, pseudo, "", argument ];
                            return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                                markFunction(function( seed, matches ) {
                                    var idx,
                                        matched = fn( seed, argument ),
                                        i = matched.length;
                                    while ( i-- ) {
                                        idx = indexOf( seed, matched[i] );
                                        seed[ idx ] = !( matches[ idx ] = matched[i] );
                                    }
                                }) :
                                function( elem ) {
                                    return fn( elem, 0, args );
                                };
                        }

                        return fn;
                    }
                },

                pseudos: {
                    // Potentially complex pseudos
                    "not": markFunction(function( selector ) {
                        // Trim the selector passed to compile
                        // to avoid treating leading and trailing
                        // spaces as combinators
                        var input = [],
                            results = [],
                            matcher = compile( selector.replace( rtrim, "$1" ) );

                        return matcher[ expando ] ?
                            markFunction(function( seed, matches, context, xml ) {
                                var elem,
                                    unmatched = matcher( seed, null, xml, [] ),
                                    i = seed.length;

                                // Match elements unmatched by `matcher`
                                while ( i-- ) {
                                    if ( (elem = unmatched[i]) ) {
                                        seed[i] = !(matches[i] = elem);
                                    }
                                }
                            }) :
                            function( elem, context, xml ) {
                                input[0] = elem;
                                matcher( input, null, xml, results );
                                // Don't keep the element (issue #299)
                                input[0] = null;
                                return !results.pop();
                            };
                    }),

                    "has": markFunction(function( selector ) {
                        return function( elem ) {
                            return Sizzle( selector, elem ).length > 0;
                        };
                    }),

                    "contains": markFunction(function( text ) {
                        text = text.replace( runescape, funescape );
                        return function( elem ) {
                            return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
                        };
                    }),

                    // "Whether an element is represented by a :lang() selector
                    // is based solely on the element's language value
                    // being equal to the identifier C,
                    // or beginning with the identifier C immediately followed by "-".
                    // The matching of C against the element's language value is performed case-insensitively.
                    // The identifier C does not have to be a valid language name."
                    // http://www.w3.org/TR/selectors/#lang-pseudo
                    "lang": markFunction( function( lang ) {
                        // lang value must be a valid identifier
                        if ( !ridentifier.test(lang || "") ) {
                            Sizzle.error( "unsupported lang: " + lang );
                        }
                        lang = lang.replace( runescape, funescape ).toLowerCase();
                        return function( elem ) {
                            var elemLang;
                            do {
                                if ( (elemLang = documentIsHTML ?
                                    elem.lang :
                                    elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

                                    elemLang = elemLang.toLowerCase();
                                    return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                                }
                            } while ( (elem = elem.parentNode) && elem.nodeType === 1 );
                            return false;
                        };
                    }),

                    // Miscellaneous
                    "target": function( elem ) {
                        var hash = window.location && window.location.hash;
                        return hash && hash.slice( 1 ) === elem.id;
                    },

                    "root": function( elem ) {
                        return elem === docElem;
                    },

                    "focus": function( elem ) {
                        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                    },

                    // Boolean properties
                    "enabled": function( elem ) {
                        return elem.disabled === false;
                    },

                    "disabled": function( elem ) {
                        return elem.disabled === true;
                    },

                    "checked": function( elem ) {
                        // In CSS3, :checked should return both checked and selected elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        var nodeName = elem.nodeName.toLowerCase();
                        return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                    },

                    "selected": function( elem ) {
                        // Accessing this property makes selected-by-default
                        // options in Safari work properly
                        if ( elem.parentNode ) {
                            elem.parentNode.selectedIndex;
                        }

                        return elem.selected === true;
                    },

                    // Contents
                    "empty": function( elem ) {
                        // http://www.w3.org/TR/selectors/#empty-pseudo
                        // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                        //   but not by others (comment: 8; processing instruction: 7; etc.)
                        // nodeType < 6 works because attributes (2) do not appear as children
                        for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                            if ( elem.nodeType < 6 ) {
                                return false;
                            }
                        }
                        return true;
                    },

                    "parent": function( elem ) {
                        return !Expr.pseudos["empty"]( elem );
                    },

                    // Element/input types
                    "header": function( elem ) {
                        return rheader.test( elem.nodeName );
                    },

                    "input": function( elem ) {
                        return rinputs.test( elem.nodeName );
                    },

                    "button": function( elem ) {
                        var name = elem.nodeName.toLowerCase();
                        return name === "input" && elem.type === "button" || name === "button";
                    },

                    "text": function( elem ) {
                        var attr;
                        return elem.nodeName.toLowerCase() === "input" &&
                            elem.type === "text" &&

                            // Support: IE<8
                            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                            ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
                    },

                    // Position-in-collection
                    "first": createPositionalPseudo(function() {
                        return [ 0 ];
                    }),

                    "last": createPositionalPseudo(function( matchIndexes, length ) {
                        return [ length - 1 ];
                    }),

                    "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
                        return [ argument < 0 ? argument + length : argument ];
                    }),

                    "even": createPositionalPseudo(function( matchIndexes, length ) {
                        var i = 0;
                        for ( ; i < length; i += 2 ) {
                            matchIndexes.push( i );
                        }
                        return matchIndexes;
                    }),

                    "odd": createPositionalPseudo(function( matchIndexes, length ) {
                        var i = 1;
                        for ( ; i < length; i += 2 ) {
                            matchIndexes.push( i );
                        }
                        return matchIndexes;
                    }),

                    "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                        var i = argument < 0 ? argument + length : argument;
                        for ( ; --i >= 0; ) {
                            matchIndexes.push( i );
                        }
                        return matchIndexes;
                    }),

                    "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
                        var i = argument < 0 ? argument + length : argument;
                        for ( ; ++i < length; ) {
                            matchIndexes.push( i );
                        }
                        return matchIndexes;
                    })
                }
            };

            Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
            for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
                Expr.pseudos[ i ] = createInputPseudo( i );
            }
            for ( i in { submit: true, reset: true } ) {
                Expr.pseudos[ i ] = createButtonPseudo( i );
            }

// Easy API for creating new setFilters
            function setFilters() {}
            setFilters.prototype = Expr.filters = Expr.pseudos;
            Expr.setFilters = new setFilters();

            tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
                var matched, match, tokens, type,
                    soFar, groups, preFilters,
                    cached = tokenCache[ selector + " " ];

                if ( cached ) {
                    return parseOnly ? 0 : cached.slice( 0 );
                }

                soFar = selector;
                groups = [];
                preFilters = Expr.preFilter;

                while ( soFar ) {

                    // Comma and first run
                    if ( !matched || (match = rcomma.exec( soFar )) ) {
                        if ( match ) {
                            // Don't consume trailing commas as valid
                            soFar = soFar.slice( match[0].length ) || soFar;
                        }
                        groups.push( (tokens = []) );
                    }

                    matched = false;

                    // Combinators
                    if ( (match = rcombinators.exec( soFar )) ) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            // Cast descendant combinators to space
                            type: match[0].replace( rtrim, " " )
                        });
                        soFar = soFar.slice( matched.length );
                    }

                    // Filters
                    for ( type in Expr.filter ) {
                        if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
                            (match = preFilters[ type ]( match ))) ) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                type: type,
                                matches: match
                            });
                            soFar = soFar.slice( matched.length );
                        }
                    }

                    if ( !matched ) {
                        break;
                    }
                }

                // Return the length of the invalid excess
                // if we're just parsing
                // Otherwise, throw an error or return tokens
                return parseOnly ?
                    soFar.length :
                    soFar ?
                        Sizzle.error( selector ) :
                        // Cache the tokens
                        tokenCache( selector, groups ).slice( 0 );
            };

            function toSelector( tokens ) {
                var i = 0,
                    len = tokens.length,
                    selector = "";
                for ( ; i < len; i++ ) {
                    selector += tokens[i].value;
                }
                return selector;
            }

            function addCombinator( matcher, combinator, base ) {
                var dir = combinator.dir,
                    checkNonElements = base && dir === "parentNode",
                    doneName = done++;

                return combinator.first ?
                    // Check against closest ancestor/preceding element
                    function( elem, context, xml ) {
                        while ( (elem = elem[ dir ]) ) {
                            if ( elem.nodeType === 1 || checkNonElements ) {
                                return matcher( elem, context, xml );
                            }
                        }
                    } :

                    // Check against all ancestor/preceding elements
                    function( elem, context, xml ) {
                        var oldCache, outerCache,
                            newCache = [ dirruns, doneName ];

                        // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
                        if ( xml ) {
                            while ( (elem = elem[ dir ]) ) {
                                if ( elem.nodeType === 1 || checkNonElements ) {
                                    if ( matcher( elem, context, xml ) ) {
                                        return true;
                                    }
                                }
                            }
                        } else {
                            while ( (elem = elem[ dir ]) ) {
                                if ( elem.nodeType === 1 || checkNonElements ) {
                                    outerCache = elem[ expando ] || (elem[ expando ] = {});
                                    if ( (oldCache = outerCache[ dir ]) &&
                                        oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

                                        // Assign to newCache so results back-propagate to previous elements
                                        return (newCache[ 2 ] = oldCache[ 2 ]);
                                    } else {
                                        // Reuse newcache so results back-propagate to previous elements
                                        outerCache[ dir ] = newCache;

                                        // A match means we're done; a fail means we have to keep checking
                                        if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    };
            }

            function elementMatcher( matchers ) {
                return matchers.length > 1 ?
                    function( elem, context, xml ) {
                        var i = matchers.length;
                        while ( i-- ) {
                            if ( !matchers[i]( elem, context, xml ) ) {
                                return false;
                            }
                        }
                        return true;
                    } :
                    matchers[0];
            }

            function multipleContexts( selector, contexts, results ) {
                var i = 0,
                    len = contexts.length;
                for ( ; i < len; i++ ) {
                    Sizzle( selector, contexts[i], results );
                }
                return results;
            }

            function condense( unmatched, map, filter, context, xml ) {
                var elem,
                    newUnmatched = [],
                    i = 0,
                    len = unmatched.length,
                    mapped = map != null;

                for ( ; i < len; i++ ) {
                    if ( (elem = unmatched[i]) ) {
                        if ( !filter || filter( elem, context, xml ) ) {
                            newUnmatched.push( elem );
                            if ( mapped ) {
                                map.push( i );
                            }
                        }
                    }
                }

                return newUnmatched;
            }

            function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
                if ( postFilter && !postFilter[ expando ] ) {
                    postFilter = setMatcher( postFilter );
                }
                if ( postFinder && !postFinder[ expando ] ) {
                    postFinder = setMatcher( postFinder, postSelector );
                }
                return markFunction(function( seed, results, context, xml ) {
                    var temp, i, elem,
                        preMap = [],
                        postMap = [],
                        preexisting = results.length,

                        // Get initial elements from seed or context
                        elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

                        // Prefilter to get matcher input, preserving a map for seed-results synchronization
                        matcherIn = preFilter && ( seed || !selector ) ?
                            condense( elems, preMap, preFilter, context, xml ) :
                            elems,

                        matcherOut = matcher ?
                            // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                            postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                                // ...intermediate processing is necessary
                                [] :

                                // ...otherwise use results directly
                                results :
                            matcherIn;

                    // Find primary matches
                    if ( matcher ) {
                        matcher( matcherIn, matcherOut, context, xml );
                    }

                    // Apply postFilter
                    if ( postFilter ) {
                        temp = condense( matcherOut, postMap );
                        postFilter( temp, [], context, xml );

                        // Un-match failing elements by moving them back to matcherIn
                        i = temp.length;
                        while ( i-- ) {
                            if ( (elem = temp[i]) ) {
                                matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                            }
                        }
                    }

                    if ( seed ) {
                        if ( postFinder || preFilter ) {
                            if ( postFinder ) {
                                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                temp = [];
                                i = matcherOut.length;
                                while ( i-- ) {
                                    if ( (elem = matcherOut[i]) ) {
                                        // Restore matcherIn since elem is not yet a final match
                                        temp.push( (matcherIn[i] = elem) );
                                    }
                                }
                                postFinder( null, (matcherOut = []), temp, xml );
                            }

                            // Move matched elements from seed to results to keep them synchronized
                            i = matcherOut.length;
                            while ( i-- ) {
                                if ( (elem = matcherOut[i]) &&
                                    (temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

                                    seed[temp] = !(results[temp] = elem);
                                }
                            }
                        }

                        // Add elements to results, through postFinder if defined
                    } else {
                        matcherOut = condense(
                            matcherOut === results ?
                                matcherOut.splice( preexisting, matcherOut.length ) :
                                matcherOut
                        );
                        if ( postFinder ) {
                            postFinder( null, results, matcherOut, xml );
                        } else {
                            push.apply( results, matcherOut );
                        }
                    }
                });
            }

            function matcherFromTokens( tokens ) {
                var checkContext, matcher, j,
                    len = tokens.length,
                    leadingRelative = Expr.relative[ tokens[0].type ],
                    implicitRelative = leadingRelative || Expr.relative[" "],
                    i = leadingRelative ? 1 : 0,

                    // The foundational matcher ensures that elements are reachable from top-level context(s)
                    matchContext = addCombinator( function( elem ) {
                        return elem === checkContext;
                    }, implicitRelative, true ),
                    matchAnyContext = addCombinator( function( elem ) {
                        return indexOf( checkContext, elem ) > -1;
                    }, implicitRelative, true ),
                    matchers = [ function( elem, context, xml ) {
                        var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                            (checkContext = context).nodeType ?
                                matchContext( elem, context, xml ) :
                                matchAnyContext( elem, context, xml ) );
                        // Avoid hanging onto element (issue #299)
                        checkContext = null;
                        return ret;
                    } ];

                for ( ; i < len; i++ ) {
                    if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
                        matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
                    } else {
                        matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

                        // Return special upon seeing a positional matcher
                        if ( matcher[ expando ] ) {
                            // Find the next relative operator (if any) for proper handling
                            j = ++i;
                            for ( ; j < len; j++ ) {
                                if ( Expr.relative[ tokens[j].type ] ) {
                                    break;
                                }
                            }
                            return setMatcher(
                                i > 1 && elementMatcher( matchers ),
                                i > 1 && toSelector(
                                // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
                                ).replace( rtrim, "$1" ),
                                matcher,
                                i < j && matcherFromTokens( tokens.slice( i, j ) ),
                                j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
                                j < len && toSelector( tokens )
                            );
                        }
                        matchers.push( matcher );
                    }
                }

                return elementMatcher( matchers );
            }

            function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
                var bySet = setMatchers.length > 0,
                    byElement = elementMatchers.length > 0,
                    superMatcher = function( seed, context, xml, results, outermost ) {
                        var elem, j, matcher,
                            matchedCount = 0,
                            i = "0",
                            unmatched = seed && [],
                            setMatched = [],
                            contextBackup = outermostContext,
                            // We must always have either seed elements or outermost context
                            elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
                            // Use integer dirruns iff this is the outermost matcher
                            dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                            len = elems.length;

                        if ( outermost ) {
                            outermostContext = context !== document && context;
                        }

                        // Add elements passing elementMatchers directly to results
                        // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
                        // Support: IE<9, Safari
                        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                        for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
                            if ( byElement && elem ) {
                                j = 0;
                                while ( (matcher = elementMatchers[j++]) ) {
                                    if ( matcher( elem, context, xml ) ) {
                                        results.push( elem );
                                        break;
                                    }
                                }
                                if ( outermost ) {
                                    dirruns = dirrunsUnique;
                                }
                            }

                            // Track unmatched elements for set filters
                            if ( bySet ) {
                                // They will have gone through all possible matchers
                                if ( (elem = !matcher && elem) ) {
                                    matchedCount--;
                                }

                                // Lengthen the array for every element, matched or not
                                if ( seed ) {
                                    unmatched.push( elem );
                                }
                            }
                        }

                        // Apply set filters to unmatched elements
                        matchedCount += i;
                        if ( bySet && i !== matchedCount ) {
                            j = 0;
                            while ( (matcher = setMatchers[j++]) ) {
                                matcher( unmatched, setMatched, context, xml );
                            }

                            if ( seed ) {
                                // Reintegrate element matches to eliminate the need for sorting
                                if ( matchedCount > 0 ) {
                                    while ( i-- ) {
                                        if ( !(unmatched[i] || setMatched[i]) ) {
                                            setMatched[i] = pop.call( results );
                                        }
                                    }
                                }

                                // Discard index placeholder values to get only actual matches
                                setMatched = condense( setMatched );
                            }

                            // Add matches to results
                            push.apply( results, setMatched );

                            // Seedless set matches succeeding multiple successful matchers stipulate sorting
                            if ( outermost && !seed && setMatched.length > 0 &&
                                ( matchedCount + setMatchers.length ) > 1 ) {

                                Sizzle.uniqueSort( results );
                            }
                        }

                        // Override manipulation of globals by nested matchers
                        if ( outermost ) {
                            dirruns = dirrunsUnique;
                            outermostContext = contextBackup;
                        }

                        return unmatched;
                    };

                return bySet ?
                    markFunction( superMatcher ) :
                    superMatcher;
            }

            compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
                var i,
                    setMatchers = [],
                    elementMatchers = [],
                    cached = compilerCache[ selector + " " ];

                if ( !cached ) {
                    // Generate a function of recursive functions that can be used to check each element
                    if ( !match ) {
                        match = tokenize( selector );
                    }
                    i = match.length;
                    while ( i-- ) {
                        cached = matcherFromTokens( match[i] );
                        if ( cached[ expando ] ) {
                            setMatchers.push( cached );
                        } else {
                            elementMatchers.push( cached );
                        }
                    }

                    // Cache the compiled function
                    cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

                    // Save selector and tokenization
                    cached.selector = selector;
                }
                return cached;
            };

            /**
             * A low-level selection function that works with Sizzle's compiled
             *  selector functions
             * @param {String|Function} selector A selector or a pre-compiled
             *  selector function built with Sizzle.compile
             * @param {Element} context
             * @param {Array} [results]
             * @param {Array} [seed] A set of elements to match against
             */
            select = Sizzle.select = function( selector, context, results, seed ) {
                var i, tokens, token, type, find,
                    compiled = typeof selector === "function" && selector,
                    match = !seed && tokenize( (selector = compiled.selector || selector) );

                results = results || [];

                // Try to minimize operations if there is no seed and only one group
                if ( match.length === 1 ) {

                    // Take a shortcut and set the context if the root selector is an ID
                    tokens = match[0] = match[0].slice( 0 );
                    if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                        support.getById && context.nodeType === 9 && documentIsHTML &&
                        Expr.relative[ tokens[1].type ] ) {

                        context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
                        if ( !context ) {
                            return results;

                            // Precompiled matchers will still verify ancestry, so step up a level
                        } else if ( compiled ) {
                            context = context.parentNode;
                        }

                        selector = selector.slice( tokens.shift().value.length );
                    }

                    // Fetch a seed set for right-to-left matching
                    i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
                    while ( i-- ) {
                        token = tokens[i];

                        // Abort if we hit a combinator
                        if ( Expr.relative[ (type = token.type) ] ) {
                            break;
                        }
                        if ( (find = Expr.find[ type ]) ) {
                            // Search, expanding context for leading sibling combinators
                            if ( (seed = find(
                                token.matches[0].replace( runescape, funescape ),
                                rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
                            )) ) {

                                // If seed is empty or no tokens remain, we can return early
                                tokens.splice( i, 1 );
                                selector = seed.length && toSelector( tokens );
                                if ( !selector ) {
                                    push.apply( results, seed );
                                    return results;
                                }

                                break;
                            }
                        }
                    }
                }

                // Compile and execute a filtering function if one is not provided
                // Provide `match` to avoid retokenization if we modified the selector above
                ( compiled || compile( selector, match ) )(
                    seed,
                    context,
                    !documentIsHTML,
                    results,
                    rsibling.test( selector ) && testContext( context.parentNode ) || context
                );
                return results;
            };

// One-time assignments

// Sort stability
            support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
            support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
            setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
            support.sortDetached = assert(function( div1 ) {
                // Should return 1, but returns 4 (following)
                return div1.compareDocumentPosition( document.createElement("div") ) & 1;
            });

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
            if ( !assert(function( div ) {
                div.innerHTML = "<a href='#'></a>";
                return div.firstChild.getAttribute("href") === "#" ;
            }) ) {
                addHandle( "type|href|height|width", function( elem, name, isXML ) {
                    if ( !isXML ) {
                        return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
                    }
                });
            }

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
            if ( !support.attributes || !assert(function( div ) {
                div.innerHTML = "<input/>";
                div.firstChild.setAttribute( "value", "" );
                return div.firstChild.getAttribute( "value" ) === "";
            }) ) {
                addHandle( "value", function( elem, name, isXML ) {
                    if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
                        return elem.defaultValue;
                    }
                });
            }

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
            if ( !assert(function( div ) {
                return div.getAttribute("disabled") == null;
            }) ) {
                addHandle( booleans, function( elem, name, isXML ) {
                    var val;
                    if ( !isXML ) {
                        return elem[ name ] === true ? name.toLowerCase() :
                            (val = elem.getAttributeNode( name )) && val.specified ?
                                val.value :
                                null;
                    }
                });
            }

            return Sizzle;

        })( window );



    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;



    var rneedsContext = jQuery.expr.match.needsContext;

    var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



    var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
    function winnow( elements, qualifier, not ) {
        if ( jQuery.isFunction( qualifier ) ) {
            return jQuery.grep( elements, function( elem, i ) {
                /* jshint -W018 */
                return !!qualifier.call( elem, i, elem ) !== not;
            });

        }

        if ( qualifier.nodeType ) {
            return jQuery.grep( elements, function( elem ) {
                return ( elem === qualifier ) !== not;
            });

        }

        if ( typeof qualifier === "string" ) {
            if ( risSimple.test( qualifier ) ) {
                return jQuery.filter( qualifier, elements, not );
            }

            qualifier = jQuery.filter( qualifier, elements );
        }

        return jQuery.grep( elements, function( elem ) {
            return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
        });
    }

    jQuery.filter = function( expr, elems, not ) {
        var elem = elems[ 0 ];

        if ( not ) {
            expr = ":not(" + expr + ")";
        }

        return elems.length === 1 && elem.nodeType === 1 ?
            jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
            jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
                return elem.nodeType === 1;
            }));
    };

    jQuery.fn.extend({
        find: function( selector ) {
            var i,
                ret = [],
                self = this,
                len = self.length;

            if ( typeof selector !== "string" ) {
                return this.pushStack( jQuery( selector ).filter(function() {
                    for ( i = 0; i < len; i++ ) {
                        if ( jQuery.contains( self[ i ], this ) ) {
                            return true;
                        }
                    }
                }) );
            }

            for ( i = 0; i < len; i++ ) {
                jQuery.find( selector, self[ i ], ret );
            }

            // Needed because $( selector, context ) becomes $( context ).find( selector )
            ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret;
        },
        filter: function( selector ) {
            return this.pushStack( winnow(this, selector || [], false) );
        },
        not: function( selector ) {
            return this.pushStack( winnow(this, selector || [], true) );
        },
        is: function( selector ) {
            return !!winnow(
                this,

                // If this is a positional/relative selector, check membership in the returned set
                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                typeof selector === "string" && rneedsContext.test( selector ) ?
                    jQuery( selector ) :
                    selector || [],
                false
            ).length;
        }
    });


// Initialize a jQuery object


// A central reference to the root jQuery(document)
    var rootjQuery,

        // Use the correct document accordingly with window argument (sandbox)
        document = window.document,

        // A simple way to check for HTML strings
        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
        // Strict HTML recognition (#11290: must start with <)
        rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

        init = jQuery.fn.init = function( selector, context ) {
            var match, elem;

            // HANDLE: $(""), $(null), $(undefined), $(false)
            if ( !selector ) {
                return this;
            }

            // Handle HTML strings
            if ( typeof selector === "string" ) {
                if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
                    // Assume that strings that start and end with <> are HTML and skip the regex check
                    match = [ null, selector, null ];

                } else {
                    match = rquickExpr.exec( selector );
                }

                // Match html or make sure no context is specified for #id
                if ( match && (match[1] || !context) ) {

                    // HANDLE: $(html) -> $(array)
                    if ( match[1] ) {
                        context = context instanceof jQuery ? context[0] : context;

                        // scripts is true for back-compat
                        // Intentionally let the error be thrown if parseHTML is not present
                        jQuery.merge( this, jQuery.parseHTML(
                            match[1],
                            context && context.nodeType ? context.ownerDocument || context : document,
                            true
                        ) );

                        // HANDLE: $(html, props)
                        if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
                            for ( match in context ) {
                                // Properties of context are called as methods if possible
                                if ( jQuery.isFunction( this[ match ] ) ) {
                                    this[ match ]( context[ match ] );

                                    // ...and otherwise set as attributes
                                } else {
                                    this.attr( match, context[ match ] );
                                }
                            }
                        }

                        return this;

                        // HANDLE: $(#id)
                    } else {
                        elem = document.getElementById( match[2] );

                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        if ( elem && elem.parentNode ) {
                            // Handle the case where IE and Opera return items
                            // by name instead of ID
                            if ( elem.id !== match[2] ) {
                                return rootjQuery.find( selector );
                            }

                            // Otherwise, we inject the element directly into the jQuery object
                            this.length = 1;
                            this[0] = elem;
                        }

                        this.context = document;
                        this.selector = selector;
                        return this;
                    }

                    // HANDLE: $(expr, $(...))
                } else if ( !context || context.jquery ) {
                    return ( context || rootjQuery ).find( selector );

                    // HANDLE: $(expr, context)
                    // (which is just equivalent to: $(context).find(expr)
                } else {
                    return this.constructor( context ).find( selector );
                }

                // HANDLE: $(DOMElement)
            } else if ( selector.nodeType ) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;

                // HANDLE: $(function)
                // Shortcut for document ready
            } else if ( jQuery.isFunction( selector ) ) {
                return typeof rootjQuery.ready !== "undefined" ?
                    rootjQuery.ready( selector ) :
                    // Execute immediately if ready is not present
                    selector( jQuery );
            }

            if ( selector.selector !== undefined ) {
                this.selector = selector.selector;
                this.context = selector.context;
            }

            return jQuery.makeArray( selector, this );
        };

// Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;

// Initialize central reference
    rootjQuery = jQuery( document );


    var rparentsprev = /^(?:parents|prev(?:Until|All))/,
        // methods guaranteed to produce a unique set when starting from a unique set
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };

    jQuery.extend({
        dir: function( elem, dir, until ) {
            var matched = [],
                cur = elem[ dir ];

            while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
                if ( cur.nodeType === 1 ) {
                    matched.push( cur );
                }
                cur = cur[dir];
            }
            return matched;
        },

        sibling: function( n, elem ) {
            var r = [];

            for ( ; n; n = n.nextSibling ) {
                if ( n.nodeType === 1 && n !== elem ) {
                    r.push( n );
                }
            }

            return r;
        }
    });

    jQuery.fn.extend({
        has: function( target ) {
            var i,
                targets = jQuery( target, this ),
                len = targets.length;

            return this.filter(function() {
                for ( i = 0; i < len; i++ ) {
                    if ( jQuery.contains( this, targets[i] ) ) {
                        return true;
                    }
                }
            });
        },

        closest: function( selectors, context ) {
            var cur,
                i = 0,
                l = this.length,
                matched = [],
                pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
                    jQuery( selectors, context || this.context ) :
                    0;

            for ( ; i < l; i++ ) {
                for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
                    // Always skip document fragments
                    if ( cur.nodeType < 11 && (pos ?
                        pos.index(cur) > -1 :

                        // Don't pass non-elements to Sizzle
                        cur.nodeType === 1 &&
                        jQuery.find.matchesSelector(cur, selectors)) ) {

                        matched.push( cur );
                        break;
                    }
                }
            }

            return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
        },

        // Determine the position of an element within
        // the matched set of elements
        index: function( elem ) {

            // No argument, return index in parent
            if ( !elem ) {
                return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
            }

            // index in selector
            if ( typeof elem === "string" ) {
                return jQuery.inArray( this[0], jQuery( elem ) );
            }

            // Locate the position of the desired element
            return jQuery.inArray(
                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem, this );
        },

        add: function( selector, context ) {
            return this.pushStack(
                jQuery.unique(
                    jQuery.merge( this.get(), jQuery( selector, context ) )
                )
            );
        },

        addBack: function( selector ) {
            return this.add( selector == null ?
                this.prevObject : this.prevObject.filter(selector)
            );
        }
    });

    function sibling( cur, dir ) {
        do {
            cur = cur[ dir ];
        } while ( cur && cur.nodeType !== 1 );

        return cur;
    }

    jQuery.each({
        parent: function( elem ) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function( elem ) {
            return jQuery.dir( elem, "parentNode" );
        },
        parentsUntil: function( elem, i, until ) {
            return jQuery.dir( elem, "parentNode", until );
        },
        next: function( elem ) {
            return sibling( elem, "nextSibling" );
        },
        prev: function( elem ) {
            return sibling( elem, "previousSibling" );
        },
        nextAll: function( elem ) {
            return jQuery.dir( elem, "nextSibling" );
        },
        prevAll: function( elem ) {
            return jQuery.dir( elem, "previousSibling" );
        },
        nextUntil: function( elem, i, until ) {
            return jQuery.dir( elem, "nextSibling", until );
        },
        prevUntil: function( elem, i, until ) {
            return jQuery.dir( elem, "previousSibling", until );
        },
        siblings: function( elem ) {
            return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
        },
        children: function( elem ) {
            return jQuery.sibling( elem.firstChild );
        },
        contents: function( elem ) {
            return jQuery.nodeName( elem, "iframe" ) ?
                elem.contentDocument || elem.contentWindow.document :
                jQuery.merge( [], elem.childNodes );
        }
    }, function( name, fn ) {
        jQuery.fn[ name ] = function( until, selector ) {
            var ret = jQuery.map( this, fn, until );

            if ( name.slice( -5 ) !== "Until" ) {
                selector = until;
            }

            if ( selector && typeof selector === "string" ) {
                ret = jQuery.filter( selector, ret );
            }

            if ( this.length > 1 ) {
                // Remove duplicates
                if ( !guaranteedUnique[ name ] ) {
                    ret = jQuery.unique( ret );
                }

                // Reverse order for parents* and prev-derivatives
                if ( rparentsprev.test( name ) ) {
                    ret = ret.reverse();
                }
            }

            return this.pushStack( ret );
        };
    });
    var rnotwhite = (/\S+/g);



// String to Object options format cache
    var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
    function createOptions( options ) {
        var object = optionsCache[ options ] = {};
        jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
            object[ flag ] = true;
        });
        return object;
    }

    /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
    jQuery.Callbacks = function( options ) {

        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ?
            ( optionsCache[ options ] || createOptions( options ) ) :
            jQuery.extend( {}, options );

        var // Flag to know if list is currently firing
            firing,
            // Last fire value (for non-forgettable lists)
            memory,
            // Flag to know if list was already fired
            fired,
            // End of the loop when firing
            firingLength,
            // Index of currently firing callback (modified by remove if needed)
            firingIndex,
            // First callback to fire (used internally by add and fireWith)
            firingStart,
            // Actual callback list
            list = [],
            // Stack of fire calls for repeatable lists
            stack = !options.once && [],
            // Fire callbacks
            fire = function( data ) {
                memory = options.memory && data;
                fired = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                firing = true;
                for ( ; list && firingIndex < firingLength; firingIndex++ ) {
                    if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
                        memory = false; // To prevent further calls using add
                        break;
                    }
                }
                firing = false;
                if ( list ) {
                    if ( stack ) {
                        if ( stack.length ) {
                            fire( stack.shift() );
                        }
                    } else if ( memory ) {
                        list = [];
                    } else {
                        self.disable();
                    }
                }
            },
            // Actual Callbacks object
            self = {
                // Add a callback or a collection of callbacks to the list
                add: function() {
                    if ( list ) {
                        // First, we save the current length
                        var start = list.length;
                        (function add( args ) {
                            jQuery.each( args, function( _, arg ) {
                                var type = jQuery.type( arg );
                                if ( type === "function" ) {
                                    if ( !options.unique || !self.has( arg ) ) {
                                        list.push( arg );
                                    }
                                } else if ( arg && arg.length && type !== "string" ) {
                                    // Inspect recursively
                                    add( arg );
                                }
                            });
                        })( arguments );
                        // Do we need to add the callbacks to the
                        // current firing batch?
                        if ( firing ) {
                            firingLength = list.length;
                            // With memory, if we're not firing then
                            // we should call right away
                        } else if ( memory ) {
                            firingStart = start;
                            fire( memory );
                        }
                    }
                    return this;
                },
                // Remove a callback from the list
                remove: function() {
                    if ( list ) {
                        jQuery.each( arguments, function( _, arg ) {
                            var index;
                            while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
                                list.splice( index, 1 );
                                // Handle firing indexes
                                if ( firing ) {
                                    if ( index <= firingLength ) {
                                        firingLength--;
                                    }
                                    if ( index <= firingIndex ) {
                                        firingIndex--;
                                    }
                                }
                            }
                        });
                    }
                    return this;
                },
                // Check if a given callback is in the list.
                // If no argument is given, return whether or not list has callbacks attached.
                has: function( fn ) {
                    return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
                },
                // Remove all callbacks from the list
                empty: function() {
                    list = [];
                    firingLength = 0;
                    return this;
                },
                // Have the list do nothing anymore
                disable: function() {
                    list = stack = memory = undefined;
                    return this;
                },
                // Is it disabled?
                disabled: function() {
                    return !list;
                },
                // Lock the list in its current state
                lock: function() {
                    stack = undefined;
                    if ( !memory ) {
                        self.disable();
                    }
                    return this;
                },
                // Is it locked?
                locked: function() {
                    return !stack;
                },
                // Call all callbacks with the given context and arguments
                fireWith: function( context, args ) {
                    if ( list && ( !fired || stack ) ) {
                        args = args || [];
                        args = [ context, args.slice ? args.slice() : args ];
                        if ( firing ) {
                            stack.push( args );
                        } else {
                            fire( args );
                        }
                    }
                    return this;
                },
                // Call all the callbacks with the given arguments
                fire: function() {
                    self.fireWith( this, arguments );
                    return this;
                },
                // To know if the callbacks have already been called at least once
                fired: function() {
                    return !!fired;
                }
            };

        return self;
    };


    jQuery.extend({

        Deferred: function( func ) {
            var tuples = [
                    // action, add listener, listener list, final state
                    [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
                    [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
                    [ "notify", "progress", jQuery.Callbacks("memory") ]
                ],
                state = "pending",
                promise = {
                    state: function() {
                        return state;
                    },
                    always: function() {
                        deferred.done( arguments ).fail( arguments );
                        return this;
                    },
                    then: function( /* fnDone, fnFail, fnProgress */ ) {
                        var fns = arguments;
                        return jQuery.Deferred(function( newDefer ) {
                            jQuery.each( tuples, function( i, tuple ) {
                                var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
                                // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                deferred[ tuple[1] ](function() {
                                    var returned = fn && fn.apply( this, arguments );
                                    if ( returned && jQuery.isFunction( returned.promise ) ) {
                                        returned.promise()
                                            .done( newDefer.resolve )
                                            .fail( newDefer.reject )
                                            .progress( newDefer.notify );
                                    } else {
                                        newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    // Get a promise for this deferred
                    // If obj is provided, the promise aspect is added to the object
                    promise: function( obj ) {
                        return obj != null ? jQuery.extend( obj, promise ) : promise;
                    }
                },
                deferred = {};

            // Keep pipe for back-compat
            promise.pipe = promise.then;

            // Add list-specific methods
            jQuery.each( tuples, function( i, tuple ) {
                var list = tuple[ 2 ],
                    stateString = tuple[ 3 ];

                // promise[ done | fail | progress ] = list.add
                promise[ tuple[1] ] = list.add;

                // Handle state
                if ( stateString ) {
                    list.add(function() {
                        // state = [ resolved | rejected ]
                        state = stateString;

                        // [ reject_list | resolve_list ].disable; progress_list.lock
                    }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
                }

                // deferred[ resolve | reject | notify ]
                deferred[ tuple[0] ] = function() {
                    deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
                    return this;
                };
                deferred[ tuple[0] + "With" ] = list.fireWith;
            });

            // Make the deferred a promise
            promise.promise( deferred );

            // Call given func if any
            if ( func ) {
                func.call( deferred, deferred );
            }

            // All done!
            return deferred;
        },

        // Deferred helper
        when: function( subordinate /* , ..., subordinateN */ ) {
            var i = 0,
                resolveValues = slice.call( arguments ),
                length = resolveValues.length,

                // the count of uncompleted subordinates
                remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

                // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
                deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

                // Update function for both resolve and progress values
                updateFunc = function( i, contexts, values ) {
                    return function( value ) {
                        contexts[ i ] = this;
                        values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                        if ( values === progressValues ) {
                            deferred.notifyWith( contexts, values );

                        } else if ( !(--remaining) ) {
                            deferred.resolveWith( contexts, values );
                        }
                    };
                },

                progressValues, progressContexts, resolveContexts;

            // add listeners to Deferred subordinates; treat others as resolved
            if ( length > 1 ) {
                progressValues = new Array( length );
                progressContexts = new Array( length );
                resolveContexts = new Array( length );
                for ( ; i < length; i++ ) {
                    if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                        resolveValues[ i ].promise()
                            .done( updateFunc( i, resolveContexts, resolveValues ) )
                            .fail( deferred.reject )
                            .progress( updateFunc( i, progressContexts, progressValues ) );
                    } else {
                        --remaining;
                    }
                }
            }

            // if we're not waiting on anything, resolve the master
            if ( !remaining ) {
                deferred.resolveWith( resolveContexts, resolveValues );
            }

            return deferred.promise();
        }
    });


// The deferred used on DOM ready
    var readyList;

    jQuery.fn.ready = function( fn ) {
        // Add the callback
        jQuery.ready.promise().done( fn );

        return this;
    };

    jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,

        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,

        // Hold (or release) the ready event
        holdReady: function( hold ) {
            if ( hold ) {
                jQuery.readyWait++;
            } else {
                jQuery.ready( true );
            }
        },

        // Handle when the DOM is ready
        ready: function( wait ) {

            // Abort if there are pending holds or we're already ready
            if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
                return;
            }

            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
            if ( !document.body ) {
                return setTimeout( jQuery.ready );
            }

            // Remember that the DOM is ready
            jQuery.isReady = true;

            // If a normal DOM Ready event fired, decrement, and wait if need be
            if ( wait !== true && --jQuery.readyWait > 0 ) {
                return;
            }

            // If there are functions bound, to execute
            readyList.resolveWith( document, [ jQuery ] );

            // Trigger any bound ready events
            if ( jQuery.fn.triggerHandler ) {
                jQuery( document ).triggerHandler( "ready" );
                jQuery( document ).off( "ready" );
            }
        }
    });

    /**
     * Clean-up method for dom ready events
     */
    function detach() {
        if ( document.addEventListener ) {
            document.removeEventListener( "DOMContentLoaded", completed, false );
            window.removeEventListener( "load", completed, false );

        } else {
            document.detachEvent( "onreadystatechange", completed );
            window.detachEvent( "onload", completed );
        }
    }

    /**
     * The ready event handler and self cleanup method
     */
    function completed() {
        // readyState === "complete" is good enough for us to call the dom ready in oldIE
        if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
            detach();
            jQuery.ready();
        }
    }

    jQuery.ready.promise = function( obj ) {
        if ( !readyList ) {

            readyList = jQuery.Deferred();

            // Catch cases where $(document).ready() is called after the browser event has already occurred.
            // we once tried to use readyState "interactive" here, but it caused issues like the one
            // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
            if ( document.readyState === "complete" ) {
                // Handle it asynchronously to allow scripts the opportunity to delay ready
                setTimeout( jQuery.ready );

                // Standards-based browsers support DOMContentLoaded
            } else if ( document.addEventListener ) {
                // Use the handy event callback
                document.addEventListener( "DOMContentLoaded", completed, false );

                // A fallback to window.onload, that will always work
                window.addEventListener( "load", completed, false );

                // If IE event model is used
            } else {
                // Ensure firing before onload, maybe late but safe also for iframes
                document.attachEvent( "onreadystatechange", completed );

                // A fallback to window.onload, that will always work
                window.attachEvent( "onload", completed );

                // If IE and not a frame
                // continually check to see if the document is ready
                var top = false;

                try {
                    top = window.frameElement == null && document.documentElement;
                } catch(e) {}

                if ( top && top.doScroll ) {
                    (function doScrollCheck() {
                        if ( !jQuery.isReady ) {

                            try {
                                // Use the trick by Diego Perini
                                // http://javascript.nwbox.com/IEContentLoaded/
                                top.doScroll("left");
                            } catch(e) {
                                return setTimeout( doScrollCheck, 50 );
                            }

                            // detach all dom ready events
                            detach();

                            // and execute any waiting functions
                            jQuery.ready();
                        }
                    })();
                }
            }
        }
        return readyList.promise( obj );
    };


    var strundefined = typeof undefined;



// Support: IE<9
// Iteration over object's inherited properties before its own
    var i;
    for ( i in jQuery( support ) ) {
        break;
    }
    support.ownLast = i !== "0";

// Note: most support tests are defined in their respective modules.
// false until the test is run
    support.inlineBlockNeedsLayout = false;

// Execute ASAP in case we need to set body.style.zoom
    jQuery(function() {
        // Minified: var a,b,c,d
        var val, div, body, container;

        body = document.getElementsByTagName( "body" )[ 0 ];
        if ( !body || !body.style ) {
            // Return for frameset docs that don't have a body
            return;
        }

        // Setup
        div = document.createElement( "div" );
        container = document.createElement( "div" );
        container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
        body.appendChild( container ).appendChild( div );

        if ( typeof div.style.zoom !== strundefined ) {
            // Support: IE<8
            // Check if natively block-level elements act like inline-block
            // elements when setting their display to 'inline' and giving
            // them layout
            div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";

            support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
            if ( val ) {
                // Prevent IE 6 from affecting layout for positioned elements #11048
                // Prevent IE from shrinking the body in IE 7 mode #12869
                // Support: IE<8
                body.style.zoom = 1;
            }
        }

        body.removeChild( container );
    });




    (function() {
        var div = document.createElement( "div" );

        // Execute the test only if not already executed in another module.
        if (support.deleteExpando == null) {
            // Support: IE<9
            support.deleteExpando = true;
            try {
                delete div.test;
            } catch( e ) {
                support.deleteExpando = false;
            }
        }

        // Null elements to avoid leaks in IE.
        div = null;
    })();


    /**
     * Determines whether an object can have data
     */
    jQuery.acceptData = function( elem ) {
        var noData = jQuery.noData[ (elem.nodeName + " ").toLowerCase() ],
            nodeType = +elem.nodeType || 1;

        // Do not set data on non-element DOM nodes because it will not be cleared (#8335).
        return nodeType !== 1 && nodeType !== 9 ?
            false :

            // Nodes accept data unless otherwise specified; rejection can be conditional
            !noData || noData !== true && elem.getAttribute("classid") === noData;
    };


    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /([A-Z])/g;

    function dataAttr( elem, key, data ) {
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if ( data === undefined && elem.nodeType === 1 ) {

            var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

            data = elem.getAttribute( name );

            if ( typeof data === "string" ) {
                try {
                    data = data === "true" ? true :
                        data === "false" ? false :
                            data === "null" ? null :
                                // Only convert to a number if it doesn't change the string
                                +data + "" === data ? +data :
                                    rbrace.test( data ) ? jQuery.parseJSON( data ) :
                                        data;
                } catch( e ) {}

                // Make sure we set the data so it isn't changed later
                jQuery.data( elem, key, data );

            } else {
                data = undefined;
            }
        }

        return data;
    }

// checks a cache object for emptiness
    function isEmptyDataObject( obj ) {
        var name;
        for ( name in obj ) {

            // if the public data object is empty, the private is still empty
            if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
                continue;
            }
            if ( name !== "toJSON" ) {
                return false;
            }
        }

        return true;
    }

    function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
        if ( !jQuery.acceptData( elem ) ) {
            return;
        }

        var ret, thisCache,
            internalKey = jQuery.expando,

            // We have to handle DOM nodes and JS objects differently because IE6-7
            // can't GC object references properly across the DOM-JS boundary
            isNode = elem.nodeType,

            // Only DOM nodes need the global jQuery cache; JS object data is
            // attached directly to the object so GC can occur automatically
            cache = isNode ? jQuery.cache : elem,

            // Only defining an ID for JS objects if its cache already exists allows
            // the code to shortcut on the same path as a DOM node with no cache
            id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

        // Avoid doing any more work than we need to when trying to get data on an
        // object that has no data at all
        if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
            return;
        }

        if ( !id ) {
            // Only DOM nodes need a new unique ID for each element since their data
            // ends up in the global cache
            if ( isNode ) {
                id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
            } else {
                id = internalKey;
            }
        }

        if ( !cache[ id ] ) {
            // Avoid exposing jQuery metadata on plain JS objects when the object
            // is serialized using JSON.stringify
            cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
        }

        // An object can be passed to jQuery.data instead of a key/value pair; this gets
        // shallow copied over onto the existing cache
        if ( typeof name === "object" || typeof name === "function" ) {
            if ( pvt ) {
                cache[ id ] = jQuery.extend( cache[ id ], name );
            } else {
                cache[ id ].data = jQuery.extend( cache[ id ].data, name );
            }
        }

        thisCache = cache[ id ];

        // jQuery data() is stored in a separate object inside the object's internal data
        // cache in order to avoid key collisions between internal data and user-defined
        // data.
        if ( !pvt ) {
            if ( !thisCache.data ) {
                thisCache.data = {};
            }

            thisCache = thisCache.data;
        }

        if ( data !== undefined ) {
            thisCache[ jQuery.camelCase( name ) ] = data;
        }

        // Check for both converted-to-camel and non-converted data property names
        // If a data property was specified
        if ( typeof name === "string" ) {

            // First Try to find as-is property data
            ret = thisCache[ name ];

            // Test for null|undefined property data
            if ( ret == null ) {

                // Try to find the camelCased property
                ret = thisCache[ jQuery.camelCase( name ) ];
            }
        } else {
            ret = thisCache;
        }

        return ret;
    }

    function internalRemoveData( elem, name, pvt ) {
        if ( !jQuery.acceptData( elem ) ) {
            return;
        }

        var thisCache, i,
            isNode = elem.nodeType,

            // See jQuery.data for more information
            cache = isNode ? jQuery.cache : elem,
            id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

        // If there is already no cache entry for this object, there is no
        // purpose in continuing
        if ( !cache[ id ] ) {
            return;
        }

        if ( name ) {

            thisCache = pvt ? cache[ id ] : cache[ id ].data;

            if ( thisCache ) {

                // Support array or space separated string names for data keys
                if ( !jQuery.isArray( name ) ) {

                    // try the string as a key before any manipulation
                    if ( name in thisCache ) {
                        name = [ name ];
                    } else {

                        // split the camel cased version by spaces unless a key with the spaces exists
                        name = jQuery.camelCase( name );
                        if ( name in thisCache ) {
                            name = [ name ];
                        } else {
                            name = name.split(" ");
                        }
                    }
                } else {
                    // If "name" is an array of keys...
                    // When data is initially created, via ("key", "val") signature,
                    // keys will be converted to camelCase.
                    // Since there is no way to tell _how_ a key was added, remove
                    // both plain key and camelCase key. #12786
                    // This will only penalize the array argument path.
                    name = name.concat( jQuery.map( name, jQuery.camelCase ) );
                }

                i = name.length;
                while ( i-- ) {
                    delete thisCache[ name[i] ];
                }

                // If there is no data left in the cache, we want to continue
                // and let the cache object itself get destroyed
                if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
                    return;
                }
            }
        }

        // See jQuery.data for more information
        if ( !pvt ) {
            delete cache[ id ].data;

            // Don't destroy the parent cache unless the internal data object
            // had been the only thing left in it
            if ( !isEmptyDataObject( cache[ id ] ) ) {
                return;
            }
        }

        // Destroy the cache
        if ( isNode ) {
            jQuery.cleanData( [ elem ], true );

            // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
            /* jshint eqeqeq: false */
        } else if ( support.deleteExpando || cache != cache.window ) {
            /* jshint eqeqeq: true */
            delete cache[ id ];

            // When all else fails, null
        } else {
            cache[ id ] = null;
        }
    }

    jQuery.extend({
        cache: {},

        // The following elements (space-suffixed to avoid Object.prototype collisions)
        // throw uncatchable exceptions if you attempt to set expando properties
        noData: {
            "applet ": true,
            "embed ": true,
            // ...but Flash objects (which have this classid) *can* handle expandos
            "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
        },

        hasData: function( elem ) {
            elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
            return !!elem && !isEmptyDataObject( elem );
        },

        data: function( elem, name, data ) {
            return internalData( elem, name, data );
        },

        removeData: function( elem, name ) {
            return internalRemoveData( elem, name );
        },

        // For internal use only.
        _data: function( elem, name, data ) {
            return internalData( elem, name, data, true );
        },

        _removeData: function( elem, name ) {
            return internalRemoveData( elem, name, true );
        }
    });

    jQuery.fn.extend({
        data: function( key, value ) {
            var i, name, data,
                elem = this[0],
                attrs = elem && elem.attributes;

            // Special expections of .data basically thwart jQuery.access,
            // so implement the relevant behavior ourselves

            // Gets all values
            if ( key === undefined ) {
                if ( this.length ) {
                    data = jQuery.data( elem );

                    if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
                        i = attrs.length;
                        while ( i-- ) {

                            // Support: IE11+
                            // The attrs elements can be null (#14894)
                            if ( attrs[ i ] ) {
                                name = attrs[ i ].name;
                                if ( name.indexOf( "data-" ) === 0 ) {
                                    name = jQuery.camelCase( name.slice(5) );
                                    dataAttr( elem, name, data[ name ] );
                                }
                            }
                        }
                        jQuery._data( elem, "parsedAttrs", true );
                    }
                }

                return data;
            }

            // Sets multiple values
            if ( typeof key === "object" ) {
                return this.each(function() {
                    jQuery.data( this, key );
                });
            }

            return arguments.length > 1 ?

                // Sets one value
                this.each(function() {
                    jQuery.data( this, key, value );
                }) :

                // Gets one value
                // Try to fetch any internally stored data first
                elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
        },

        removeData: function( key ) {
            return this.each(function() {
                jQuery.removeData( this, key );
            });
        }
    });


    jQuery.extend({
        queue: function( elem, type, data ) {
            var queue;

            if ( elem ) {
                type = ( type || "fx" ) + "queue";
                queue = jQuery._data( elem, type );

                // Speed up dequeue by getting out quickly if this is just a lookup
                if ( data ) {
                    if ( !queue || jQuery.isArray(data) ) {
                        queue = jQuery._data( elem, type, jQuery.makeArray(data) );
                    } else {
                        queue.push( data );
                    }
                }
                return queue || [];
            }
        },

        dequeue: function( elem, type ) {
            type = type || "fx";

            var queue = jQuery.queue( elem, type ),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks( elem, type ),
                next = function() {
                    jQuery.dequeue( elem, type );
                };

            // If the fx queue is dequeued, always remove the progress sentinel
            if ( fn === "inprogress" ) {
                fn = queue.shift();
                startLength--;
            }

            if ( fn ) {

                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if ( type === "fx" ) {
                    queue.unshift( "inprogress" );
                }

                // clear up the last queue stop function
                delete hooks.stop;
                fn.call( elem, next, hooks );
            }

            if ( !startLength && hooks ) {
                hooks.empty.fire();
            }
        },

        // not intended for public consumption - generates a queueHooks object, or returns the current one
        _queueHooks: function( elem, type ) {
            var key = type + "queueHooks";
            return jQuery._data( elem, key ) || jQuery._data( elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    jQuery._removeData( elem, type + "queue" );
                    jQuery._removeData( elem, key );
                })
            });
        }
    });

    jQuery.fn.extend({
        queue: function( type, data ) {
            var setter = 2;

            if ( typeof type !== "string" ) {
                data = type;
                type = "fx";
                setter--;
            }

            if ( arguments.length < setter ) {
                return jQuery.queue( this[0], type );
            }

            return data === undefined ?
                this :
                this.each(function() {
                    var queue = jQuery.queue( this, type, data );

                    // ensure a hooks for this queue
                    jQuery._queueHooks( this, type );

                    if ( type === "fx" && queue[0] !== "inprogress" ) {
                        jQuery.dequeue( this, type );
                    }
                });
        },
        dequeue: function( type ) {
            return this.each(function() {
                jQuery.dequeue( this, type );
            });
        },
        clearQueue: function( type ) {
            return this.queue( type || "fx", [] );
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function( type, obj ) {
            var tmp,
                count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function() {
                    if ( !( --count ) ) {
                        defer.resolveWith( elements, [ elements ] );
                    }
                };

            if ( typeof type !== "string" ) {
                obj = type;
                type = undefined;
            }
            type = type || "fx";

            while ( i-- ) {
                tmp = jQuery._data( elements[ i ], type + "queueHooks" );
                if ( tmp && tmp.empty ) {
                    count++;
                    tmp.empty.add( resolve );
                }
            }
            resolve();
            return defer.promise( obj );
        }
    });
    var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

    var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

    var isHidden = function( elem, el ) {
        // isHidden might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;
        return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
    };



// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
    var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
        var i = 0,
            length = elems.length,
            bulk = key == null;

        // Sets many values
        if ( jQuery.type( key ) === "object" ) {
            chainable = true;
            for ( i in key ) {
                jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
            }

            // Sets one value
        } else if ( value !== undefined ) {
            chainable = true;

            if ( !jQuery.isFunction( value ) ) {
                raw = true;
            }

            if ( bulk ) {
                // Bulk operations run against the entire set
                if ( raw ) {
                    fn.call( elems, value );
                    fn = null;

                    // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function( elem, key, value ) {
                        return bulk.call( jQuery( elem ), value );
                    };
                }
            }

            if ( fn ) {
                for ( ; i < length; i++ ) {
                    fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
                }
            }
        }

        return chainable ?
            elems :

            // Gets
            bulk ?
                fn.call( elems ) :
                length ? fn( elems[0], key ) : emptyGet;
    };
    var rcheckableType = (/^(?:checkbox|radio)$/i);



    (function() {
        // Minified: var a,b,c
        var input = document.createElement( "input" ),
            div = document.createElement( "div" ),
            fragment = document.createDocumentFragment();

        // Setup
        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

        // IE strips leading whitespace when .innerHTML is used
        support.leadingWhitespace = div.firstChild.nodeType === 3;

        // Make sure that tbody elements aren't automatically inserted
        // IE will insert them into empty tables
        support.tbody = !div.getElementsByTagName( "tbody" ).length;

        // Make sure that link elements get serialized correctly by innerHTML
        // This requires a wrapper element in IE
        support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;

        // Makes sure cloning an html5 element does not cause problems
        // Where outerHTML is undefined, this still works
        support.html5Clone =
            document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";

        // Check if a disconnected checkbox will retain its checked
        // value of true after appended to the DOM (IE6/7)
        input.type = "checkbox";
        input.checked = true;
        fragment.appendChild( input );
        support.appendChecked = input.checked;

        // Make sure textarea (and checkbox) defaultValue is properly cloned
        // Support: IE6-IE11+
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

        // #11217 - WebKit loses check when the name is after the checked attribute
        fragment.appendChild( div );
        div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

        // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
        // old WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

        // Support: IE<9
        // Opera does not clone events (and typeof div.attachEvent === undefined).
        // IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
        support.noCloneEvent = true;
        if ( div.attachEvent ) {
            div.attachEvent( "onclick", function() {
                support.noCloneEvent = false;
            });

            div.cloneNode( true ).click();
        }

        // Execute the test only if not already executed in another module.
        if (support.deleteExpando == null) {
            // Support: IE<9
            support.deleteExpando = true;
            try {
                delete div.test;
            } catch( e ) {
                support.deleteExpando = false;
            }
        }
    })();


    (function() {
        var i, eventName,
            div = document.createElement( "div" );

        // Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
        for ( i in { submit: true, change: true, focusin: true }) {
            eventName = "on" + i;

            if ( !(support[ i + "Bubbles" ] = eventName in window) ) {
                // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
                div.setAttribute( eventName, "t" );
                support[ i + "Bubbles" ] = div.attributes[ eventName ].expando === false;
            }
        }

        // Null elements to avoid leaks in IE.
        div = null;
    })();


    var rformElems = /^(?:input|select|textarea)$/i,
        rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

    function returnTrue() {
        return true;
    }

    function returnFalse() {
        return false;
    }

    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch ( err ) { }
    }

    /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
    jQuery.event = {

        global: {},

        add: function( elem, types, handler, data, selector ) {
            var tmp, events, t, handleObjIn,
                special, eventHandle, handleObj,
                handlers, type, namespaces, origType,
                elemData = jQuery._data( elem );

            // Don't attach events to noData or text/comment nodes (but allow plain objects)
            if ( !elemData ) {
                return;
            }

            // Caller can pass in an object of custom data in lieu of the handler
            if ( handler.handler ) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }

            // Make sure that the handler has a unique ID, used to find/remove it later
            if ( !handler.guid ) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure and main handler, if this is the first
            if ( !(events = elemData.events) ) {
                events = elemData.events = {};
            }
            if ( !(eventHandle = elemData.handle) ) {
                eventHandle = elemData.handle = function( e ) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?
                        jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
                        undefined;
                };
                // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
                eventHandle.elem = elem;
            }

            // Handle multiple events separated by a space
            types = ( types || "" ).match( rnotwhite ) || [ "" ];
            t = types.length;
            while ( t-- ) {
                tmp = rtypenamespace.exec( types[t] ) || [];
                type = origType = tmp[1];
                namespaces = ( tmp[2] || "" ).split( "." ).sort();

                // There *must* be a type, no attaching namespace-only handlers
                if ( !type ) {
                    continue;
                }

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[ type ] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = ( selector ? special.delegateType : special.bindType ) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[ type ] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
                    namespace: namespaces.join(".")
                }, handleObjIn );

                // Init the event handler queue if we're the first
                if ( !(handlers = events[ type ]) ) {
                    handlers = events[ type ] = [];
                    handlers.delegateCount = 0;

                    // Only use addEventListener/attachEvent if the special events handler returns false
                    if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
                        // Bind the global event handler to the element
                        if ( elem.addEventListener ) {
                            elem.addEventListener( type, eventHandle, false );

                        } else if ( elem.attachEvent ) {
                            elem.attachEvent( "on" + type, eventHandle );
                        }
                    }
                }

                if ( special.add ) {
                    special.add.call( elem, handleObj );

                    if ( !handleObj.handler.guid ) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add to the element's handler list, delegates in front
                if ( selector ) {
                    handlers.splice( handlers.delegateCount++, 0, handleObj );
                } else {
                    handlers.push( handleObj );
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[ type ] = true;
            }

            // Nullify elem to prevent memory leaks in IE
            elem = null;
        },

        // Detach an event or set of events from an element
        remove: function( elem, types, handler, selector, mappedTypes ) {
            var j, handleObj, tmp,
                origCount, t, events,
                special, handlers, type,
                namespaces, origType,
                elemData = jQuery.hasData( elem ) && jQuery._data( elem );

            if ( !elemData || !(events = elemData.events) ) {
                return;
            }

            // Once for each type.namespace in types; type may be omitted
            types = ( types || "" ).match( rnotwhite ) || [ "" ];
            t = types.length;
            while ( t-- ) {
                tmp = rtypenamespace.exec( types[t] ) || [];
                type = origType = tmp[1];
                namespaces = ( tmp[2] || "" ).split( "." ).sort();

                // Unbind all events (on this namespace, if provided) for the element
                if ( !type ) {
                    for ( type in events ) {
                        jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                    }
                    continue;
                }

                special = jQuery.event.special[ type ] || {};
                type = ( selector ? special.delegateType : special.bindType ) || type;
                handlers = events[ type ] || [];
                tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

                // Remove matching events
                origCount = j = handlers.length;
                while ( j-- ) {
                    handleObj = handlers[ j ];

                    if ( ( mappedTypes || origType === handleObj.origType ) &&
                        ( !handler || handler.guid === handleObj.guid ) &&
                        ( !tmp || tmp.test( handleObj.namespace ) ) &&
                        ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
                        handlers.splice( j, 1 );

                        if ( handleObj.selector ) {
                            handlers.delegateCount--;
                        }
                        if ( special.remove ) {
                            special.remove.call( elem, handleObj );
                        }
                    }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if ( origCount && !handlers.length ) {
                    if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
                        jQuery.removeEvent( elem, type, elemData.handle );
                    }

                    delete events[ type ];
                }
            }

            // Remove the expando if it's no longer used
            if ( jQuery.isEmptyObject( events ) ) {
                delete elemData.handle;

                // removeData also checks for emptiness and clears the expando if empty
                // so use it instead of delete
                jQuery._removeData( elem, "events" );
            }
        },

        trigger: function( event, data, elem, onlyHandlers ) {
            var handle, ontype, cur,
                bubbleType, special, tmp, i,
                eventPath = [ elem || document ],
                type = hasOwn.call( event, "type" ) ? event.type : event,
                namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

            cur = tmp = elem = elem || document;

            // Don't do events on text and comment nodes
            if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                return;
            }

            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
                return;
            }

            if ( type.indexOf(".") >= 0 ) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;

            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[ jQuery.expando ] ?
                event :
                new jQuery.Event( type, typeof event === "object" && event );

            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.namespace_re = event.namespace ?
                new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
                null;

            // Clean up the event in case it is being reused
            event.result = undefined;
            if ( !event.target ) {
                event.target = elem;
            }

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ?
                [ event ] :
                jQuery.makeArray( data, [ event ] );

            // Allow special events to draw outside the lines
            special = jQuery.event.special[ type ] || {};
            if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
                return;
            }

            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

                bubbleType = special.delegateType || type;
                if ( !rfocusMorph.test( bubbleType + type ) ) {
                    cur = cur.parentNode;
                }
                for ( ; cur; cur = cur.parentNode ) {
                    eventPath.push( cur );
                    tmp = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if ( tmp === (elem.ownerDocument || document) ) {
                    eventPath.push( tmp.defaultView || tmp.parentWindow || window );
                }
            }

            // Fire handlers on the event path
            i = 0;
            while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

                event.type = i > 1 ?
                    bubbleType :
                    special.bindType || type;

                // jQuery handler
                handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
                if ( handle ) {
                    handle.apply( cur, data );
                }

                // Native handler
                handle = ontype && cur[ ontype ];
                if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
                    event.result = handle.apply( cur, data );
                    if ( event.result === false ) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;

            // If nobody prevented the default action, do it now
            if ( !onlyHandlers && !event.isDefaultPrevented() ) {

                if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
                    jQuery.acceptData( elem ) ) {

                    // Call a native DOM method on the target with the same name name as the event.
                    // Can't use an .isFunction() check here because IE6/7 fails that test.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ ontype ];

                        if ( tmp ) {
                            elem[ ontype ] = null;
                        }

                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        try {
                            elem[ type ]();
                        } catch ( e ) {
                            // IE<9 dies on focus/blur to hidden element (#1486,#12518)
                            // only reproducible on winXP IE8 native, not IE9 in IE8 mode
                        }
                        jQuery.event.triggered = undefined;

                        if ( tmp ) {
                            elem[ ontype ] = tmp;
                        }
                    }
                }
            }

            return event.result;
        },

        dispatch: function( event ) {

            // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix( event );

            var i, ret, handleObj, matched, j,
                handlerQueue = [],
                args = slice.call( arguments ),
                handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
                special = jQuery.event.special[ event.type ] || {};

            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;
            event.delegateTarget = this;

            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
                return;
            }

            // Determine handlers
            handlerQueue = jQuery.event.handlers.call( this, event, handlers );

            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
                event.currentTarget = matched.elem;

                j = 0;
                while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

                    // Triggered event must either 1) have no namespace, or
                    // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                    if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

                        event.handleObj = handleObj;
                        event.data = handleObj.data;

                        ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                            .apply( matched.elem, args );

                        if ( ret !== undefined ) {
                            if ( (event.result = ret) === false ) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }

            // Call the postDispatch hook for the mapped type
            if ( special.postDispatch ) {
                special.postDispatch.call( this, event );
            }

            return event.result;
        },

        handlers: function( event, handlers ) {
            var sel, handleObj, matches, i,
                handlerQueue = [],
                delegateCount = handlers.delegateCount,
                cur = event.target;

            // Find delegate handlers
            // Black-hole SVG <use> instance trees (#13180)
            // Avoid non-left-click bubbling in Firefox (#3861)
            if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

                /* jshint eqeqeq: false */
                for ( ; cur != this; cur = cur.parentNode || this ) {
                    /* jshint eqeqeq: true */

                    // Don't check non-elements (#13208)
                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
                        matches = [];
                        for ( i = 0; i < delegateCount; i++ ) {
                            handleObj = handlers[ i ];

                            // Don't conflict with Object.prototype properties (#13203)
                            sel = handleObj.selector + " ";

                            if ( matches[ sel ] === undefined ) {
                                matches[ sel ] = handleObj.needsContext ?
                                    jQuery( sel, this ).index( cur ) >= 0 :
                                    jQuery.find( sel, this, null, [ cur ] ).length;
                            }
                            if ( matches[ sel ] ) {
                                matches.push( handleObj );
                            }
                        }
                        if ( matches.length ) {
                            handlerQueue.push({ elem: cur, handlers: matches });
                        }
                    }
                }
            }

            // Add the remaining (directly-bound) handlers
            if ( delegateCount < handlers.length ) {
                handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
            }

            return handlerQueue;
        },

        fix: function( event ) {
            if ( event[ jQuery.expando ] ) {
                return event;
            }

            // Create a writable copy of the event object and normalize some properties
            var i, prop, copy,
                type = event.type,
                originalEvent = event,
                fixHook = this.fixHooks[ type ];

            if ( !fixHook ) {
                this.fixHooks[ type ] = fixHook =
                    rmouseEvent.test( type ) ? this.mouseHooks :
                        rkeyEvent.test( type ) ? this.keyHooks :
                            {};
            }
            copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

            event = new jQuery.Event( originalEvent );

            i = copy.length;
            while ( i-- ) {
                prop = copy[ i ];
                event[ prop ] = originalEvent[ prop ];
            }

            // Support: IE<9
            // Fix target property (#1925)
            if ( !event.target ) {
                event.target = originalEvent.srcElement || document;
            }

            // Support: Chrome 23+, Safari?
            // Target should not be a text node (#504, #13143)
            if ( event.target.nodeType === 3 ) {
                event.target = event.target.parentNode;
            }

            // Support: IE<9
            // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
            event.metaKey = !!event.metaKey;

            return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
        },

        // Includes some event props shared by KeyEvent and MouseEvent
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

        fixHooks: {},

        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function( event, original ) {

                // Add which for key events
                if ( event.which == null ) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }

                return event;
            }
        },

        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function( event, original ) {
                var body, eventDoc, doc,
                    button = original.button,
                    fromElement = original.fromElement;

                // Calculate pageX/Y if missing and clientX/Y available
                if ( event.pageX == null && original.clientX != null ) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;

                    event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                    event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
                }

                // Add relatedTarget, if necessary
                if ( !event.relatedTarget && fromElement ) {
                    event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                }

                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don't use it
                if ( !event.which && button !== undefined ) {
                    event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
                }

                return event;
            }
        },

        special: {
            load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            focus: {
                // Fire native event if possible so blur/focus sequence is correct
                trigger: function() {
                    if ( this !== safeActiveElement() && this.focus ) {
                        try {
                            this.focus();
                            return false;
                        } catch ( e ) {
                            // Support: IE<9
                            // If we error on focus to hidden element (#1486, #12518),
                            // let .trigger() run the handlers
                        }
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if ( this === safeActiveElement() && this.blur ) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {
                // For checkbox, fire native event so checked state will be right
                trigger: function() {
                    if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
                        this.click();
                        return false;
                    }
                },

                // For cross-browser consistency, don't fire native .click() on links
                _default: function( event ) {
                    return jQuery.nodeName( event.target, "a" );
                }
            },

            beforeunload: {
                postDispatch: function( event ) {

                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if ( event.result !== undefined && event.originalEvent ) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        },

        simulate: function( type, elem, event, bubble ) {
            // Piggyback on a donor event to simulate a different one.
            // Fake originalEvent to avoid donor's stopPropagation, but if the
            // simulated event prevents default then we do the same on the donor.
            var e = jQuery.extend(
                new jQuery.Event(),
                event,
                {
                    type: type,
                    isSimulated: true,
                    originalEvent: {}
                }
            );
            if ( bubble ) {
                jQuery.event.trigger( e, null, elem );
            } else {
                jQuery.event.dispatch.call( elem, e );
            }
            if ( e.isDefaultPrevented() ) {
                event.preventDefault();
            }
        }
    };

    jQuery.removeEvent = document.removeEventListener ?
        function( elem, type, handle ) {
            if ( elem.removeEventListener ) {
                elem.removeEventListener( type, handle, false );
            }
        } :
        function( elem, type, handle ) {
            var name = "on" + type;

            if ( elem.detachEvent ) {

                // #8545, #7054, preventing memory leaks for custom events in IE6-8
                // detachEvent needed property on element, by name of that event, to properly expose it to GC
                if ( typeof elem[ name ] === strundefined ) {
                    elem[ name ] = null;
                }

                elem.detachEvent( name, handle );
            }
        };

    jQuery.Event = function( src, props ) {
        // Allow instantiation without the 'new' keyword
        if ( !(this instanceof jQuery.Event) ) {
            return new jQuery.Event( src, props );
        }

        // Event object
        if ( src && src.type ) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented ||
            src.defaultPrevented === undefined &&
            // Support: IE < 9, Android < 4.0
            src.returnValue === false ?
                returnTrue :
                returnFalse;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if ( props ) {
            jQuery.extend( this, props );
        }

        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || jQuery.now();

        // Mark it as fixed
        this[ jQuery.expando ] = true;
    };

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,

        preventDefault: function() {
            var e = this.originalEvent;

            this.isDefaultPrevented = returnTrue;
            if ( !e ) {
                return;
            }

            // If preventDefault exists, run it on the original event
            if ( e.preventDefault ) {
                e.preventDefault();

                // Support: IE
                // Otherwise set the returnValue property of the original event to false
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function() {
            var e = this.originalEvent;

            this.isPropagationStopped = returnTrue;
            if ( !e ) {
                return;
            }
            // If stopPropagation exists, run it on the original event
            if ( e.stopPropagation ) {
                e.stopPropagation();
            }

            // Support: IE
            // Set the cancelBubble property of the original event to true
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;

            this.isImmediatePropagationStopped = returnTrue;

            if ( e && e.stopImmediatePropagation ) {
                e.stopImmediatePropagation();
            }

            this.stopPropagation();
        }
    };

// Create mouseenter/leave events using mouseover/out and event-time checks
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function( orig, fix ) {
        jQuery.event.special[ orig ] = {
            delegateType: fix,
            bindType: fix,

            handle: function( event ) {
                var ret,
                    target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj;

                // For mousenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply( this, arguments );
                    event.type = fix;
                }
                return ret;
            }
        };
    });

// IE submit delegation
    if ( !support.submitBubbles ) {

        jQuery.event.special.submit = {
            setup: function() {
                // Only need this for delegated form submit events
                if ( jQuery.nodeName( this, "form" ) ) {
                    return false;
                }

                // Lazy-add a submit handler when a descendant form may potentially be submitted
                jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
                    // Node name check avoids a VML-related crash in IE (#9807)
                    var elem = e.target,
                        form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
                    if ( form && !jQuery._data( form, "submitBubbles" ) ) {
                        jQuery.event.add( form, "submit._submit", function( event ) {
                            event._submit_bubble = true;
                        });
                        jQuery._data( form, "submitBubbles", true );
                    }
                });
                // return undefined since we don't need an event listener
            },

            postDispatch: function( event ) {
                // If form was submitted by the user, bubble the event up the tree
                if ( event._submit_bubble ) {
                    delete event._submit_bubble;
                    if ( this.parentNode && !event.isTrigger ) {
                        jQuery.event.simulate( "submit", this.parentNode, event, true );
                    }
                }
            },

            teardown: function() {
                // Only need this for delegated form submit events
                if ( jQuery.nodeName( this, "form" ) ) {
                    return false;
                }

                // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
                jQuery.event.remove( this, "._submit" );
            }
        };
    }

// IE change delegation and checkbox/radio fix
    if ( !support.changeBubbles ) {

        jQuery.event.special.change = {

            setup: function() {

                if ( rformElems.test( this.nodeName ) ) {
                    // IE doesn't fire change on a check/radio until blur; trigger it on click
                    // after a propertychange. Eat the blur-change in special.change.handle.
                    // This still fires onchange a second time for check/radio after blur.
                    if ( this.type === "checkbox" || this.type === "radio" ) {
                        jQuery.event.add( this, "propertychange._change", function( event ) {
                            if ( event.originalEvent.propertyName === "checked" ) {
                                this._just_changed = true;
                            }
                        });
                        jQuery.event.add( this, "click._change", function( event ) {
                            if ( this._just_changed && !event.isTrigger ) {
                                this._just_changed = false;
                            }
                            // Allow triggered, simulated change events (#11500)
                            jQuery.event.simulate( "change", this, event, true );
                        });
                    }
                    return false;
                }
                // Delegated event; lazy-add a change handler on descendant inputs
                jQuery.event.add( this, "beforeactivate._change", function( e ) {
                    var elem = e.target;

                    if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
                        jQuery.event.add( elem, "change._change", function( event ) {
                            if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
                                jQuery.event.simulate( "change", this.parentNode, event, true );
                            }
                        });
                        jQuery._data( elem, "changeBubbles", true );
                    }
                });
            },

            handle: function( event ) {
                var elem = event.target;

                // Swallow native change events from checkbox/radio, we already triggered them above
                if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
                    return event.handleObj.handler.apply( this, arguments );
                }
            },

            teardown: function() {
                jQuery.event.remove( this, "._change" );

                return !rformElems.test( this.nodeName );
            }
        };
    }

// Create "bubbling" focus and blur events
    if ( !support.focusinBubbles ) {
        jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

            // Attach a single capturing handler on the document while someone wants focusin/focusout
            var handler = function( event ) {
                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
            };

            jQuery.event.special[ fix ] = {
                setup: function() {
                    var doc = this.ownerDocument || this,
                        attaches = jQuery._data( doc, fix );

                    if ( !attaches ) {
                        doc.addEventListener( orig, handler, true );
                    }
                    jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
                },
                teardown: function() {
                    var doc = this.ownerDocument || this,
                        attaches = jQuery._data( doc, fix ) - 1;

                    if ( !attaches ) {
                        doc.removeEventListener( orig, handler, true );
                        jQuery._removeData( doc, fix );
                    } else {
                        jQuery._data( doc, fix, attaches );
                    }
                }
            };
        });
    }

    jQuery.fn.extend({

        on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
            var type, origFn;

            // Types can be a map of types/handlers
            if ( typeof types === "object" ) {
                // ( types-Object, selector, data )
                if ( typeof selector !== "string" ) {
                    // ( types-Object, data )
                    data = data || selector;
                    selector = undefined;
                }
                for ( type in types ) {
                    this.on( type, selector, data, types[ type ], one );
                }
                return this;
            }

            if ( data == null && fn == null ) {
                // ( types, fn )
                fn = selector;
                data = selector = undefined;
            } else if ( fn == null ) {
                if ( typeof selector === "string" ) {
                    // ( types, selector, fn )
                    fn = data;
                    data = undefined;
                } else {
                    // ( types, data, fn )
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if ( fn === false ) {
                fn = returnFalse;
            } else if ( !fn ) {
                return this;
            }

            if ( one === 1 ) {
                origFn = fn;
                fn = function( event ) {
                    // Can use an empty set, since event contains the info
                    jQuery().off( event );
                    return origFn.apply( this, arguments );
                };
                // Use same guid so caller can remove using origFn
                fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
            }
            return this.each( function() {
                jQuery.event.add( this, types, fn, data, selector );
            });
        },
        one: function( types, selector, data, fn ) {
            return this.on( types, selector, data, fn, 1 );
        },
        off: function( types, selector, fn ) {
            var handleObj, type;
            if ( types && types.preventDefault && types.handleObj ) {
                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery( types.delegateTarget ).off(
                    handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                    handleObj.selector,
                    handleObj.handler
                );
                return this;
            }
            if ( typeof types === "object" ) {
                // ( types-object [, selector] )
                for ( type in types ) {
                    this.off( type, selector, types[ type ] );
                }
                return this;
            }
            if ( selector === false || typeof selector === "function" ) {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if ( fn === false ) {
                fn = returnFalse;
            }
            return this.each(function() {
                jQuery.event.remove( this, types, fn, selector );
            });
        },

        trigger: function( type, data ) {
            return this.each(function() {
                jQuery.event.trigger( type, data, this );
            });
        },
        triggerHandler: function( type, data ) {
            var elem = this[0];
            if ( elem ) {
                return jQuery.event.trigger( type, data, elem, true );
            }
        }
    });


    function createSafeFragment( document ) {
        var list = nodeNames.split( "|" ),
            safeFrag = document.createDocumentFragment();

        if ( safeFrag.createElement ) {
            while ( list.length ) {
                safeFrag.createElement(
                    list.pop()
                );
            }
        }
        return safeFrag;
    }

    var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
        "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
        rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
        rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
        rleadingWhitespace = /^\s+/,
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
        rtagName = /<([\w:]+)/,
        rtbody = /<tbody/i,
        rhtml = /<|&#?\w+;/,
        rnoInnerhtml = /<(?:script|style|link)/i,
        // checked="checked" or checked
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptType = /^$|\/(?:java|ecma)script/i,
        rscriptTypeMasked = /^true\/(.*)/,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

        // We have to close these tags to support XHTML (#13200)
        wrapMap = {
            option: [ 1, "<select multiple='multiple'>", "</select>" ],
            legend: [ 1, "<fieldset>", "</fieldset>" ],
            area: [ 1, "<map>", "</map>" ],
            param: [ 1, "<object>", "</object>" ],
            thead: [ 1, "<table>", "</table>" ],
            tr: [ 2, "<table><tbody>", "</tbody></table>" ],
            col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
            td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

            // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
            // unless wrapped in a div with non-breaking characters in front of it.
            _default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
        },
        safeFragment = createSafeFragment( document ),
        fragmentDiv = safeFragment.appendChild( document.createElement("div") );

    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    function getAll( context, tag ) {
        var elems, elem,
            i = 0,
            found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || "*" ) :
                typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || "*" ) :
                    undefined;

        if ( !found ) {
            for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
                if ( !tag || jQuery.nodeName( elem, tag ) ) {
                    found.push( elem );
                } else {
                    jQuery.merge( found, getAll( elem, tag ) );
                }
            }
        }

        return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
            jQuery.merge( [ context ], found ) :
            found;
    }

// Used in buildFragment, fixes the defaultChecked property
    function fixDefaultChecked( elem ) {
        if ( rcheckableType.test( elem.type ) ) {
            elem.defaultChecked = elem.checked;
        }
    }

// Support: IE<8
// Manipulating tables requires a tbody
    function manipulationTarget( elem, content ) {
        return jQuery.nodeName( elem, "table" ) &&
        jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

            elem.getElementsByTagName("tbody")[0] ||
            elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
            elem;
    }

// Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript( elem ) {
        elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
        return elem;
    }
    function restoreScript( elem ) {
        var match = rscriptTypeMasked.exec( elem.type );
        if ( match ) {
            elem.type = match[1];
        } else {
            elem.removeAttribute("type");
        }
        return elem;
    }

// Mark scripts as having already been evaluated
    function setGlobalEval( elems, refElements ) {
        var elem,
            i = 0;
        for ( ; (elem = elems[i]) != null; i++ ) {
            jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
        }
    }

    function cloneCopyEvent( src, dest ) {

        if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
            return;
        }

        var type, i, l,
            oldData = jQuery._data( src ),
            curData = jQuery._data( dest, oldData ),
            events = oldData.events;

        if ( events ) {
            delete curData.handle;
            curData.events = {};

            for ( type in events ) {
                for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                    jQuery.event.add( dest, type, events[ type ][ i ] );
                }
            }
        }

        // make the cloned public data object a copy from the original
        if ( curData.data ) {
            curData.data = jQuery.extend( {}, curData.data );
        }
    }

    function fixCloneNodeIssues( src, dest ) {
        var nodeName, e, data;

        // We do not need to do anything for non-Elements
        if ( dest.nodeType !== 1 ) {
            return;
        }

        nodeName = dest.nodeName.toLowerCase();

        // IE6-8 copies events bound via attachEvent when using cloneNode.
        if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
            data = jQuery._data( dest );

            for ( e in data.events ) {
                jQuery.removeEvent( dest, e, data.handle );
            }

            // Event data gets referenced instead of copied if the expando gets copied too
            dest.removeAttribute( jQuery.expando );
        }

        // IE blanks contents when cloning scripts, and tries to evaluate newly-set text
        if ( nodeName === "script" && dest.text !== src.text ) {
            disableScript( dest ).text = src.text;
            restoreScript( dest );

            // IE6-10 improperly clones children of object elements using classid.
            // IE10 throws NoModificationAllowedError if parent is null, #12132.
        } else if ( nodeName === "object" ) {
            if ( dest.parentNode ) {
                dest.outerHTML = src.outerHTML;
            }

            // This path appears unavoidable for IE9. When cloning an object
            // element in IE9, the outerHTML strategy above is not sufficient.
            // If the src has innerHTML and the destination does not,
            // copy the src.innerHTML into the dest.innerHTML. #10324
            if ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
                dest.innerHTML = src.innerHTML;
            }

        } else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
            // IE6-8 fails to persist the checked state of a cloned checkbox
            // or radio button. Worse, IE6-7 fail to give the cloned element
            // a checked appearance if the defaultChecked value isn't also set

            dest.defaultChecked = dest.checked = src.checked;

            // IE6-7 get confused and end up setting the value of a cloned
            // checkbox/radio button to an empty string instead of "on"
            if ( dest.value !== src.value ) {
                dest.value = src.value;
            }

            // IE6-8 fails to return the selected option to the default selected
            // state when cloning options
        } else if ( nodeName === "option" ) {
            dest.defaultSelected = dest.selected = src.defaultSelected;

            // IE6-8 fails to set the defaultValue to the correct value when
            // cloning other types of input fields
        } else if ( nodeName === "input" || nodeName === "textarea" ) {
            dest.defaultValue = src.defaultValue;
        }
    }

    jQuery.extend({
        clone: function( elem, dataAndEvents, deepDataAndEvents ) {
            var destElements, node, clone, i, srcElements,
                inPage = jQuery.contains( elem.ownerDocument, elem );

            if ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
                clone = elem.cloneNode( true );

                // IE<=8 does not properly clone detached, unknown element nodes
            } else {
                fragmentDiv.innerHTML = elem.outerHTML;
                fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
            }

            if ( (!support.noCloneEvent || !support.noCloneChecked) &&
                (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

                // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                destElements = getAll( clone );
                srcElements = getAll( elem );

                // Fix all IE cloning issues
                for ( i = 0; (node = srcElements[i]) != null; ++i ) {
                    // Ensure that the destination node is not null; Fixes #9587
                    if ( destElements[i] ) {
                        fixCloneNodeIssues( node, destElements[i] );
                    }
                }
            }

            // Copy the events from the original to the clone
            if ( dataAndEvents ) {
                if ( deepDataAndEvents ) {
                    srcElements = srcElements || getAll( elem );
                    destElements = destElements || getAll( clone );

                    for ( i = 0; (node = srcElements[i]) != null; i++ ) {
                        cloneCopyEvent( node, destElements[i] );
                    }
                } else {
                    cloneCopyEvent( elem, clone );
                }
            }

            // Preserve script evaluation history
            destElements = getAll( clone, "script" );
            if ( destElements.length > 0 ) {
                setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
            }

            destElements = srcElements = node = null;

            // Return the cloned set
            return clone;
        },

        buildFragment: function( elems, context, scripts, selection ) {
            var j, elem, contains,
                tmp, tag, tbody, wrap,
                l = elems.length,

                // Ensure a safe fragment
                safe = createSafeFragment( context ),

                nodes = [],
                i = 0;

            for ( ; i < l; i++ ) {
                elem = elems[ i ];

                if ( elem || elem === 0 ) {

                    // Add nodes directly
                    if ( jQuery.type( elem ) === "object" ) {
                        jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

                        // Convert non-html into a text node
                    } else if ( !rhtml.test( elem ) ) {
                        nodes.push( context.createTextNode( elem ) );

                        // Convert html into DOM nodes
                    } else {
                        tmp = tmp || safe.appendChild( context.createElement("div") );

                        // Deserialize a standard representation
                        tag = (rtagName.exec( elem ) || [ "", "" ])[ 1 ].toLowerCase();
                        wrap = wrapMap[ tag ] || wrapMap._default;

                        tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

                        // Descend through wrappers to the right content
                        j = wrap[0];
                        while ( j-- ) {
                            tmp = tmp.lastChild;
                        }

                        // Manually add leading whitespace removed by IE
                        if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
                            nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
                        }

                        // Remove IE's autoinserted <tbody> from table fragments
                        if ( !support.tbody ) {

                            // String was a <table>, *may* have spurious <tbody>
                            elem = tag === "table" && !rtbody.test( elem ) ?
                                tmp.firstChild :

                                // String was a bare <thead> or <tfoot>
                                wrap[1] === "<table>" && !rtbody.test( elem ) ?
                                    tmp :
                                    0;

                            j = elem && elem.childNodes.length;
                            while ( j-- ) {
                                if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
                                    elem.removeChild( tbody );
                                }
                            }
                        }

                        jQuery.merge( nodes, tmp.childNodes );

                        // Fix #12392 for WebKit and IE > 9
                        tmp.textContent = "";

                        // Fix #12392 for oldIE
                        while ( tmp.firstChild ) {
                            tmp.removeChild( tmp.firstChild );
                        }

                        // Remember the top-level container for proper cleanup
                        tmp = safe.lastChild;
                    }
                }
            }

            // Fix #11356: Clear elements from fragment
            if ( tmp ) {
                safe.removeChild( tmp );
            }

            // Reset defaultChecked for any radios and checkboxes
            // about to be appended to the DOM in IE 6/7 (#8060)
            if ( !support.appendChecked ) {
                jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
            }

            i = 0;
            while ( (elem = nodes[ i++ ]) ) {

                // #4087 - If origin and destination elements are the same, and this is
                // that element, do not do anything
                if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
                    continue;
                }

                contains = jQuery.contains( elem.ownerDocument, elem );

                // Append to fragment
                tmp = getAll( safe.appendChild( elem ), "script" );

                // Preserve script evaluation history
                if ( contains ) {
                    setGlobalEval( tmp );
                }

                // Capture executables
                if ( scripts ) {
                    j = 0;
                    while ( (elem = tmp[ j++ ]) ) {
                        if ( rscriptType.test( elem.type || "" ) ) {
                            scripts.push( elem );
                        }
                    }
                }
            }

            tmp = null;

            return safe;
        },

        cleanData: function( elems, /* internal */ acceptData ) {
            var elem, type, id, data,
                i = 0,
                internalKey = jQuery.expando,
                cache = jQuery.cache,
                deleteExpando = support.deleteExpando,
                special = jQuery.event.special;

            for ( ; (elem = elems[i]) != null; i++ ) {
                if ( acceptData || jQuery.acceptData( elem ) ) {

                    id = elem[ internalKey ];
                    data = id && cache[ id ];

                    if ( data ) {
                        if ( data.events ) {
                            for ( type in data.events ) {
                                if ( special[ type ] ) {
                                    jQuery.event.remove( elem, type );

                                    // This is a shortcut to avoid jQuery.event.remove's overhead
                                } else {
                                    jQuery.removeEvent( elem, type, data.handle );
                                }
                            }
                        }

                        // Remove cache only if it was not already removed by jQuery.event.remove
                        if ( cache[ id ] ) {

                            delete cache[ id ];

                            // IE does not allow us to delete expando properties from nodes,
                            // nor does it have a removeAttribute function on Document nodes;
                            // we must handle all of these cases
                            if ( deleteExpando ) {
                                delete elem[ internalKey ];

                            } else if ( typeof elem.removeAttribute !== strundefined ) {
                                elem.removeAttribute( internalKey );

                            } else {
                                elem[ internalKey ] = null;
                            }

                            deletedIds.push( id );
                        }
                    }
                }
            }
        }
    });

    jQuery.fn.extend({
        text: function( value ) {
            return access( this, function( value ) {
                return value === undefined ?
                    jQuery.text( this ) :
                    this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
            }, null, value, arguments.length );
        },

        append: function() {
            return this.domManip( arguments, function( elem ) {
                if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                    var target = manipulationTarget( this, elem );
                    target.appendChild( elem );
                }
            });
        },

        prepend: function() {
            return this.domManip( arguments, function( elem ) {
                if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                    var target = manipulationTarget( this, elem );
                    target.insertBefore( elem, target.firstChild );
                }
            });
        },

        before: function() {
            return this.domManip( arguments, function( elem ) {
                if ( this.parentNode ) {
                    this.parentNode.insertBefore( elem, this );
                }
            });
        },

        after: function() {
            return this.domManip( arguments, function( elem ) {
                if ( this.parentNode ) {
                    this.parentNode.insertBefore( elem, this.nextSibling );
                }
            });
        },

        remove: function( selector, keepData /* Internal Use Only */ ) {
            var elem,
                elems = selector ? jQuery.filter( selector, this ) : this,
                i = 0;

            for ( ; (elem = elems[i]) != null; i++ ) {

                if ( !keepData && elem.nodeType === 1 ) {
                    jQuery.cleanData( getAll( elem ) );
                }

                if ( elem.parentNode ) {
                    if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
                        setGlobalEval( getAll( elem, "script" ) );
                    }
                    elem.parentNode.removeChild( elem );
                }
            }

            return this;
        },

        empty: function() {
            var elem,
                i = 0;

            for ( ; (elem = this[i]) != null; i++ ) {
                // Remove element nodes and prevent memory leaks
                if ( elem.nodeType === 1 ) {
                    jQuery.cleanData( getAll( elem, false ) );
                }

                // Remove any remaining nodes
                while ( elem.firstChild ) {
                    elem.removeChild( elem.firstChild );
                }

                // If this is a select, ensure that it displays empty (#12336)
                // Support: IE<9
                if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
                    elem.options.length = 0;
                }
            }

            return this;
        },

        clone: function( dataAndEvents, deepDataAndEvents ) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map(function() {
                return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
            });
        },

        html: function( value ) {
            return access( this, function( value ) {
                var elem = this[ 0 ] || {},
                    i = 0,
                    l = this.length;

                if ( value === undefined ) {
                    return elem.nodeType === 1 ?
                        elem.innerHTML.replace( rinlinejQuery, "" ) :
                        undefined;
                }

                // See if we can take a shortcut and just use innerHTML
                if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
                    ( support.htmlSerialize || !rnoshimcache.test( value )  ) &&
                    ( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
                    !wrapMap[ (rtagName.exec( value ) || [ "", "" ])[ 1 ].toLowerCase() ] ) {

                    value = value.replace( rxhtmlTag, "<$1></$2>" );

                    try {
                        for (; i < l; i++ ) {
                            // Remove element nodes and prevent memory leaks
                            elem = this[i] || {};
                            if ( elem.nodeType === 1 ) {
                                jQuery.cleanData( getAll( elem, false ) );
                                elem.innerHTML = value;
                            }
                        }

                        elem = 0;

                        // If using innerHTML throws an exception, use the fallback method
                    } catch(e) {}
                }

                if ( elem ) {
                    this.empty().append( value );
                }
            }, null, value, arguments.length );
        },

        replaceWith: function() {
            var arg = arguments[ 0 ];

            // Make the changes, replacing each context element with the new content
            this.domManip( arguments, function( elem ) {
                arg = this.parentNode;

                jQuery.cleanData( getAll( this ) );

                if ( arg ) {
                    arg.replaceChild( elem, this );
                }
            });

            // Force removal if there was no new content (e.g., from empty arguments)
            return arg && (arg.length || arg.nodeType) ? this : this.remove();
        },

        detach: function( selector ) {
            return this.remove( selector, true );
        },

        domManip: function( args, callback ) {

            // Flatten any nested arrays
            args = concat.apply( [], args );

            var first, node, hasScripts,
                scripts, doc, fragment,
                i = 0,
                l = this.length,
                set = this,
                iNoClone = l - 1,
                value = args[0],
                isFunction = jQuery.isFunction( value );

            // We can't cloneNode fragments that contain checked, in WebKit
            if ( isFunction ||
                ( l > 1 && typeof value === "string" &&
                    !support.checkClone && rchecked.test( value ) ) ) {
                return this.each(function( index ) {
                    var self = set.eq( index );
                    if ( isFunction ) {
                        args[0] = value.call( this, index, self.html() );
                    }
                    self.domManip( args, callback );
                });
            }

            if ( l ) {
                fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
                first = fragment.firstChild;

                if ( fragment.childNodes.length === 1 ) {
                    fragment = first;
                }

                if ( first ) {
                    scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
                    hasScripts = scripts.length;

                    // Use the original fragment for the last item instead of the first because it can end up
                    // being emptied incorrectly in certain situations (#8070).
                    for ( ; i < l; i++ ) {
                        node = fragment;

                        if ( i !== iNoClone ) {
                            node = jQuery.clone( node, true, true );

                            // Keep references to cloned scripts for later restoration
                            if ( hasScripts ) {
                                jQuery.merge( scripts, getAll( node, "script" ) );
                            }
                        }

                        callback.call( this[i], node, i );
                    }

                    if ( hasScripts ) {
                        doc = scripts[ scripts.length - 1 ].ownerDocument;

                        // Reenable scripts
                        jQuery.map( scripts, restoreScript );

                        // Evaluate executable scripts on first document insertion
                        for ( i = 0; i < hasScripts; i++ ) {
                            node = scripts[ i ];
                            if ( rscriptType.test( node.type || "" ) &&
                                !jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

                                if ( node.src ) {
                                    // Optional AJAX dependency, but won't run scripts if not present
                                    if ( jQuery._evalUrl ) {
                                        jQuery._evalUrl( node.src );
                                    }
                                } else {
                                    jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
                                }
                            }
                        }
                    }

                    // Fix #11809: Avoid leaking memory
                    fragment = first = null;
                }
            }

            return this;
        }
    });

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function( name, original ) {
        jQuery.fn[ name ] = function( selector ) {
            var elems,
                i = 0,
                ret = [],
                insert = jQuery( selector ),
                last = insert.length - 1;

            for ( ; i <= last; i++ ) {
                elems = i === last ? this : this.clone(true);
                jQuery( insert[i] )[ original ]( elems );

                // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
                push.apply( ret, elems.get() );
            }

            return this.pushStack( ret );
        };
    });


    var iframe,
        elemdisplay = {};

    /**
     * Retrieve the actual display of a element
     * @param {String} name nodeName of the element
     * @param {Object} doc Document object
     */
// Called only from within defaultDisplay
    function actualDisplay( name, doc ) {
        var style,
            elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

            // getDefaultComputedStyle might be reliably used only on attached element
            display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

                // Use of this method is a temporary fix (more like optmization) until something better comes along,
                // since it was removed from specification and supported only in FF
                style.display : jQuery.css( elem[ 0 ], "display" );

        // We don't have any data stored on the element,
        // so use "detach" method as fast way to get rid of the element
        elem.detach();

        return display;
    }

    /**
     * Try to determine the default display value of an element
     * @param {String} nodeName
     */
    function defaultDisplay( nodeName ) {
        var doc = document,
            display = elemdisplay[ nodeName ];

        if ( !display ) {
            display = actualDisplay( nodeName, doc );

            // If the simple way fails, read from inside an iframe
            if ( display === "none" || !display ) {

                // Use the already-created iframe if possible
                iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

                // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;

                // Support: IE
                doc.write();
                doc.close();

                display = actualDisplay( nodeName, doc );
                iframe.detach();
            }

            // Store the correct default display
            elemdisplay[ nodeName ] = display;
        }

        return display;
    }


    (function() {
        var shrinkWrapBlocksVal;

        support.shrinkWrapBlocks = function() {
            if ( shrinkWrapBlocksVal != null ) {
                return shrinkWrapBlocksVal;
            }

            // Will be changed later if needed.
            shrinkWrapBlocksVal = false;

            // Minified: var b,c,d
            var div, body, container;

            body = document.getElementsByTagName( "body" )[ 0 ];
            if ( !body || !body.style ) {
                // Test fired too early or in an unsupported environment, exit.
                return;
            }

            // Setup
            div = document.createElement( "div" );
            container = document.createElement( "div" );
            container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
            body.appendChild( container ).appendChild( div );

            // Support: IE6
            // Check if elements with layout shrink-wrap their children
            if ( typeof div.style.zoom !== strundefined ) {
                // Reset CSS: box-sizing; display; margin; border
                div.style.cssText =
                    // Support: Firefox<29, Android 2.3
                    // Vendor-prefix box-sizing
                    "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                    "box-sizing:content-box;display:block;margin:0;border:0;" +
                    "padding:1px;width:1px;zoom:1";
                div.appendChild( document.createElement( "div" ) ).style.width = "5px";
                shrinkWrapBlocksVal = div.offsetWidth !== 3;
            }

            body.removeChild( container );

            return shrinkWrapBlocksVal;
        };

    })();
    var rmargin = (/^margin/);

    var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );



    var getStyles, curCSS,
        rposition = /^(top|right|bottom|left)$/;

    if ( window.getComputedStyle ) {
        getStyles = function( elem ) {
            // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
            // IE throws on elements created in popups
            // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
            if ( elem.ownerDocument.defaultView.opener ) {
                return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
            }

            return window.getComputedStyle( elem, null );
        };

        curCSS = function( elem, name, computed ) {
            var width, minWidth, maxWidth, ret,
                style = elem.style;

            computed = computed || getStyles( elem );

            // getPropertyValue is only needed for .css('filter') in IE9, see #12537
            ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

            if ( computed ) {

                if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
                    ret = jQuery.style( elem, name );
                }

                // A tribute to the "awesome hack by Dean Edwards"
                // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
                // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
                // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
                if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

                    // Remember the original values
                    width = style.width;
                    minWidth = style.minWidth;
                    maxWidth = style.maxWidth;

                    // Put in the new values to get a computed value out
                    style.minWidth = style.maxWidth = style.width = ret;
                    ret = computed.width;

                    // Revert the changed values
                    style.width = width;
                    style.minWidth = minWidth;
                    style.maxWidth = maxWidth;
                }
            }

            // Support: IE
            // IE returns zIndex value as an integer.
            return ret === undefined ?
                ret :
                ret + "";
        };
    } else if ( document.documentElement.currentStyle ) {
        getStyles = function( elem ) {
            return elem.currentStyle;
        };

        curCSS = function( elem, name, computed ) {
            var left, rs, rsLeft, ret,
                style = elem.style;

            computed = computed || getStyles( elem );
            ret = computed ? computed[ name ] : undefined;

            // Avoid setting ret to empty string here
            // so we don't default to auto
            if ( ret == null && style && style[ name ] ) {
                ret = style[ name ];
            }

            // From the awesome hack by Dean Edwards
            // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

            // If we're not dealing with a regular pixel number
            // but a number that has a weird ending, we need to convert it to pixels
            // but not position css attributes, as those are proportional to the parent element instead
            // and we can't measure the parent instead because it might trigger a "stacking dolls" problem
            if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

                // Remember the original values
                left = style.left;
                rs = elem.runtimeStyle;
                rsLeft = rs && rs.left;

                // Put in the new values to get a computed value out
                if ( rsLeft ) {
                    rs.left = elem.currentStyle.left;
                }
                style.left = name === "fontSize" ? "1em" : ret;
                ret = style.pixelLeft + "px";

                // Revert the changed values
                style.left = left;
                if ( rsLeft ) {
                    rs.left = rsLeft;
                }
            }

            // Support: IE
            // IE returns zIndex value as an integer.
            return ret === undefined ?
                ret :
                ret + "" || "auto";
        };
    }




    function addGetHookIf( conditionFn, hookFn ) {
        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function() {
                var condition = conditionFn();

                if ( condition == null ) {
                    // The test was not ready at this point; screw the hook this time
                    // but check again when needed next time.
                    return;
                }

                if ( condition ) {
                    // Hook not needed (or it's not possible to use it due to missing dependency),
                    // remove it.
                    // Since there are no other hooks for marginRight, remove the whole object.
                    delete this.get;
                    return;
                }

                // Hook needed; redefine it so that the support test is not executed again.

                return (this.get = hookFn).apply( this, arguments );
            }
        };
    }


    (function() {
        // Minified: var b,c,d,e,f,g, h,i
        var div, style, a, pixelPositionVal, boxSizingReliableVal,
            reliableHiddenOffsetsVal, reliableMarginRightVal;

        // Setup
        div = document.createElement( "div" );
        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
        a = div.getElementsByTagName( "a" )[ 0 ];
        style = a && a.style;

        // Finish early in limited (non-browser) environments
        if ( !style ) {
            return;
        }

        style.cssText = "float:left;opacity:.5";

        // Support: IE<9
        // Make sure that element opacity exists (as opposed to filter)
        support.opacity = style.opacity === "0.5";

        // Verify style float existence
        // (IE uses styleFloat instead of cssFloat)
        support.cssFloat = !!style.cssFloat;

        div.style.backgroundClip = "content-box";
        div.cloneNode( true ).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";

        // Support: Firefox<29, Android 2.3
        // Vendor-prefix box-sizing
        support.boxSizing = style.boxSizing === "" || style.MozBoxSizing === "" ||
            style.WebkitBoxSizing === "";

        jQuery.extend(support, {
            reliableHiddenOffsets: function() {
                if ( reliableHiddenOffsetsVal == null ) {
                    computeStyleTests();
                }
                return reliableHiddenOffsetsVal;
            },

            boxSizingReliable: function() {
                if ( boxSizingReliableVal == null ) {
                    computeStyleTests();
                }
                return boxSizingReliableVal;
            },

            pixelPosition: function() {
                if ( pixelPositionVal == null ) {
                    computeStyleTests();
                }
                return pixelPositionVal;
            },

            // Support: Android 2.3
            reliableMarginRight: function() {
                if ( reliableMarginRightVal == null ) {
                    computeStyleTests();
                }
                return reliableMarginRightVal;
            }
        });

        function computeStyleTests() {
            // Minified: var b,c,d,j
            var div, body, container, contents;

            body = document.getElementsByTagName( "body" )[ 0 ];
            if ( !body || !body.style ) {
                // Test fired too early or in an unsupported environment, exit.
                return;
            }

            // Setup
            div = document.createElement( "div" );
            container = document.createElement( "div" );
            container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
            body.appendChild( container ).appendChild( div );

            div.style.cssText =
                // Support: Firefox<29, Android 2.3
                // Vendor-prefix box-sizing
                "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
                "box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
                "border:1px;padding:1px;width:4px;position:absolute";

            // Support: IE<9
            // Assume reasonable values in the absence of getComputedStyle
            pixelPositionVal = boxSizingReliableVal = false;
            reliableMarginRightVal = true;

            // Check for getComputedStyle so that this code is not run in IE<9.
            if ( window.getComputedStyle ) {
                pixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
                boxSizingReliableVal =
                    ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

                // Support: Android 2.3
                // Div with explicit width and no margin-right incorrectly
                // gets computed margin-right based on width of container (#3333)
                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                contents = div.appendChild( document.createElement( "div" ) );

                // Reset CSS: box-sizing; display; margin; border; padding
                contents.style.cssText = div.style.cssText =
                    // Support: Firefox<29, Android 2.3
                    // Vendor-prefix box-sizing
                    "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
                    "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
                contents.style.marginRight = contents.style.width = "0";
                div.style.width = "1px";

                reliableMarginRightVal =
                    !parseFloat( ( window.getComputedStyle( contents, null ) || {} ).marginRight );

                div.removeChild( contents );
            }

            // Support: IE8
            // Check if table cells still have offsetWidth/Height when they are set
            // to display:none and there are still other visible table cells in a
            // table row; if so, offsetWidth/Height are not reliable for use when
            // determining if an element has been hidden directly using
            // display:none (it is still safe to use offsets if a parent element is
            // hidden; don safety goggles and see bug #4512 for more information).
            div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
            contents = div.getElementsByTagName( "td" );
            contents[ 0 ].style.cssText = "margin:0;border:0;padding:0;display:none";
            reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
            if ( reliableHiddenOffsetsVal ) {
                contents[ 0 ].style.display = "";
                contents[ 1 ].style.display = "none";
                reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
            }

            body.removeChild( container );
        }

    })();


// A method for quickly swapping in/out CSS properties to get correct calculations.
    jQuery.swap = function( elem, options, callback, args ) {
        var ret, name,
            old = {};

        // Remember the old values, and insert the new ones
        for ( name in options ) {
            old[ name ] = elem.style[ name ];
            elem.style[ name ] = options[ name ];
        }

        ret = callback.apply( elem, args || [] );

        // Revert the old values
        for ( name in options ) {
            elem.style[ name ] = old[ name ];
        }

        return ret;
    };


    var
        ralpha = /alpha\([^)]*\)/i,
        ropacity = /opacity\s*=\s*([^)]*)/,

        // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
        // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
        rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
        rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

        cssShow = { position: "absolute", visibility: "hidden", display: "block" },
        cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
        },

        cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];


// return a css property mapped to a potentially vendor prefixed property
    function vendorPropName( style, name ) {

        // shortcut for names that are not vendor prefixed
        if ( name in style ) {
            return name;
        }

        // check for vendor prefixed names
        var capName = name.charAt(0).toUpperCase() + name.slice(1),
            origName = name,
            i = cssPrefixes.length;

        while ( i-- ) {
            name = cssPrefixes[ i ] + capName;
            if ( name in style ) {
                return name;
            }
        }

        return origName;
    }

    function showHide( elements, show ) {
        var display, elem, hidden,
            values = [],
            index = 0,
            length = elements.length;

        for ( ; index < length; index++ ) {
            elem = elements[ index ];
            if ( !elem.style ) {
                continue;
            }

            values[ index ] = jQuery._data( elem, "olddisplay" );
            display = elem.style.display;
            if ( show ) {
                // Reset the inline display of this element to learn if it is
                // being hidden by cascaded rules or not
                if ( !values[ index ] && display === "none" ) {
                    elem.style.display = "";
                }

                // Set elements which have been overridden with display: none
                // in a stylesheet to whatever the default browser style is
                // for such an element
                if ( elem.style.display === "" && isHidden( elem ) ) {
                    values[ index ] = jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
                }
            } else {
                hidden = isHidden( elem );

                if ( display && display !== "none" || !hidden ) {
                    jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
                }
            }
        }

        // Set the display of most of the elements in a second loop
        // to avoid the constant reflow
        for ( index = 0; index < length; index++ ) {
            elem = elements[ index ];
            if ( !elem.style ) {
                continue;
            }
            if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
                elem.style.display = show ? values[ index ] || "" : "none";
            }
        }

        return elements;
    }

    function setPositiveNumber( elem, value, subtract ) {
        var matches = rnumsplit.exec( value );
        return matches ?
            // Guard against undefined "subtract", e.g., when used as in cssHooks
            Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
            value;
    }

    function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
        var i = extra === ( isBorderBox ? "border" : "content" ) ?
            // If we already have the right measurement, avoid augmentation
            4 :
            // Otherwise initialize for horizontal or vertical properties
            name === "width" ? 1 : 0,

            val = 0;

        for ( ; i < 4; i += 2 ) {
            // both box models exclude margin, so add it if we want it
            if ( extra === "margin" ) {
                val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
            }

            if ( isBorderBox ) {
                // border-box includes padding, so remove it if we want content
                if ( extra === "content" ) {
                    val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
                }

                // at this point, extra isn't border nor margin, so remove border
                if ( extra !== "margin" ) {
                    val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                }
            } else {
                // at this point, extra isn't content, so add padding
                val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

                // at this point, extra isn't content nor padding, so add border
                if ( extra !== "padding" ) {
                    val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
                }
            }
        }

        return val;
    }

    function getWidthOrHeight( elem, name, extra ) {

        // Start with offset property, which is equivalent to the border-box value
        var valueIsBorderBox = true,
            val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
            styles = getStyles( elem ),
            isBorderBox = support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

        // some non-html elements return undefined for offsetWidth, so check for null/undefined
        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
        if ( val <= 0 || val == null ) {
            // Fall back to computed then uncomputed css if necessary
            val = curCSS( elem, name, styles );
            if ( val < 0 || val == null ) {
                val = elem.style[ name ];
            }

            // Computed unit is not pixels. Stop here and return.
            if ( rnumnonpx.test(val) ) {
                return val;
            }

            // we need the check for style in case a browser which returns unreliable values
            // for getComputedStyle silently falls back to the reliable elem.style
            valueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );

            // Normalize "", auto, and prepare for extra
            val = parseFloat( val ) || 0;
        }

        // use the active box-sizing model to add/subtract irrelevant styles
        return ( val +
            augmentWidthOrHeight(
                elem,
                name,
                extra || ( isBorderBox ? "border" : "content" ),
                valueIsBorderBox,
                styles
            )
        ) + "px";
    }

    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function( elem, computed ) {
                    if ( computed ) {
                        // We should always get a number back from opacity
                        var ret = curCSS( elem, "opacity" );
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },

        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            // normalize float css property
            "float": support.cssFloat ? "cssFloat" : "styleFloat"
        },

        // Get and set the style property on a DOM Node
        style: function( elem, name, value, extra ) {
            // Don't set styles on text and comment nodes
            if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, hooks,
                origName = jQuery.camelCase( name ),
                style = elem.style;

            name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

            // gets hook for the prefixed version
            // followed by the unprefixed version
            hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

            // Check if we're setting a value
            if ( value !== undefined ) {
                type = typeof value;

                // convert relative number strings (+= or -=) to relative numbers. #7345
                if ( type === "string" && (ret = rrelNum.exec( value )) ) {
                    value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
                    // Fixes bug #9237
                    type = "number";
                }

                // Make sure that null and NaN values aren't set. See: #7116
                if ( value == null || value !== value ) {
                    return;
                }

                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
                    value += "px";
                }

                // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
                // but it would mean to define eight (for every problematic property) identical functions
                if ( !support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
                    style[ name ] = "inherit";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

                    // Support: IE
                    // Swallow errors from 'invalid' CSS values (#5509)
                    try {
                        style[ name ] = value;
                    } catch(e) {}
                }

            } else {
                // If a hook was provided get the non-computed value from there
                if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[ name ];
            }
        },

        css: function( elem, name, extra, styles ) {
            var num, val, hooks,
                origName = jQuery.camelCase( name );

            // Make sure that we're working with the right name
            name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

            // gets hook for the prefixed version
            // followed by the unprefixed version
            hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

            // If a hook was provided get the computed value from there
            if ( hooks && "get" in hooks ) {
                val = hooks.get( elem, true, extra );
            }

            // Otherwise, if a way to get the computed value exists, use that
            if ( val === undefined ) {
                val = curCSS( elem, name, styles );
            }

            //convert "normal" to computed value
            if ( val === "normal" && name in cssNormalTransform ) {
                val = cssNormalTransform[ name ];
            }

            // Return, converting to number if forced or a qualifier was provided and val looks numeric
            if ( extra === "" || extra ) {
                num = parseFloat( val );
                return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
            }
            return val;
        }
    });

    jQuery.each([ "height", "width" ], function( i, name ) {
        jQuery.cssHooks[ name ] = {
            get: function( elem, computed, extra ) {
                if ( computed ) {
                    // certain elements can have dimension info if we invisibly show them
                    // however, it must have a current display style that would benefit from this
                    return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
                        jQuery.swap( elem, cssShow, function() {
                            return getWidthOrHeight( elem, name, extra );
                        }) :
                        getWidthOrHeight( elem, name, extra );
                }
            },

            set: function( elem, value, extra ) {
                var styles = extra && getStyles( elem );
                return setPositiveNumber( elem, value, extra ?
                    augmentWidthOrHeight(
                        elem,
                        name,
                        extra,
                        support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
                        styles
                    ) : 0
                );
            }
        };
    });

    if ( !support.opacity ) {
        jQuery.cssHooks.opacity = {
            get: function( elem, computed ) {
                // IE uses filters for opacity
                return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
                    ( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
                    computed ? "1" : "";
            },

            set: function( elem, value ) {
                var style = elem.style,
                    currentStyle = elem.currentStyle,
                    opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
                    filter = currentStyle && currentStyle.filter || style.filter || "";

                // IE has trouble with opacity if it does not have layout
                // Force it by setting the zoom level
                style.zoom = 1;

                // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
                // if value === "", then remove inline opacity #12685
                if ( ( value >= 1 || value === "" ) &&
                    jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
                    style.removeAttribute ) {

                    // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                    // if "filter:" is present at all, clearType is disabled, we want to avoid this
                    // style.removeAttribute is IE Only, but so apparently is this code path...
                    style.removeAttribute( "filter" );

                    // if there is no filter style applied in a css rule or unset inline opacity, we are done
                    if ( value === "" || currentStyle && !currentStyle.filter ) {
                        return;
                    }
                }

                // otherwise, set new filter values
                style.filter = ralpha.test( filter ) ?
                    filter.replace( ralpha, opacity ) :
                    filter + " " + opacity;
            }
        };
    }

    jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
        function( elem, computed ) {
            if ( computed ) {
                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                // Work around by temporarily setting element display to inline-block
                return jQuery.swap( elem, { "display": "inline-block" },
                    curCSS, [ elem, "marginRight" ] );
            }
        }
    );

// These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function( prefix, suffix ) {
        jQuery.cssHooks[ prefix + suffix ] = {
            expand: function( value ) {
                var i = 0,
                    expanded = {},

                    // assumes a single number if not a string
                    parts = typeof value === "string" ? value.split(" ") : [ value ];

                for ( ; i < 4; i++ ) {
                    expanded[ prefix + cssExpand[ i ] + suffix ] =
                        parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
                }

                return expanded;
            }
        };

        if ( !rmargin.test( prefix ) ) {
            jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
        }
    });

    jQuery.fn.extend({
        css: function( name, value ) {
            return access( this, function( elem, name, value ) {
                var styles, len,
                    map = {},
                    i = 0;

                if ( jQuery.isArray( name ) ) {
                    styles = getStyles( elem );
                    len = name.length;

                    for ( ; i < len; i++ ) {
                        map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                    }

                    return map;
                }

                return value !== undefined ?
                    jQuery.style( elem, name, value ) :
                    jQuery.css( elem, name );
            }, name, value, arguments.length > 1 );
        },
        show: function() {
            return showHide( this, true );
        },
        hide: function() {
            return showHide( this );
        },
        toggle: function( state ) {
            if ( typeof state === "boolean" ) {
                return state ? this.show() : this.hide();
            }

            return this.each(function() {
                if ( isHidden( this ) ) {
                    jQuery( this ).show();
                } else {
                    jQuery( this ).hide();
                }
            });
        }
    });


    function Tween( elem, options, prop, end, easing ) {
        return new Tween.prototype.init( elem, options, prop, end, easing );
    }
    jQuery.Tween = Tween;

    Tween.prototype = {
        constructor: Tween,
        init: function( elem, options, prop, end, easing, unit ) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || "swing";
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
        },
        cur: function() {
            var hooks = Tween.propHooks[ this.prop ];

            return hooks && hooks.get ?
                hooks.get( this ) :
                Tween.propHooks._default.get( this );
        },
        run: function( percent ) {
            var eased,
                hooks = Tween.propHooks[ this.prop ];

            if ( this.options.duration ) {
                this.pos = eased = jQuery.easing[ this.easing ](
                    percent, this.options.duration * percent, 0, 1, this.options.duration
                );
            } else {
                this.pos = eased = percent;
            }
            this.now = ( this.end - this.start ) * eased + this.start;

            if ( this.options.step ) {
                this.options.step.call( this.elem, this.now, this );
            }

            if ( hooks && hooks.set ) {
                hooks.set( this );
            } else {
                Tween.propHooks._default.set( this );
            }
            return this;
        }
    };

    Tween.prototype.init.prototype = Tween.prototype;

    Tween.propHooks = {
        _default: {
            get: function( tween ) {
                var result;

                if ( tween.elem[ tween.prop ] != null &&
                    (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
                    return tween.elem[ tween.prop ];
                }

                // passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails
                // so, simple values such as "10px" are parsed to Float.
                // complex values such as "rotate(1rad)" are returned as is.
                result = jQuery.css( tween.elem, tween.prop, "" );
                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function( tween ) {
                // use step hook for back compat - use cssHook if its there - use .style if its
                // available and use plain properties where available
                if ( jQuery.fx.step[ tween.prop ] ) {
                    jQuery.fx.step[ tween.prop ]( tween );
                } else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
                    jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
                } else {
                    tween.elem[ tween.prop ] = tween.now;
                }
            }
        }
    };

// Support: IE <=9
// Panic based approach to setting things on disconnected nodes

    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function( tween ) {
            if ( tween.elem.nodeType && tween.elem.parentNode ) {
                tween.elem[ tween.prop ] = tween.now;
            }
        }
    };

    jQuery.easing = {
        linear: function( p ) {
            return p;
        },
        swing: function( p ) {
            return 0.5 - Math.cos( p * Math.PI ) / 2;
        }
    };

    jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
    jQuery.fx.step = {};




    var
        fxNow, timerId,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
        rrun = /queueHooks$/,
        animationPrefilters = [ defaultPrefilter ],
        tweeners = {
            "*": [ function( prop, value ) {
                var tween = this.createTween( prop, value ),
                    target = tween.cur(),
                    parts = rfxnum.exec( value ),
                    unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

                    // Starting value computation is required for potential unit mismatches
                    start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
                        rfxnum.exec( jQuery.css( tween.elem, prop ) ),
                    scale = 1,
                    maxIterations = 20;

                if ( start && start[ 3 ] !== unit ) {
                    // Trust units reported by jQuery.css
                    unit = unit || start[ 3 ];

                    // Make sure we update the tween properties later on
                    parts = parts || [];

                    // Iteratively approximate from a nonzero starting point
                    start = +target || 1;

                    do {
                        // If previous iteration zeroed out, double until we get *something*
                        // Use a string for doubling factor so we don't accidentally see scale as unchanged below
                        scale = scale || ".5";

                        // Adjust and apply
                        start = start / scale;
                        jQuery.style( tween.elem, prop, start + unit );

                        // Update scale, tolerating zero or NaN from tween.cur()
                        // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
                    } while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
                }

                // Update tween properties
                if ( parts ) {
                    start = tween.start = +start || +target || 0;
                    tween.unit = unit;
                    // If a +=/-= token was provided, we're doing a relative animation
                    tween.end = parts[ 1 ] ?
                        start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
                        +parts[ 2 ];
                }

                return tween;
            } ]
        };

// Animations created synchronously will run synchronously
    function createFxNow() {
        setTimeout(function() {
            fxNow = undefined;
        });
        return ( fxNow = jQuery.now() );
    }

// Generate parameters to create a standard animation
    function genFx( type, includeWidth ) {
        var which,
            attrs = { height: type },
            i = 0;

        // if we include width, step value is 1 to do all cssExpand values,
        // if we don't include width, step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for ( ; i < 4 ; i += 2 - includeWidth ) {
            which = cssExpand[ i ];
            attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
        }

        if ( includeWidth ) {
            attrs.opacity = attrs.width = type;
        }

        return attrs;
    }

    function createTween( value, prop, animation ) {
        var tween,
            collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
            index = 0,
            length = collection.length;
        for ( ; index < length; index++ ) {
            if ( (tween = collection[ index ].call( animation, prop, value )) ) {

                // we're done with this property
                return tween;
            }
        }
    }

    function defaultPrefilter( elem, props, opts ) {
        /* jshint validthis: true */
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
            anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHidden( elem ),
            dataShow = jQuery._data( elem, "fxshow" );

        // handle queue: false promises
        if ( !opts.queue ) {
            hooks = jQuery._queueHooks( elem, "fx" );
            if ( hooks.unqueued == null ) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if ( !hooks.unqueued ) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;

            anim.always(function() {
                // doing this makes sure that the complete handler will be called
                // before this completes
                anim.always(function() {
                    hooks.unqueued--;
                    if ( !jQuery.queue( elem, "fx" ).length ) {
                        hooks.empty.fire();
                    }
                });
            });
        }

        // height/width overflow pass
        if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
            // Make sure that nothing sneaks out
            // Record all 3 overflow attributes because IE does not
            // change the overflow attribute when overflowX and
            // overflowY are set to the same value
            opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

            // Set display property to inline-block for height/width
            // animations on inline elements that are having width/height animated
            display = jQuery.css( elem, "display" );

            // Test default display if display is currently "none"
            checkDisplay = display === "none" ?
                jQuery._data( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

            if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {

                // inline-level elements accept inline-block;
                // block-level elements need to be inline with layout
                if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === "inline" ) {
                    style.display = "inline-block";
                } else {
                    style.zoom = 1;
                }
            }
        }

        if ( opts.overflow ) {
            style.overflow = "hidden";
            if ( !support.shrinkWrapBlocks() ) {
                anim.always(function() {
                    style.overflow = opts.overflow[ 0 ];
                    style.overflowX = opts.overflow[ 1 ];
                    style.overflowY = opts.overflow[ 2 ];
                });
            }
        }

        // show/hide pass
        for ( prop in props ) {
            value = props[ prop ];
            if ( rfxtypes.exec( value ) ) {
                delete props[ prop ];
                toggle = toggle || value === "toggle";
                if ( value === ( hidden ? "hide" : "show" ) ) {

                    // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                    if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

                // Any non-fx value stops us from restoring the original display value
            } else {
                display = undefined;
            }
        }

        if ( !jQuery.isEmptyObject( orig ) ) {
            if ( dataShow ) {
                if ( "hidden" in dataShow ) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = jQuery._data( elem, "fxshow", {} );
            }

            // store state if its toggle - enables .stop().toggle() to "reverse"
            if ( toggle ) {
                dataShow.hidden = !hidden;
            }
            if ( hidden ) {
                jQuery( elem ).show();
            } else {
                anim.done(function() {
                    jQuery( elem ).hide();
                });
            }
            anim.done(function() {
                var prop;
                jQuery._removeData( elem, "fxshow" );
                for ( prop in orig ) {
                    jQuery.style( elem, prop, orig[ prop ] );
                }
            });
            for ( prop in orig ) {
                tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

                if ( !( prop in dataShow ) ) {
                    dataShow[ prop ] = tween.start;
                    if ( hidden ) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }

            // If this is a noop like .hide().hide(), restore an overwritten display value
        } else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
            style.display = display;
        }
    }

    function propFilter( props, specialEasing ) {
        var index, name, easing, value, hooks;

        // camelCase, specialEasing and expand cssHook pass
        for ( index in props ) {
            name = jQuery.camelCase( index );
            easing = specialEasing[ name ];
            value = props[ index ];
            if ( jQuery.isArray( value ) ) {
                easing = value[ 1 ];
                value = props[ index ] = value[ 0 ];
            }

            if ( index !== name ) {
                props[ name ] = value;
                delete props[ index ];
            }

            hooks = jQuery.cssHooks[ name ];
            if ( hooks && "expand" in hooks ) {
                value = hooks.expand( value );
                delete props[ name ];

                // not quite $.extend, this wont overwrite keys already present.
                // also - reusing 'index' from above because we have the correct "name"
                for ( index in value ) {
                    if ( !( index in props ) ) {
                        props[ index ] = value[ index ];
                        specialEasing[ index ] = easing;
                    }
                }
            } else {
                specialEasing[ name ] = easing;
            }
        }
    }

    function Animation( elem, properties, options ) {
        var result,
            stopped,
            index = 0,
            length = animationPrefilters.length,
            deferred = jQuery.Deferred().always( function() {
                // don't match elem in the :animated selector
                delete tick.elem;
            }),
            tick = function() {
                if ( stopped ) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(),
                    remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
                    // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
                    temp = remaining / animation.duration || 0,
                    percent = 1 - temp,
                    index = 0,
                    length = animation.tweens.length;

                for ( ; index < length ; index++ ) {
                    animation.tweens[ index ].run( percent );
                }

                deferred.notifyWith( elem, [ animation, percent, remaining ]);

                if ( percent < 1 && length ) {
                    return remaining;
                } else {
                    deferred.resolveWith( elem, [ animation ] );
                    return false;
                }
            },
            animation = deferred.promise({
                elem: elem,
                props: jQuery.extend( {}, properties ),
                opts: jQuery.extend( true, { specialEasing: {} }, options ),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function( prop, end ) {
                    var tween = jQuery.Tween( elem, animation.opts, prop, end,
                        animation.opts.specialEasing[ prop ] || animation.opts.easing );
                    animation.tweens.push( tween );
                    return tween;
                },
                stop: function( gotoEnd ) {
                    var index = 0,
                        // if we are going to the end, we want to run all the tweens
                        // otherwise we skip this part
                        length = gotoEnd ? animation.tweens.length : 0;
                    if ( stopped ) {
                        return this;
                    }
                    stopped = true;
                    for ( ; index < length ; index++ ) {
                        animation.tweens[ index ].run( 1 );
                    }

                    // resolve when we played the last frame
                    // otherwise, reject
                    if ( gotoEnd ) {
                        deferred.resolveWith( elem, [ animation, gotoEnd ] );
                    } else {
                        deferred.rejectWith( elem, [ animation, gotoEnd ] );
                    }
                    return this;
                }
            }),
            props = animation.props;

        propFilter( props, animation.opts.specialEasing );

        for ( ; index < length ; index++ ) {
            result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
            if ( result ) {
                return result;
            }
        }

        jQuery.map( props, createTween, animation );

        if ( jQuery.isFunction( animation.opts.start ) ) {
            animation.opts.start.call( elem, animation );
        }

        jQuery.fx.timer(
            jQuery.extend( tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            })
        );

        // attach callbacks from options
        return animation.progress( animation.opts.progress )
            .done( animation.opts.done, animation.opts.complete )
            .fail( animation.opts.fail )
            .always( animation.opts.always );
    }

    jQuery.Animation = jQuery.extend( Animation, {
        tweener: function( props, callback ) {
            if ( jQuery.isFunction( props ) ) {
                callback = props;
                props = [ "*" ];
            } else {
                props = props.split(" ");
            }

            var prop,
                index = 0,
                length = props.length;

            for ( ; index < length ; index++ ) {
                prop = props[ index ];
                tweeners[ prop ] = tweeners[ prop ] || [];
                tweeners[ prop ].unshift( callback );
            }
        },

        prefilter: function( callback, prepend ) {
            if ( prepend ) {
                animationPrefilters.unshift( callback );
            } else {
                animationPrefilters.push( callback );
            }
        }
    });

    jQuery.speed = function( speed, easing, fn ) {
        var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
            complete: fn || !fn && easing ||
                jQuery.isFunction( speed ) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
        };

        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
            opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

        // normalize opt.queue - true/undefined/null -> "fx"
        if ( opt.queue == null || opt.queue === true ) {
            opt.queue = "fx";
        }

        // Queueing
        opt.old = opt.complete;

        opt.complete = function() {
            if ( jQuery.isFunction( opt.old ) ) {
                opt.old.call( this );
            }

            if ( opt.queue ) {
                jQuery.dequeue( this, opt.queue );
            }
        };

        return opt;
    };

    jQuery.fn.extend({
        fadeTo: function( speed, to, easing, callback ) {

            // show any hidden elements after setting opacity to 0
            return this.filter( isHidden ).css( "opacity", 0 ).show()

                // animate to the value specified
                .end().animate({ opacity: to }, speed, easing, callback );
        },
        animate: function( prop, speed, easing, callback ) {
            var empty = jQuery.isEmptyObject( prop ),
                optall = jQuery.speed( speed, easing, callback ),
                doAnimation = function() {
                    // Operate on a copy of prop so per-property easing won't be lost
                    var anim = Animation( this, jQuery.extend( {}, prop ), optall );

                    // Empty animations, or finishing resolves immediately
                    if ( empty || jQuery._data( this, "finish" ) ) {
                        anim.stop( true );
                    }
                };
            doAnimation.finish = doAnimation;

            return empty || optall.queue === false ?
                this.each( doAnimation ) :
                this.queue( optall.queue, doAnimation );
        },
        stop: function( type, clearQueue, gotoEnd ) {
            var stopQueue = function( hooks ) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop( gotoEnd );
            };

            if ( typeof type !== "string" ) {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if ( clearQueue && type !== false ) {
                this.queue( type || "fx", [] );
            }

            return this.each(function() {
                var dequeue = true,
                    index = type != null && type + "queueHooks",
                    timers = jQuery.timers,
                    data = jQuery._data( this );

                if ( index ) {
                    if ( data[ index ] && data[ index ].stop ) {
                        stopQueue( data[ index ] );
                    }
                } else {
                    for ( index in data ) {
                        if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                            stopQueue( data[ index ] );
                        }
                    }
                }

                for ( index = timers.length; index--; ) {
                    if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
                        timers[ index ].anim.stop( gotoEnd );
                        dequeue = false;
                        timers.splice( index, 1 );
                    }
                }

                // start the next in the queue if the last step wasn't forced
                // timers currently will call their complete callbacks, which will dequeue
                // but only if they were gotoEnd
                if ( dequeue || !gotoEnd ) {
                    jQuery.dequeue( this, type );
                }
            });
        },
        finish: function( type ) {
            if ( type !== false ) {
                type = type || "fx";
            }
            return this.each(function() {
                var index,
                    data = jQuery._data( this ),
                    queue = data[ type + "queue" ],
                    hooks = data[ type + "queueHooks" ],
                    timers = jQuery.timers,
                    length = queue ? queue.length : 0;

                // enable finishing flag on private data
                data.finish = true;

                // empty the queue first
                jQuery.queue( this, type, [] );

                if ( hooks && hooks.stop ) {
                    hooks.stop.call( this, true );
                }

                // look for any active animations, and finish them
                for ( index = timers.length; index--; ) {
                    if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
                        timers[ index ].anim.stop( true );
                        timers.splice( index, 1 );
                    }
                }

                // look for any animations in the old queue and finish them
                for ( index = 0; index < length; index++ ) {
                    if ( queue[ index ] && queue[ index ].finish ) {
                        queue[ index ].finish.call( this );
                    }
                }

                // turn off finishing flag
                delete data.finish;
            });
        }
    });

    jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
        var cssFn = jQuery.fn[ name ];
        jQuery.fn[ name ] = function( speed, easing, callback ) {
            return speed == null || typeof speed === "boolean" ?
                cssFn.apply( this, arguments ) :
                this.animate( genFx( name, true ), speed, easing, callback );
        };
    });

// Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
    }, function( name, props ) {
        jQuery.fn[ name ] = function( speed, easing, callback ) {
            return this.animate( props, speed, easing, callback );
        };
    });

    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer,
            timers = jQuery.timers,
            i = 0;

        fxNow = jQuery.now();

        for ( ; i < timers.length; i++ ) {
            timer = timers[ i ];
            // Checks the timer has not already been removed
            if ( !timer() && timers[ i ] === timer ) {
                timers.splice( i--, 1 );
            }
        }

        if ( !timers.length ) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };

    jQuery.fx.timer = function( timer ) {
        jQuery.timers.push( timer );
        if ( timer() ) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };

    jQuery.fx.interval = 13;

    jQuery.fx.start = function() {
        if ( !timerId ) {
            timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
        }
    };

    jQuery.fx.stop = function() {
        clearInterval( timerId );
        timerId = null;
    };

    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
    };


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function( time, type ) {
        time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
        type = type || "fx";

        return this.queue( type, function( next, hooks ) {
            var timeout = setTimeout( next, time );
            hooks.stop = function() {
                clearTimeout( timeout );
            };
        });
    };


    (function() {
        // Minified: var a,b,c,d,e
        var input, div, select, a, opt;

        // Setup
        div = document.createElement( "div" );
        div.setAttribute( "className", "t" );
        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
        a = div.getElementsByTagName("a")[ 0 ];

        // First batch of tests.
        select = document.createElement("select");
        opt = select.appendChild( document.createElement("option") );
        input = div.getElementsByTagName("input")[ 0 ];

        a.style.cssText = "top:1px";

        // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
        support.getSetAttribute = div.className !== "t";

        // Get the style information from getAttribute
        // (IE uses .cssText instead)
        support.style = /top/.test( a.getAttribute("style") );

        // Make sure that URLs aren't manipulated
        // (IE normalizes it by default)
        support.hrefNormalized = a.getAttribute("href") === "/a";

        // Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
        support.checkOn = !!input.value;

        // Make sure that a selected-by-default option has a working selected property.
        // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
        support.optSelected = opt.selected;

        // Tests for enctype support on a form (#6743)
        support.enctype = !!document.createElement("form").enctype;

        // Make sure that the options inside disabled selects aren't marked as disabled
        // (WebKit marks them as disabled)
        select.disabled = true;
        support.optDisabled = !opt.disabled;

        // Support: IE8 only
        // Check if we can trust getAttribute("value")
        input = document.createElement( "input" );
        input.setAttribute( "value", "" );
        support.input = input.getAttribute( "value" ) === "";

        // Check if an input maintains its value after becoming a radio
        input.value = "t";
        input.setAttribute( "type", "radio" );
        support.radioValue = input.value === "t";
    })();


    var rreturn = /\r/g;

    jQuery.fn.extend({
        val: function( value ) {
            var hooks, ret, isFunction,
                elem = this[0];

            if ( !arguments.length ) {
                if ( elem ) {
                    hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                    if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
                        return ret;
                    }

                    ret = elem.value;

                    return typeof ret === "string" ?
                        // handle most common string cases
                        ret.replace(rreturn, "") :
                        // handle cases where value is null/undef or number
                        ret == null ? "" : ret;
                }

                return;
            }

            isFunction = jQuery.isFunction( value );

            return this.each(function( i ) {
                var val;

                if ( this.nodeType !== 1 ) {
                    return;
                }

                if ( isFunction ) {
                    val = value.call( this, i, jQuery( this ).val() );
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if ( val == null ) {
                    val = "";
                } else if ( typeof val === "number" ) {
                    val += "";
                } else if ( jQuery.isArray( val ) ) {
                    val = jQuery.map( val, function( value ) {
                        return value == null ? "" : value + "";
                    });
                }

                hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

                // If set returns undefined, fall back to normal setting
                if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function( elem ) {
                    var val = jQuery.find.attr( elem, "value" );
                    return val != null ?
                        val :
                        // Support: IE10-11+
                        // option.text throws exceptions (#14686, #14858)
                        jQuery.trim( jQuery.text( elem ) );
                }
            },
            select: {
                get: function( elem ) {
                    var value, option,
                        options = elem.options,
                        index = elem.selectedIndex,
                        one = elem.type === "select-one" || index < 0,
                        values = one ? null : [],
                        max = one ? index + 1 : options.length,
                        i = index < 0 ?
                            max :
                            one ? index : 0;

                    // Loop through all the selected options
                    for ( ; i < max; i++ ) {
                        option = options[ i ];

                        // oldIE doesn't update selected after form reset (#2551)
                        if ( ( option.selected || i === index ) &&
                            // Don't return options that are disabled or in a disabled optgroup
                            ( support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
                            ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

                            // Get the specific value for the option
                            value = jQuery( option ).val();

                            // We don't need an array for one selects
                            if ( one ) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push( value );
                        }
                    }

                    return values;
                },

                set: function( elem, value ) {
                    var optionSet, option,
                        options = elem.options,
                        values = jQuery.makeArray( value ),
                        i = options.length;

                    while ( i-- ) {
                        option = options[ i ];

                        if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {

                            // Support: IE6
                            // When new option element is added to select box we need to
                            // force reflow of newly added node in order to workaround delay
                            // of initialization properties
                            try {
                                option.selected = optionSet = true;

                            } catch ( _ ) {

                                // Will be executed only in IE6
                                option.scrollHeight;
                            }

                        } else {
                            option.selected = false;
                        }
                    }

                    // Force browsers to behave consistently when non-matching value is set
                    if ( !optionSet ) {
                        elem.selectedIndex = -1;
                    }

                    return options;
                }
            }
        }
    });

// Radios and checkboxes getter/setter
    jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[ this ] = {
            set: function( elem, value ) {
                if ( jQuery.isArray( value ) ) {
                    return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
                }
            }
        };
        if ( !support.checkOn ) {
            jQuery.valHooks[ this ].get = function( elem ) {
                // Support: Webkit
                // "" is returned instead of "on" if a value isn't specified
                return elem.getAttribute("value") === null ? "on" : elem.value;
            };
        }
    });




    var nodeHook, boolHook,
        attrHandle = jQuery.expr.attrHandle,
        ruseDefault = /^(?:checked|selected)$/i,
        getSetAttribute = support.getSetAttribute,
        getSetInput = support.input;

    jQuery.fn.extend({
        attr: function( name, value ) {
            return access( this, jQuery.attr, name, value, arguments.length > 1 );
        },

        removeAttr: function( name ) {
            return this.each(function() {
                jQuery.removeAttr( this, name );
            });
        }
    });

    jQuery.extend({
        attr: function( elem, name, value ) {
            var hooks, ret,
                nType = elem.nodeType;

            // don't get/set attributes on text, comment and attribute nodes
            if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                return;
            }

            // Fallback to prop when attributes are not supported
            if ( typeof elem.getAttribute === strundefined ) {
                return jQuery.prop( elem, name, value );
            }

            // All attributes are lowercase
            // Grab necessary hook if one is defined
            if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[ name ] ||
                    ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
            }

            if ( value !== undefined ) {

                if ( value === null ) {
                    jQuery.removeAttr( elem, name );

                } else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
                    return ret;

                } else {
                    elem.setAttribute( name, value + "" );
                    return value;
                }

            } else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
                return ret;

            } else {
                ret = jQuery.find.attr( elem, name );

                // Non-existent attributes return null, we normalize to undefined
                return ret == null ?
                    undefined :
                    ret;
            }
        },

        removeAttr: function( elem, value ) {
            var name, propName,
                i = 0,
                attrNames = value && value.match( rnotwhite );

            if ( attrNames && elem.nodeType === 1 ) {
                while ( (name = attrNames[i++]) ) {
                    propName = jQuery.propFix[ name ] || name;

                    // Boolean attributes get special treatment (#10870)
                    if ( jQuery.expr.match.bool.test( name ) ) {
                        // Set corresponding property to false
                        if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
                            elem[ propName ] = false;
                            // Support: IE<9
                            // Also clear defaultChecked/defaultSelected (if appropriate)
                        } else {
                            elem[ jQuery.camelCase( "default-" + name ) ] =
                                elem[ propName ] = false;
                        }

                        // See #9699 for explanation of this approach (setting first, then removal)
                    } else {
                        jQuery.attr( elem, name, "" );
                    }

                    elem.removeAttribute( getSetAttribute ? name : propName );
                }
            }
        },

        attrHooks: {
            type: {
                set: function( elem, value ) {
                    if ( !support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
                        // Setting the type on a radio button after the value resets the value in IE6-9
                        // Reset value to default in case type is set after value during creation
                        var val = elem.value;
                        elem.setAttribute( "type", value );
                        if ( val ) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        }
    });

// Hook for boolean attributes
    boolHook = {
        set: function( elem, value, name ) {
            if ( value === false ) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr( elem, name );
            } else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
                // IE<8 needs the *property* name
                elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

                // Use defaultChecked and defaultSelected for oldIE
            } else {
                elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
            }

            return name;
        }
    };

// Retrieve booleans specially
    jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {

        var getter = attrHandle[ name ] || jQuery.find.attr;

        attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
            function( elem, name, isXML ) {
                var ret, handle;
                if ( !isXML ) {
                    // Avoid an infinite loop by temporarily removing this function from the getter
                    handle = attrHandle[ name ];
                    attrHandle[ name ] = ret;
                    ret = getter( elem, name, isXML ) != null ?
                        name.toLowerCase() :
                        null;
                    attrHandle[ name ] = handle;
                }
                return ret;
            } :
            function( elem, name, isXML ) {
                if ( !isXML ) {
                    return elem[ jQuery.camelCase( "default-" + name ) ] ?
                        name.toLowerCase() :
                        null;
                }
            };
    });

// fix oldIE attroperties
    if ( !getSetInput || !getSetAttribute ) {
        jQuery.attrHooks.value = {
            set: function( elem, value, name ) {
                if ( jQuery.nodeName( elem, "input" ) ) {
                    // Does not return so that setAttribute is also used
                    elem.defaultValue = value;
                } else {
                    // Use nodeHook if defined (#1954); otherwise setAttribute is fine
                    return nodeHook && nodeHook.set( elem, value, name );
                }
            }
        };
    }

// IE6/7 do not support getting/setting some attributes with get/setAttribute
    if ( !getSetAttribute ) {

        // Use this for any attribute in IE6/7
        // This fixes almost every IE6/7 issue
        nodeHook = {
            set: function( elem, value, name ) {
                // Set the existing or create a new attribute node
                var ret = elem.getAttributeNode( name );
                if ( !ret ) {
                    elem.setAttributeNode(
                        (ret = elem.ownerDocument.createAttribute( name ))
                    );
                }

                ret.value = value += "";

                // Break association with cloned elements by also using setAttribute (#9646)
                if ( name === "value" || value === elem.getAttribute( name ) ) {
                    return value;
                }
            }
        };

        // Some attributes are constructed with empty-string values when not defined
        attrHandle.id = attrHandle.name = attrHandle.coords =
            function( elem, name, isXML ) {
                var ret;
                if ( !isXML ) {
                    return (ret = elem.getAttributeNode( name )) && ret.value !== "" ?
                        ret.value :
                        null;
                }
            };

        // Fixing value retrieval on a button requires this module
        jQuery.valHooks.button = {
            get: function( elem, name ) {
                var ret = elem.getAttributeNode( name );
                if ( ret && ret.specified ) {
                    return ret.value;
                }
            },
            set: nodeHook.set
        };

        // Set contenteditable to false on removals(#10429)
        // Setting to empty string throws an error as an invalid value
        jQuery.attrHooks.contenteditable = {
            set: function( elem, value, name ) {
                nodeHook.set( elem, value === "" ? false : value, name );
            }
        };

        // Set width and height to auto instead of 0 on empty string( Bug #8150 )
        // This is for removals
        jQuery.each([ "width", "height" ], function( i, name ) {
            jQuery.attrHooks[ name ] = {
                set: function( elem, value ) {
                    if ( value === "" ) {
                        elem.setAttribute( name, "auto" );
                        return value;
                    }
                }
            };
        });
    }

    if ( !support.style ) {
        jQuery.attrHooks.style = {
            get: function( elem ) {
                // Return undefined in the case of empty string
                // Note: IE uppercases css property names, but if we were to .toLowerCase()
                // .cssText, that would destroy case senstitivity in URL's, like in "background"
                return elem.style.cssText || undefined;
            },
            set: function( elem, value ) {
                return ( elem.style.cssText = value + "" );
            }
        };
    }




    var rfocusable = /^(?:input|select|textarea|button|object)$/i,
        rclickable = /^(?:a|area)$/i;

    jQuery.fn.extend({
        prop: function( name, value ) {
            return access( this, jQuery.prop, name, value, arguments.length > 1 );
        },

        removeProp: function( name ) {
            name = jQuery.propFix[ name ] || name;
            return this.each(function() {
                // try/catch handles cases where IE balks (such as removing a property on window)
                try {
                    this[ name ] = undefined;
                    delete this[ name ];
                } catch( e ) {}
            });
        }
    });

    jQuery.extend({
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },

        prop: function( elem, name, value ) {
            var ret, hooks, notxml,
                nType = elem.nodeType;

            // don't get/set properties on text, comment and attribute nodes
            if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                return;
            }

            notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

            if ( notxml ) {
                // Fix name and attach hooks
                name = jQuery.propFix[ name ] || name;
                hooks = jQuery.propHooks[ name ];
            }

            if ( value !== undefined ) {
                return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
                    ret :
                    ( elem[ name ] = value );

            } else {
                return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
                    ret :
                    elem[ name ];
            }
        },

        propHooks: {
            tabIndex: {
                get: function( elem ) {
                    // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    // Use proper attribute retrieval(#12072)
                    var tabindex = jQuery.find.attr( elem, "tabindex" );

                    return tabindex ?
                        parseInt( tabindex, 10 ) :
                        rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
                            0 :
                            -1;
                }
            }
        }
    });

// Some attributes require a special call on IE
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
    if ( !support.hrefNormalized ) {
        // href/src property should get the full normalized URL (#10299/#12915)
        jQuery.each([ "href", "src" ], function( i, name ) {
            jQuery.propHooks[ name ] = {
                get: function( elem ) {
                    return elem.getAttribute( name, 4 );
                }
            };
        });
    }

// Support: Safari, IE9+
// mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
    if ( !support.optSelected ) {
        jQuery.propHooks.selected = {
            get: function( elem ) {
                var parent = elem.parentNode;

                if ( parent ) {
                    parent.selectedIndex;

                    // Make sure that it also works with optgroups, see #5701
                    if ( parent.parentNode ) {
                        parent.parentNode.selectedIndex;
                    }
                }
                return null;
            }
        };
    }

    jQuery.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
    ], function() {
        jQuery.propFix[ this.toLowerCase() ] = this;
    });

// IE6/7 call enctype encoding
    if ( !support.enctype ) {
        jQuery.propFix.enctype = "encoding";
    }




    var rclass = /[\t\r\n\f]/g;

    jQuery.fn.extend({
        addClass: function( value ) {
            var classes, elem, cur, clazz, j, finalValue,
                i = 0,
                len = this.length,
                proceed = typeof value === "string" && value;

            if ( jQuery.isFunction( value ) ) {
                return this.each(function( j ) {
                    jQuery( this ).addClass( value.call( this, j, this.className ) );
                });
            }

            if ( proceed ) {
                // The disjunction here is for better compressibility (see removeClass)
                classes = ( value || "" ).match( rnotwhite ) || [];

                for ( ; i < len; i++ ) {
                    elem = this[ i ];
                    cur = elem.nodeType === 1 && ( elem.className ?
                            ( " " + elem.className + " " ).replace( rclass, " " ) :
                            " "
                    );

                    if ( cur ) {
                        j = 0;
                        while ( (clazz = classes[j++]) ) {
                            if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                                cur += clazz + " ";
                            }
                        }

                        // only assign if different to avoid unneeded rendering.
                        finalValue = jQuery.trim( cur );
                        if ( elem.className !== finalValue ) {
                            elem.className = finalValue;
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function( value ) {
            var classes, elem, cur, clazz, j, finalValue,
                i = 0,
                len = this.length,
                proceed = arguments.length === 0 || typeof value === "string" && value;

            if ( jQuery.isFunction( value ) ) {
                return this.each(function( j ) {
                    jQuery( this ).removeClass( value.call( this, j, this.className ) );
                });
            }
            if ( proceed ) {
                classes = ( value || "" ).match( rnotwhite ) || [];

                for ( ; i < len; i++ ) {
                    elem = this[ i ];
                    // This expression is here for better compressibility (see addClass)
                    cur = elem.nodeType === 1 && ( elem.className ?
                            ( " " + elem.className + " " ).replace( rclass, " " ) :
                            ""
                    );

                    if ( cur ) {
                        j = 0;
                        while ( (clazz = classes[j++]) ) {
                            // Remove *all* instances
                            while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
                                cur = cur.replace( " " + clazz + " ", " " );
                            }
                        }

                        // only assign if different to avoid unneeded rendering.
                        finalValue = value ? jQuery.trim( cur ) : "";
                        if ( elem.className !== finalValue ) {
                            elem.className = finalValue;
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function( value, stateVal ) {
            var type = typeof value;

            if ( typeof stateVal === "boolean" && type === "string" ) {
                return stateVal ? this.addClass( value ) : this.removeClass( value );
            }

            if ( jQuery.isFunction( value ) ) {
                return this.each(function( i ) {
                    jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
                });
            }

            return this.each(function() {
                if ( type === "string" ) {
                    // toggle individual class names
                    var className,
                        i = 0,
                        self = jQuery( this ),
                        classNames = value.match( rnotwhite ) || [];

                    while ( (className = classNames[ i++ ]) ) {
                        // check each className given, space separated list
                        if ( self.hasClass( className ) ) {
                            self.removeClass( className );
                        } else {
                            self.addClass( className );
                        }
                    }

                    // Toggle whole class name
                } else if ( type === strundefined || type === "boolean" ) {
                    if ( this.className ) {
                        // store className if set
                        jQuery._data( this, "__className__", this.className );
                    }

                    // If the element has a class name or if we're passed "false",
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
                }
            });
        },

        hasClass: function( selector ) {
            var className = " " + selector + " ",
                i = 0,
                l = this.length;
            for ( ; i < l; i++ ) {
                if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
                    return true;
                }
            }

            return false;
        }
    });




// Return jQuery for attributes-only inclusion


    jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

        // Handle event binding
        jQuery.fn[ name ] = function( data, fn ) {
            return arguments.length > 0 ?
                this.on( name, null, data, fn ) :
                this.trigger( name );
        };
    });

    jQuery.fn.extend({
        hover: function( fnOver, fnOut ) {
            return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
        },

        bind: function( types, data, fn ) {
            return this.on( types, null, data, fn );
        },
        unbind: function( types, fn ) {
            return this.off( types, null, fn );
        },

        delegate: function( selector, types, data, fn ) {
            return this.on( types, selector, data, fn );
        },
        undelegate: function( selector, types, fn ) {
            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
        }
    });


    var nonce = jQuery.now();

    var rquery = (/\?/);



    var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

    jQuery.parseJSON = function( data ) {
        // Attempt to parse using the native JSON parser first
        if ( window.JSON && window.JSON.parse ) {
            // Support: Android 2.3
            // Workaround failure to string-cast null input
            return window.JSON.parse( data + "" );
        }

        var requireNonComma,
            depth = null,
            str = jQuery.trim( data + "" );

        // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
        // after removing valid tokens
        return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {

            // Force termination if we see a misplaced comma
            if ( requireNonComma && comma ) {
                depth = 0;
            }

            // Perform no more replacements after returning to outermost depth
            if ( depth === 0 ) {
                return token;
            }

            // Commas must not follow "[", "{", or ","
            requireNonComma = open || comma;

            // Determine new depth
            // array/object open ("[" or "{"): depth += true - false (increment)
            // array/object close ("]" or "}"): depth += false - true (decrement)
            // other cases ("," or primitive): depth += true - true (numeric cast)
            depth += !close - !open;

            // Remove this token
            return "";
        }) ) ?
            ( Function( "return " + str ) )() :
            jQuery.error( "Invalid JSON: " + data );
    };


// Cross-browser xml parsing
    jQuery.parseXML = function( data ) {
        var xml, tmp;
        if ( !data || typeof data !== "string" ) {
            return null;
        }
        try {
            if ( window.DOMParser ) { // Standard
                tmp = new DOMParser();
                xml = tmp.parseFromString( data, "text/xml" );
            } else { // IE
                xml = new ActiveXObject( "Microsoft.XMLDOM" );
                xml.async = "false";
                xml.loadXML( data );
            }
        } catch( e ) {
            xml = undefined;
        }
        if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
            jQuery.error( "Invalid XML: " + data );
        }
        return xml;
    };


    var
        // Document location
        ajaxLocParts,
        ajaxLocation,

        rhash = /#.*$/,
        rts = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
        // #7653, #8125, #8152: local protocol detection
        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
        rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

        /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
        prefilters = {},

        /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
        transports = {},

        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
        allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch( e ) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement( "a" );
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }

// Segment location into parts
    ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports( structure ) {

        // dataTypeExpression is optional and defaults to "*"
        return function( dataTypeExpression, func ) {

            if ( typeof dataTypeExpression !== "string" ) {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType,
                i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

            if ( jQuery.isFunction( func ) ) {
                // For each dataType in the dataTypeExpression
                while ( (dataType = dataTypes[i++]) ) {
                    // Prepend if requested
                    if ( dataType.charAt( 0 ) === "+" ) {
                        dataType = dataType.slice( 1 ) || "*";
                        (structure[ dataType ] = structure[ dataType ] || []).unshift( func );

                        // Otherwise append
                    } else {
                        (structure[ dataType ] = structure[ dataType ] || []).push( func );
                    }
                }
            }
        };
    }

// Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

        var inspected = {},
            seekingTransport = ( structure === transports );

        function inspect( dataType ) {
            var selected;
            inspected[ dataType ] = true;
            jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
                var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
                if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
                    options.dataTypes.unshift( dataTypeOrTransport );
                    inspect( dataTypeOrTransport );
                    return false;
                } else if ( seekingTransport ) {
                    return !( selected = dataTypeOrTransport );
                }
            });
            return selected;
        }

        return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
    }

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
    function ajaxExtend( target, src ) {
        var deep, key,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};

        for ( key in src ) {
            if ( src[ key ] !== undefined ) {
                ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
            }
        }
        if ( deep ) {
            jQuery.extend( true, target, deep );
        }

        return target;
    }

    /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
    function ajaxHandleResponses( s, jqXHR, responses ) {
        var firstDataType, ct, finalDataType, type,
            contents = s.contents,
            dataTypes = s.dataTypes;

        // Remove auto dataType and get content-type in the process
        while ( dataTypes[ 0 ] === "*" ) {
            dataTypes.shift();
            if ( ct === undefined ) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }

        // Check if we're dealing with a known content-type
        if ( ct ) {
            for ( type in contents ) {
                if ( contents[ type ] && contents[ type ].test( ct ) ) {
                    dataTypes.unshift( type );
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if ( dataTypes[ 0 ] in responses ) {
            finalDataType = dataTypes[ 0 ];
        } else {
            // Try convertible dataTypes
            for ( type in responses ) {
                if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
                    finalDataType = type;
                    break;
                }
                if ( !firstDataType ) {
                    firstDataType = type;
                }
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if ( finalDataType ) {
            if ( finalDataType !== dataTypes[ 0 ] ) {
                dataTypes.unshift( finalDataType );
            }
            return responses[ finalDataType ];
        }
    }

    /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
    function ajaxConvert( s, response, jqXHR, isSuccess ) {
        var conv2, current, conv, tmp, prev,
            converters = {},
            // Work with a copy of dataTypes in case we need to modify it for conversion
            dataTypes = s.dataTypes.slice();

        // Create converters map with lowercased keys
        if ( dataTypes[ 1 ] ) {
            for ( conv in s.converters ) {
                converters[ conv.toLowerCase() ] = s.converters[ conv ];
            }
        }

        current = dataTypes.shift();

        // Convert to each sequential dataType
        while ( current ) {

            if ( s.responseFields[ current ] ) {
                jqXHR[ s.responseFields[ current ] ] = response;
            }

            // Apply the dataFilter if provided
            if ( !prev && isSuccess && s.dataFilter ) {
                response = s.dataFilter( response, s.dataType );
            }

            prev = current;
            current = dataTypes.shift();

            if ( current ) {

                // There's only work to do if current dataType is non-auto
                if ( current === "*" ) {

                    current = prev;

                    // Convert response if prev dataType is non-auto and differs from current
                } else if ( prev !== "*" && prev !== current ) {

                    // Seek a direct converter
                    conv = converters[ prev + " " + current ] || converters[ "* " + current ];

                    // If none found, seek a pair
                    if ( !conv ) {
                        for ( conv2 in converters ) {

                            // If conv2 outputs current
                            tmp = conv2.split( " " );
                            if ( tmp[ 1 ] === current ) {

                                // If prev can be converted to accepted input
                                conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                    converters[ "* " + tmp[ 0 ] ];
                                if ( conv ) {
                                    // Condense equivalence converters
                                    if ( conv === true ) {
                                        conv = converters[ conv2 ];

                                        // Otherwise, insert the intermediate dataType
                                    } else if ( converters[ conv2 ] !== true ) {
                                        current = tmp[ 0 ];
                                        dataTypes.unshift( tmp[ 1 ] );
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    // Apply converter (if not an equivalence)
                    if ( conv !== true ) {

                        // Unless errors are allowed to bubble, catch and return them
                        if ( conv && s[ "throws" ] ) {
                            response = conv( response );
                        } else {
                            try {
                                response = conv( response );
                            } catch ( e ) {
                                return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
                            }
                        }
                    }
                }
            }
        }

        return { state: "success", data: response };
    }

    jQuery.extend({

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},

        ajaxSettings: {
            url: ajaxLocation,
            type: "GET",
            isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },

            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },

            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {

                // Convert anything to text
                "* text": String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,

                // Parse text as xml
                "text xml": jQuery.parseXML
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function( target, settings ) {
            return settings ?

                // Building a settings object
                ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

                // Extending ajaxSettings
                ajaxExtend( jQuery.ajaxSettings, target );
        },

        ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
        ajaxTransport: addToPrefiltersOrTransports( transports ),

        // Main method
        ajax: function( url, options ) {

            // If url is an object, simulate pre-1.5 signature
            if ( typeof url === "object" ) {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var // Cross-domain detection vars
                parts,
                // Loop variable
                i,
                // URL without anti-cache param
                cacheURL,
                // Response headers as string
                responseHeadersString,
                // timeout handle
                timeoutTimer,

                // To know if global events are to be dispatched
                fireGlobals,

                transport,
                // Response headers
                responseHeaders,
                // Create the final options object
                s = jQuery.ajaxSetup( {}, options ),
                // Callbacks context
                callbackContext = s.context || s,
                // Context for global events is callbackContext if it is a DOM node or jQuery collection
                globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
                    jQuery( callbackContext ) :
                    jQuery.event,
                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks("once memory"),
                // Status-dependent callbacks
                statusCode = s.statusCode || {},
                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},
                // The jqXHR state
                state = 0,
                // Default abort message
                strAbort = "canceled",
                // Fake xhr
                jqXHR = {
                    readyState: 0,

                    // Builds headers hashtable if needed
                    getResponseHeader: function( key ) {
                        var match;
                        if ( state === 2 ) {
                            if ( !responseHeaders ) {
                                responseHeaders = {};
                                while ( (match = rheaders.exec( responseHeadersString )) ) {
                                    responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                                }
                            }
                            match = responseHeaders[ key.toLowerCase() ];
                        }
                        return match == null ? null : match;
                    },

                    // Raw string
                    getAllResponseHeaders: function() {
                        return state === 2 ? responseHeadersString : null;
                    },

                    // Caches the header
                    setRequestHeader: function( name, value ) {
                        var lname = name.toLowerCase();
                        if ( !state ) {
                            name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                            requestHeaders[ name ] = value;
                        }
                        return this;
                    },

                    // Overrides response content-type header
                    overrideMimeType: function( type ) {
                        if ( !state ) {
                            s.mimeType = type;
                        }
                        return this;
                    },

                    // Status-dependent callbacks
                    statusCode: function( map ) {
                        var code;
                        if ( map ) {
                            if ( state < 2 ) {
                                for ( code in map ) {
                                    // Lazy-add the new callback in a way that preserves old ones
                                    statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                                }
                            } else {
                                // Execute the appropriate callbacks
                                jqXHR.always( map[ jqXHR.status ] );
                            }
                        }
                        return this;
                    },

                    // Cancel the request
                    abort: function( statusText ) {
                        var finalText = statusText || strAbort;
                        if ( transport ) {
                            transport.abort( finalText );
                        }
                        done( 0, finalText );
                        return this;
                    }
                };

            // Attach deferreds
            deferred.promise( jqXHR ).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;

            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;

            // Extract dataTypes list
            s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

            // A cross-domain request is in order when we have a protocol:host:port mismatch
            if ( s.crossDomain == null ) {
                parts = rurl.exec( s.url.toLowerCase() );
                s.crossDomain = !!( parts &&
                    ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                        ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
                        ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
                );
            }

            // Convert data if not already a string
            if ( s.data && s.processData && typeof s.data !== "string" ) {
                s.data = jQuery.param( s.data, s.traditional );
            }

            // Apply prefilters
            inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

            // If request was aborted inside a prefilter, stop there
            if ( state === 2 ) {
                return jqXHR;
            }

            // We can fire global events as of now if asked to
            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
            fireGlobals = jQuery.event && s.global;

            // Watch for a new set of requests
            if ( fireGlobals && jQuery.active++ === 0 ) {
                jQuery.event.trigger("ajaxStart");
            }

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test( s.type );

            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            cacheURL = s.url;

            // More options handling for requests with no content
            if ( !s.hasContent ) {

                // If data is available, append data to url
                if ( s.data ) {
                    cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Add anti-cache in url if needed
                if ( s.cache === false ) {
                    s.url = rts.test( cacheURL ) ?

                        // If there is already a '_' parameter, set its value
                        cacheURL.replace( rts, "$1_=" + nonce++ ) :

                        // Otherwise add one to the end
                        cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
                }
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if ( s.ifModified ) {
                if ( jQuery.lastModified[ cacheURL ] ) {
                    jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
                }
                if ( jQuery.etag[ cacheURL ] ) {
                    jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
                }
            }

            // Set the correct header, if data is being sent
            if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
                jqXHR.setRequestHeader( "Content-Type", s.contentType );
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
                "Accept",
                s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
                    s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                    s.accepts[ "*" ]
            );

            // Check for headers option
            for ( i in s.headers ) {
                jqXHR.setRequestHeader( i, s.headers[ i ] );
            }

            // Allow custom headers/mimetypes and early abort
            if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
                // Abort if not done already and return
                return jqXHR.abort();
            }

            // aborting is no longer a cancellation
            strAbort = "abort";

            // Install callbacks on deferreds
            for ( i in { success: 1, error: 1, complete: 1 } ) {
                jqXHR[ i ]( s[ i ] );
            }

            // Get transport
            transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

            // If no transport, we auto-abort
            if ( !transport ) {
                done( -1, "No Transport" );
            } else {
                jqXHR.readyState = 1;

                // Send global event
                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
                }
                // Timeout
                if ( s.async && s.timeout > 0 ) {
                    timeoutTimer = setTimeout(function() {
                        jqXHR.abort("timeout");
                    }, s.timeout );
                }

                try {
                    state = 1;
                    transport.send( requestHeaders, done );
                } catch ( e ) {
                    // Propagate exception as error if not done
                    if ( state < 2 ) {
                        done( -1, e );
                        // Simply rethrow otherwise
                    } else {
                        throw e;
                    }
                }
            }

            // Callback for when everything is done
            function done( status, nativeStatusText, responses, headers ) {
                var isSuccess, success, error, response, modified,
                    statusText = nativeStatusText;

                // Called once
                if ( state === 2 ) {
                    return;
                }

                // State is "done" now
                state = 2;

                // Clear timeout if it exists
                if ( timeoutTimer ) {
                    clearTimeout( timeoutTimer );
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;

                // Get response data
                if ( responses ) {
                    response = ajaxHandleResponses( s, jqXHR, responses );
                }

                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert( s, response, jqXHR, isSuccess );

                // If successful, handle type chaining
                if ( isSuccess ) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if ( s.ifModified ) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if ( modified ) {
                            jQuery.lastModified[ cacheURL ] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if ( modified ) {
                            jQuery.etag[ cacheURL ] = modified;
                        }
                    }

                    // if no content
                    if ( status === 204 || s.type === "HEAD" ) {
                        statusText = "nocontent";

                        // if not modified
                    } else if ( status === 304 ) {
                        statusText = "notmodified";

                        // If we have data, let's convert it
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    // We extract error from statusText
                    // then normalize statusText and status for non-aborts
                    error = statusText;
                    if ( status || !statusText ) {
                        statusText = "error";
                        if ( status < 0 ) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = ( nativeStatusText || statusText ) + "";

                // Success/Error
                if ( isSuccess ) {
                    deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                } else {
                    deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                }

                // Status-dependent callbacks
                jqXHR.statusCode( statusCode );
                statusCode = undefined;

                if ( fireGlobals ) {
                    globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
                        [ jqXHR, s, isSuccess ? success : error ] );
                }

                // Complete
                completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

                if ( fireGlobals ) {
                    globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
                    // Handle the global AJAX counter
                    if ( !( --jQuery.active ) ) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }

            return jqXHR;
        },

        getJSON: function( url, data, callback ) {
            return jQuery.get( url, data, callback, "json" );
        },

        getScript: function( url, callback ) {
            return jQuery.get( url, undefined, callback, "script" );
        }
    });

    jQuery.each( [ "get", "post" ], function( i, method ) {
        jQuery[ method ] = function( url, data, callback, type ) {
            // shift arguments if data argument was omitted
            if ( jQuery.isFunction( data ) ) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            return jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    });


    jQuery._evalUrl = function( url ) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            "throws": true
        });
    };


    jQuery.fn.extend({
        wrapAll: function( html ) {
            if ( jQuery.isFunction( html ) ) {
                return this.each(function(i) {
                    jQuery(this).wrapAll( html.call(this, i) );
                });
            }

            if ( this[0] ) {
                // The elements to wrap the target around
                var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

                if ( this[0].parentNode ) {
                    wrap.insertBefore( this[0] );
                }

                wrap.map(function() {
                    var elem = this;

                    while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
                        elem = elem.firstChild;
                    }

                    return elem;
                }).append( this );
            }

            return this;
        },

        wrapInner: function( html ) {
            if ( jQuery.isFunction( html ) ) {
                return this.each(function(i) {
                    jQuery(this).wrapInner( html.call(this, i) );
                });
            }

            return this.each(function() {
                var self = jQuery( this ),
                    contents = self.contents();

                if ( contents.length ) {
                    contents.wrapAll( html );

                } else {
                    self.append( html );
                }
            });
        },

        wrap: function( html ) {
            var isFunction = jQuery.isFunction( html );

            return this.each(function(i) {
                jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
            });
        },

        unwrap: function() {
            return this.parent().each(function() {
                if ( !jQuery.nodeName( this, "body" ) ) {
                    jQuery( this ).replaceWith( this.childNodes );
                }
            }).end();
        }
    });


    jQuery.expr.filters.hidden = function( elem ) {
        // Support: Opera <= 12.12
        // Opera reports offsetWidths and offsetHeights less than zero on some elements
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
            (!support.reliableHiddenOffsets() &&
                ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
    };

    jQuery.expr.filters.visible = function( elem ) {
        return !jQuery.expr.filters.hidden( elem );
    };




    var r20 = /%20/g,
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams( prefix, obj, traditional, add ) {
        var name;

        if ( jQuery.isArray( obj ) ) {
            // Serialize array item.
            jQuery.each( obj, function( i, v ) {
                if ( traditional || rbracket.test( prefix ) ) {
                    // Treat each array item as a scalar.
                    add( prefix, v );

                } else {
                    // Item is non-scalar (array or object), encode its numeric index.
                    buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
                }
            });

        } else if ( !traditional && jQuery.type( obj ) === "object" ) {
            // Serialize object item.
            for ( name in obj ) {
                buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
            }

        } else {
            // Serialize scalar item.
            add( prefix, obj );
        }
    }

// Serialize an array of form elements or a set of
// key/values into a query string
    jQuery.param = function( a, traditional ) {
        var prefix,
            s = [],
            add = function( key, value ) {
                // If value is a function, invoke it and return its value
                value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
                s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
            };

        // Set traditional to true for jQuery <= 1.3.2 behavior.
        if ( traditional === undefined ) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }

        // If an array was passed in, assume that it is an array of form elements.
        if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
            // Serialize the form elements
            jQuery.each( a, function() {
                add( this.name, this.value );
            });

        } else {
            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for ( prefix in a ) {
                buildParams( prefix, a[ prefix ], traditional, add );
            }
        }

        // Return the resulting serialization
        return s.join( "&" ).replace( r20, "+" );
    };

    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param( this.serializeArray() );
        },
        serializeArray: function() {
            return this.map(function() {
                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop( this, "elements" );
                return elements ? jQuery.makeArray( elements ) : this;
            })
                .filter(function() {
                    var type = this.type;
                    // Use .is(":disabled") so that fieldset[disabled] works
                    return this.name && !jQuery( this ).is( ":disabled" ) &&
                        rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
                        ( this.checked || !rcheckableType.test( type ) );
                })
                .map(function( i, elem ) {
                    var val = jQuery( this ).val();

                    return val == null ?
                        null :
                        jQuery.isArray( val ) ?
                            jQuery.map( val, function( val ) {
                                return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                            }) :
                            { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                }).get();
        }
    });


// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
    jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?
        // Support: IE6+
        function() {

            // XHR cannot access local files, always use ActiveX for that case
            return !this.isLocal &&

                // Support: IE7-8
                // oldIE XHR does not support non-RFC2616 methods (#13240)
                // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
                // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
                // Although this check for six methods instead of eight
                // since IE also does not support "trace" and "connect"
                /^(get|post|head|put|delete|options)$/i.test( this.type ) &&

                createStandardXHR() || createActiveXHR();
        } :
        // For all other browsers, use the standard XMLHttpRequest object
        createStandardXHR;

    var xhrId = 0,
        xhrCallbacks = {},
        xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE<10
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
    if ( window.attachEvent ) {
        window.attachEvent( "onunload", function() {
            for ( var key in xhrCallbacks ) {
                xhrCallbacks[ key ]( undefined, true );
            }
        });
    }

// Determine support properties
    support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
    xhrSupported = support.ajax = !!xhrSupported;

// Create transport if the browser can provide an xhr
    if ( xhrSupported ) {

        jQuery.ajaxTransport(function( options ) {
            // Cross domain only allowed if supported through XMLHttpRequest
            if ( !options.crossDomain || support.cors ) {

                var callback;

                return {
                    send: function( headers, complete ) {
                        var i,
                            xhr = options.xhr(),
                            id = ++xhrId;

                        // Open the socket
                        xhr.open( options.type, options.url, options.async, options.username, options.password );

                        // Apply custom fields if provided
                        if ( options.xhrFields ) {
                            for ( i in options.xhrFields ) {
                                xhr[ i ] = options.xhrFields[ i ];
                            }
                        }

                        // Override mime type if needed
                        if ( options.mimeType && xhr.overrideMimeType ) {
                            xhr.overrideMimeType( options.mimeType );
                        }

                        // X-Requested-With header
                        // For cross-domain requests, seeing as conditions for a preflight are
                        // akin to a jigsaw puzzle, we simply never set it to be sure.
                        // (it can always be set on a per-request basis or even using ajaxSetup)
                        // For same-domain requests, won't change header if already provided.
                        if ( !options.crossDomain && !headers["X-Requested-With"] ) {
                            headers["X-Requested-With"] = "XMLHttpRequest";
                        }

                        // Set headers
                        for ( i in headers ) {
                            // Support: IE<9
                            // IE's ActiveXObject throws a 'Type Mismatch' exception when setting
                            // request header to a null-value.
                            //
                            // To keep consistent with other XHR implementations, cast the value
                            // to string and ignore `undefined`.
                            if ( headers[ i ] !== undefined ) {
                                xhr.setRequestHeader( i, headers[ i ] + "" );
                            }
                        }

                        // Do send the request
                        // This may raise an exception which is actually
                        // handled in jQuery.ajax (so no try/catch here)
                        xhr.send( ( options.hasContent && options.data ) || null );

                        // Listener
                        callback = function( _, isAbort ) {
                            var status, statusText, responses;

                            // Was never called and is aborted or complete
                            if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
                                // Clean up
                                delete xhrCallbacks[ id ];
                                callback = undefined;
                                xhr.onreadystatechange = jQuery.noop;

                                // Abort manually if needed
                                if ( isAbort ) {
                                    if ( xhr.readyState !== 4 ) {
                                        xhr.abort();
                                    }
                                } else {
                                    responses = {};
                                    status = xhr.status;

                                    // Support: IE<10
                                    // Accessing binary-data responseText throws an exception
                                    // (#11426)
                                    if ( typeof xhr.responseText === "string" ) {
                                        responses.text = xhr.responseText;
                                    }

                                    // Firefox throws an exception when accessing
                                    // statusText for faulty cross-domain requests
                                    try {
                                        statusText = xhr.statusText;
                                    } catch( e ) {
                                        // We normalize with Webkit giving an empty statusText
                                        statusText = "";
                                    }

                                    // Filter status for non standard behaviors

                                    // If the request is local and we have data: assume a success
                                    // (success with no data won't get notified, that's the best we
                                    // can do given current implementations)
                                    if ( !status && options.isLocal && !options.crossDomain ) {
                                        status = responses.text ? 200 : 404;
                                        // IE - #1450: sometimes returns 1223 when it should be 204
                                    } else if ( status === 1223 ) {
                                        status = 204;
                                    }
                                }
                            }

                            // Call complete if needed
                            if ( responses ) {
                                complete( status, statusText, responses, xhr.getAllResponseHeaders() );
                            }
                        };

                        if ( !options.async ) {
                            // if we're in sync mode we fire the callback
                            callback();
                        } else if ( xhr.readyState === 4 ) {
                            // (IE6 & IE7) if it's in cache and has been
                            // retrieved directly we need to fire the callback
                            setTimeout( callback );
                        } else {
                            // Add to the list of active xhr callbacks
                            xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
                        }
                    },

                    abort: function() {
                        if ( callback ) {
                            callback( undefined, true );
                        }
                    }
                };
            }
        });
    }

// Functions to create xhrs
    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch( e ) {}
    }

    function createActiveXHR() {
        try {
            return new window.ActiveXObject( "Microsoft.XMLHTTP" );
        } catch( e ) {}
    }




// Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function( text ) {
                jQuery.globalEval( text );
                return text;
            }
        }
    });

// Handle cache's special case and global
    jQuery.ajaxPrefilter( "script", function( s ) {
        if ( s.cache === undefined ) {
            s.cache = false;
        }
        if ( s.crossDomain ) {
            s.type = "GET";
            s.global = false;
        }
    });

// Bind script tag hack transport
    jQuery.ajaxTransport( "script", function(s) {

        // This transport only deals with cross domain requests
        if ( s.crossDomain ) {

            var script,
                head = document.head || jQuery("head")[0] || document.documentElement;

            return {

                send: function( _, callback ) {

                    script = document.createElement("script");

                    script.async = true;

                    if ( s.scriptCharset ) {
                        script.charset = s.scriptCharset;
                    }

                    script.src = s.url;

                    // Attach handlers for all browsers
                    script.onload = script.onreadystatechange = function( _, isAbort ) {

                        if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

                            // Handle memory leak in IE
                            script.onload = script.onreadystatechange = null;

                            // Remove the script
                            if ( script.parentNode ) {
                                script.parentNode.removeChild( script );
                            }

                            // Dereference the script
                            script = null;

                            // Callback if not abort
                            if ( !isAbort ) {
                                callback( 200, "success" );
                            }
                        }
                    };

                    // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
                    // Use native DOM manipulation to avoid our domManip AJAX trickery
                    head.insertBefore( script, head.firstChild );
                },

                abort: function() {
                    if ( script ) {
                        script.onload( undefined, true );
                    }
                }
            };
        }
    });




    var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
            this[ callback ] = true;
            return callback;
        }
    });

// Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

        var callbackName, overwritten, responseContainer,
            jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
                    "url" :
                    typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
            );

        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
                s.jsonpCallback() :
                s.jsonpCallback;

            // Insert callback into url or form data
            if ( jsonProp ) {
                s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
            } else if ( s.jsonp !== false ) {
                s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
            }

            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function() {
                if ( !responseContainer ) {
                    jQuery.error( callbackName + " was not called" );
                }
                return responseContainer[ 0 ];
            };

            // force json dataType
            s.dataTypes[ 0 ] = "json";

            // Install callback
            overwritten = window[ callbackName ];
            window[ callbackName ] = function() {
                responseContainer = arguments;
            };

            // Clean-up function (fires after converters)
            jqXHR.always(function() {
                // Restore preexisting value
                window[ callbackName ] = overwritten;

                // Save back as free
                if ( s[ callbackName ] ) {
                    // make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;

                    // save the callback name for future use
                    oldCallbacks.push( callbackName );
                }

                // Call if it was a function and we have a response
                if ( responseContainer && jQuery.isFunction( overwritten ) ) {
                    overwritten( responseContainer[ 0 ] );
                }

                responseContainer = overwritten = undefined;
            });

            // Delegate to script
            return "script";
        }
    });




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function( data, context, keepScripts ) {
        if ( !data || typeof data !== "string" ) {
            return null;
        }
        if ( typeof context === "boolean" ) {
            keepScripts = context;
            context = false;
        }
        context = context || document;

        var parsed = rsingleTag.exec( data ),
            scripts = !keepScripts && [];

        // Single tag
        if ( parsed ) {
            return [ context.createElement( parsed[1] ) ];
        }

        parsed = jQuery.buildFragment( [ data ], context, scripts );

        if ( scripts && scripts.length ) {
            jQuery( scripts ).remove();
        }

        return jQuery.merge( [], parsed.childNodes );
    };


// Keep a copy of the old load method
    var _load = jQuery.fn.load;

    /**
     * Load a url into a page
     */
    jQuery.fn.load = function( url, params, callback ) {
        if ( typeof url !== "string" && _load ) {
            return _load.apply( this, arguments );
        }

        var selector, response, type,
            self = this,
            off = url.indexOf(" ");

        if ( off >= 0 ) {
            selector = jQuery.trim( url.slice( off, url.length ) );
            url = url.slice( 0, off );
        }

        // If it's a function
        if ( jQuery.isFunction( params ) ) {

            // We assume that it's the callback
            callback = params;
            params = undefined;

            // Otherwise, build a param string
        } else if ( params && typeof params === "object" ) {
            type = "POST";
        }

        // If we have elements to modify, make the request
        if ( self.length > 0 ) {
            jQuery.ajax({
                url: url,

                // if "type" variable is undefined, then "GET" method will be used
                type: type,
                dataType: "html",
                data: params
            }).done(function( responseText ) {

                // Save response for use in complete callback
                response = arguments;

                self.html( selector ?

                    // If a selector was specified, locate the right elements in a dummy div
                    // Exclude scripts to avoid IE 'Permission Denied' errors
                    jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

                    // Otherwise use the full result
                    responseText );

            }).complete( callback && function( jqXHR, status ) {
                self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
            });
        }

        return this;
    };




// Attach a bunch of functions for handling common AJAX events
    jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
        jQuery.fn[ type ] = function( fn ) {
            return this.on( type, fn );
        };
    });




    jQuery.expr.filters.animated = function( elem ) {
        return jQuery.grep(jQuery.timers, function( fn ) {
            return elem === fn.elem;
        }).length;
    };





    var docElem = window.document.documentElement;

    /**
     * Gets a window from an element
     */
    function getWindow( elem ) {
        return jQuery.isWindow( elem ) ?
            elem :
            elem.nodeType === 9 ?
                elem.defaultView || elem.parentWindow :
                false;
    }

    jQuery.offset = {
        setOffset: function( elem, options, i ) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                position = jQuery.css( elem, "position" ),
                curElem = jQuery( elem ),
                props = {};

            // set position first, in-case top/left are set even on static elem
            if ( position === "static" ) {
                elem.style.position = "relative";
            }

            curOffset = curElem.offset();
            curCSSTop = jQuery.css( elem, "top" );
            curCSSLeft = jQuery.css( elem, "left" );
            calculatePosition = ( position === "absolute" || position === "fixed" ) &&
                jQuery.inArray("auto", [ curCSSTop, curCSSLeft ] ) > -1;

            // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
            if ( calculatePosition ) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat( curCSSTop ) || 0;
                curLeft = parseFloat( curCSSLeft ) || 0;
            }

            if ( jQuery.isFunction( options ) ) {
                options = options.call( elem, i, curOffset );
            }

            if ( options.top != null ) {
                props.top = ( options.top - curOffset.top ) + curTop;
            }
            if ( options.left != null ) {
                props.left = ( options.left - curOffset.left ) + curLeft;
            }

            if ( "using" in options ) {
                options.using.call( elem, props );
            } else {
                curElem.css( props );
            }
        }
    };

    jQuery.fn.extend({
        offset: function( options ) {
            if ( arguments.length ) {
                return options === undefined ?
                    this :
                    this.each(function( i ) {
                        jQuery.offset.setOffset( this, options, i );
                    });
            }

            var docElem, win,
                box = { top: 0, left: 0 },
                elem = this[ 0 ],
                doc = elem && elem.ownerDocument;

            if ( !doc ) {
                return;
            }

            docElem = doc.documentElement;

            // Make sure it's not a disconnected DOM node
            if ( !jQuery.contains( docElem, elem ) ) {
                return box;
            }

            // If we don't have gBCR, just use 0,0 rather than error
            // BlackBerry 5, iOS 3 (original iPhone)
            if ( typeof elem.getBoundingClientRect !== strundefined ) {
                box = elem.getBoundingClientRect();
            }
            win = getWindow( doc );
            return {
                top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
                left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
            };
        },

        position: function() {
            if ( !this[ 0 ] ) {
                return;
            }

            var offsetParent, offset,
                parentOffset = { top: 0, left: 0 },
                elem = this[ 0 ];

            // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
            if ( jQuery.css( elem, "position" ) === "fixed" ) {
                // we assume that getBoundingClientRect is available when computed position is fixed
                offset = elem.getBoundingClientRect();
            } else {
                // Get *real* offsetParent
                offsetParent = this.offsetParent();

                // Get correct offsets
                offset = this.offset();
                if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
                    parentOffset = offsetParent.offset();
                }

                // Add offsetParent borders
                parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
                parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
            }

            // Subtract parent offsets and element margins
            // note: when an element has margin: auto the offsetLeft and marginLeft
            // are the same in Safari causing offset.left to incorrectly be 0
            return {
                top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
                left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
            };
        },

        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent || docElem;

                while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || docElem;
            });
        }
    });

// Create scrollLeft and scrollTop methods
    jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
        var top = /Y/.test( prop );

        jQuery.fn[ method ] = function( val ) {
            return access( this, function( elem, method, val ) {
                var win = getWindow( elem );

                if ( val === undefined ) {
                    return win ? (prop in win) ? win[ prop ] :
                        win.document.documentElement[ method ] :
                        elem[ method ];
                }

                if ( win ) {
                    win.scrollTo(
                        !top ? val : jQuery( win ).scrollLeft(),
                        top ? val : jQuery( win ).scrollTop()
                    );

                } else {
                    elem[ method ] = val;
                }
            }, method, val, arguments.length, null );
        };
    });

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
    jQuery.each( [ "top", "left" ], function( i, prop ) {
        jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
            function( elem, computed ) {
                if ( computed ) {
                    computed = curCSS( elem, prop );
                    // if curCSS returns percentage, fallback to offset
                    return rnumnonpx.test( computed ) ?
                        jQuery( elem ).position()[ prop ] + "px" :
                        computed;
                }
            }
        );
    });


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
        jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
            // margin is only for outerHeight, outerWidth
            jQuery.fn[ funcName ] = function( margin, value ) {
                var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                    extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

                return access( this, function( elem, type, value ) {
                    var doc;

                    if ( jQuery.isWindow( elem ) ) {
                        // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                        // isn't a whole lot we can do. See pull request at this URL for discussion:
                        // https://github.com/jquery/jquery/pull/764
                        return elem.document.documentElement[ "client" + name ];
                    }

                    // Get document width or height
                    if ( elem.nodeType === 9 ) {
                        doc = elem.documentElement;

                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
                        // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
                        return Math.max(
                            elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                            elem.body[ "offset" + name ], doc[ "offset" + name ],
                            doc[ "client" + name ]
                        );
                    }

                    return value === undefined ?
                        // Get width or height on the element, requesting but not forcing parseFloat
                        jQuery.css( elem, type, extra ) :

                        // Set width or height on the element
                        jQuery.style( elem, type, value, extra );
                }, type, chainable ? margin : undefined, chainable, null );
            };
        });
    });


// The number of elements contained in the matched element set
    jQuery.fn.size = function() {
        return this.length;
    };

    jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

    if ( typeof define === "function" && define.amd ) {
        define( "jquery", [], function() {
            return jQuery;
        });
    }




    var
        // Map over jQuery in case of overwrite
        _jQuery = window.jQuery,

        // Map over the $ in case of overwrite
        _$ = window.$;

    jQuery.noConflict = function( deep ) {
        if ( window.$ === jQuery ) {
            window.$ = _$;
        }

        if ( deep && window.jQuery === jQuery ) {
            window.jQuery = _jQuery;
        }

        return jQuery;
    };

// Expose jQuery and $ identifiers, even in
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
    if ( typeof noGlobal === strundefined ) {
        window.jQuery = window.$ = jQuery;
    }




    return jQuery;

}));
(function (window) {

    jQuery.easing['jswing'] = jQuery.easing['swing'];

    jQuery.extend( jQuery.easing,
        {
            easeOutBounce: function (x, t, b, c, d) {
                if ((t/=d) < (1/2.75)) {
                    return c*(7.5625*t*t) + b;
                } else if (t < (2/2.75)) {
                    return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
                } else if (t < (2.5/2.75)) {
                    return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
                } else {
                    return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
                }
            },
            easeOutElastic: function (x, t, b, c, d) {
                var s=1.70158;var p=0;var a=c;
                if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
                if (a < Math.abs(c)) { a=c; var s=p/4; }
                else var s = p/(2*Math.PI) * Math.asin (c/a);
                return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
            },
            easeOutExpo: function (x, t, b, c, d) {
                return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
            }
        });


    window.BXReady = {
        showAjaxShadow: function(element, idArea, localeShadow){

            if (localeShadow == true){
                $(element).addClass('ajax-shadow');
                $(element).addClass('ajax-shadow-r');
            }
            else{
                if ($('div').is('#'+idArea)){

                }
                else
                {
                    $('<div id="'+idArea+'" class="ajax-shadow"></div>').appendTo('body');
                }

                $('#'+idArea).show();
                $('#'+idArea).width($(element).width());
                $('#'+idArea).height($(element).outerHeight());
                if ($(element).length && $(element).offset()) {
                    $('#' + idArea).css('top', $(element).offset().top + 'px');
                    $('#' + idArea).css('left', $(element).offset().left + 'px');
                }
            }

        },

        closeAjaxShadow: function(idArea, localShadow){
            if (localShadow == true){
                $(idArea).removeClass('ajax-shadow-r');
                $(idArea).removeClass('ajax-shadow');
            }
            else{
                $('#'+idArea).hide();
            }
        },

        scrollTo: function(targetElement){

            $("html, body").animate({
                scrollTop: $(targetElement).offset().top-20 + "px"
            }, {
                duration: 500
            });
        },

        autosizeVertical: function(){
            maxHeight = 0;
            $('div.bxr-v-autosize').each(function(){
                if ($(this).height()> maxHeight){
                    maxHeight = $(this).height();
                };
            });
            $('div.bxr-v-autosize').each(function(){

                delta = Math.round((maxHeight - $(this).height())/2);
                $(this).css({'padding-top': delta+'px', 'padding-bottom': delta+'px'});
            });
        },

        setHeadPadding: function () {
            //paddingTop = ($(".bxr-full-width.bxr-top-headline.affix").height() > 0) ? $(".bxr-full-width.bxr-top-headline.affix").height() + 25 : 64;
            paddingTop = 40;
            $('.bxr-full-width.bxr-container-headline.head_v1').css("padding-top", paddingTop + "px");
            if (window.scrollY > 0)
                $(".bxr-full-width.bxr-top-headline").addClass("affix-fixed");
        },

        removeAffixHead: function () {
            // var tWirth = $(document).width();
            // if(tWirth==0)
            //     tWirth = screen.width;
            //
            // console.log(tWirth);
            //
            // if (tWirth < 992) {
            //     $(".bxr-full-width.bxr-top-headline").removeClass("affix-fixed");
            //     $(".bxr-full-width.bxr-top-headline").removeClass("fixed");
            //     $(".bxr-full-width.bxr-top-headline").data("spy", "");
            // } else {
            //     $(".bxr-full-width.bxr-top-headline").addClass("affix-fixed");
            //     $(".bxr-full-width.bxr-top-headline").data("spy", "affix");
            // }
        }
    };

    window.BXReady.Market = {
        loader: [],

        setPriceCents: function(){

            $('.bxr-format-price').each(function(){
                price = $(this).html();

                newPrice = price.replace(/(\.\d\d)/g, '<sup>$1</sup>');
                newPrice = newPrice.replace(/(\.)/g, '');

                $(this).html(newPrice);
            });
        },

        bestsellersAjaxUrl: '/ajax/bestsellers.php',
        markersAjaxUrl: '/ajax/markers.php'
    };

    $(document).on('click', '.search-btn', function() {
        var search = $('#searchline');
        if(search.is(":visible"))
            search.fadeOut();
        else
            search.fadeIn();
    });

    $(document).on('click', '.bxr-mobile-login-icon', function() {
        $('.bxr-mobile-login-area').fadeOut(200, function(){
            $('.bxr-mobile-phone-area').fadeIn(200);
        });
    });

    $(document).on('click', '.bxr-mobile-phone-icon', function() {
        if (typeof openAuthorizePopup === 'function') {
            openAuthorizePopup();
        } else {
            $('.bxr-mobile-phone-area').fadeOut(200, function(){
                $('.bxr-mobile-login-area').fadeIn(200);
            });
        }
    });

    $(window).on ('resize', function() {
        if ($(window).width() > 960) {
            $('.bxr-mobile-phone-area').fadeOut(200, function(){
                $('.bxr-mobile-login-area').fadeIn(200);
            });
        } else {
            $('.bxr-mobile-phone-area').fadeIn(200, function(){
                $('.bxr-mobile-login-area').fadeOut(200);
            });
        }
    });

    $(document).on('click', '.mobile-footer-menu-tumbl', function() {
        $(this).next().toggle();
    });

    $(document).on('click', '.delivery-item-more', function() {
        if ($(this).prev('.delivery-item-text').css('display') == 'none'){
            $(this).prev('.delivery-item-text').slideDown();
            $(this).html('<span class="fa fa-angle-up"></span> Hide');
        } else {
            $(this).prev('.delivery-item-text').slideUp();
            $(this).html('<span class="fa fa-angle-down"></span> More');
        }
    });

    window.onload = function()
    {
        if (typeof window.BXReady.Market.loader != 'object')
            window.BXReady.Market.loader = [];
        for ( var i in window.BXReady.Market.loader )
        {
            if ( typeof( window.BXReady.Market.loader[i] ) == 'function' ) window.BXReady.Market.loader[i]();
        }

        BXReady.setHeadPadding();
    };

    if (typeof window.BXReady.Market.loader != 'object')
        window.BXReady.Market.loader = [];
    window.BXReady.Market.loader.push(BXReady.autosizeVertical);
    window.BXReady.Market.loader.push(BXReady.setHeadPadding);
    window.BXReady.Market.loader.push(BXReady.removeAffixHead);


    $( window ).resize(function() {
        BXReady.autosizeVertical();
        BXReady.setHeadPadding();
        BXReady.removeAffixHead();
    });

    // $(document).ready(function () {
    //     BXReady.setHeadPadding();
    // });

})(window);


$(document).ready(function () {
    $('.fancyimg').fancybox();
    var top_show = 500;
    var delay = 1000;

    $(window).scroll(function () {
        if ($(this).scrollTop() > top_show) $('.bxr-button-up').fadeIn();
        else $('.bxr-button-up').fadeOut();
    });

    $('.bxr-button-up').click(function () {
        $('body, html').animate({
            scrollTop: 0
        }, delay);
    });


    $('.bxr-slider').slick({
        slidesToShow: 1,
        dots: true,
        fade: true,
        speed: 1500,
        autoplaySpeed: 3000,
        autoplay: true,
        nextArrow: '<button type="button" class="slick-next bxr-bg-hover-dark-flat"><i class="fa fa-angle-right"></i></button>',
        prevArrow: '<button type="button" class="slick-prev bxr-bg-hover-dark-flat"><i class="fa fa-angle-left"></i></button>',
    });

    $('.bxr-slider').css("visibility", "visible");
});

/*!
 * fancyBox - jQuery Plugin
 * version: 2.1.5 (Fri, 14 Jun 2013)
 * @requires jQuery v1.6 or later
 *
 * Examples at http://fancyapps.com/fancybox/
 * License: www.fancyapps.com/fancybox/#license
 *
 * Copyright 2012 Janis Skarnelis - janis@fancyapps.com
 *
 */

(function (window, document, $, undefined) {
    "use strict";

    var H = $("html"),
        W = $(window),
        D = $(document),
        F = $.fancybox = function () {
            F.open.apply( this, arguments );
        },
        IE =  navigator.userAgent.match(/msie/i),
        didUpdate	= null,
        isTouch		= document.createTouch !== undefined,

        isQuery	= function(obj) {
            return obj && obj.hasOwnProperty && obj instanceof $;
        },
        isString = function(str) {
            return str && $.type(str) === "string";
        },
        isPercentage = function(str) {
            return isString(str) && str.indexOf('%') > 0;
        },
        isScrollable = function(el) {
            return (el && !(el.style.overflow && el.style.overflow === 'hidden') && ((el.clientWidth && el.scrollWidth > el.clientWidth) || (el.clientHeight && el.scrollHeight > el.clientHeight)));
        },
        getScalar = function(orig, dim) {
            var value = parseInt(orig, 10) || 0;

            if (dim && isPercentage(orig)) {
                value = F.getViewport()[ dim ] / 100 * value;
            }

            return Math.ceil(value);
        },
        getValue = function(value, dim) {
            return getScalar(value, dim) + 'px';
        };

    $.extend(F, {
        // The current version of fancyBox
        version: '2.1.5',

        defaults: {
            padding : 15,
            margin  : 20,

            width     : 800,
            height    : 600,
            minWidth  : 100,
            minHeight : 100,
            maxWidth  : 9999,
            maxHeight : 9999,
            pixelRatio: 1, // Set to 2 for retina display support

            autoSize   : true,
            autoHeight : false,
            autoWidth  : false,

            autoResize  : true,
            autoCenter  : !isTouch,
            fitToView   : true,
            aspectRatio : false,
            topRatio    : 0.5,
            leftRatio   : 0.5,

            scrolling : 'auto', // 'auto', 'yes' or 'no'
            wrapCSS   : '',

            arrows     : true,
            closeBtn   : true,
            closeClick : false,
            nextClick  : false,
            mouseWheel : true,
            autoPlay   : false,
            playSpeed  : 3000,
            preload    : 3,
            modal      : false,
            loop       : true,

            ajax  : {
                dataType : 'html',
                headers  : { 'X-fancyBox': true }
            },
            iframe : {
                scrolling : 'auto',
                preload   : true
            },
            swf : {
                wmode: 'transparent',
                allowfullscreen   : 'true',
                allowscriptaccess : 'always'
            },

            keys  : {
                next : {
                    13 : 'left', // enter
                    34 : 'up',   // page down
                    39 : 'left', // right arrow
                    40 : 'up'    // down arrow
                },
                prev : {
                    8  : 'right',  // backspace
                    33 : 'down',   // page up
                    37 : 'right',  // left arrow
                    38 : 'down'    // up arrow
                },
                close  : [27], // escape key
                play   : [32], // space - start/stop slideshow
                toggle : [70]  // letter "f" - toggle fullscreen
            },

            direction : {
                next : 'left',
                prev : 'right'
            },

            scrollOutside  : true,

            // Override some properties
            index   : 0,
            type    : null,
            href    : null,
            content : null,
            title   : null,

            // HTML templates
            tpl: {
                wrap     : '<div class="fancybox-wrap" tabIndex="-1"><div class="fancybox-skin"><div class="fancybox-outer"><div class="fancybox-inner"></div></div></div></div>',
                image    : '<img class="fancybox-image" src="{href}" alt="" />',
                iframe   : '<iframe id="fancybox-frame{rnd}" name="fancybox-frame{rnd}" class="fancybox-iframe" frameborder="0" vspace="0" hspace="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen' + (IE ? ' allowtransparency="true"' : '') + '></iframe>',
                error    : '<p class="fancybox-error">The requested content cannot be loaded.<br/>Please try again later.</p>',
                closeBtn : '<a title="Close" class="fancybox-item fancybox-close" href="javascript:;"></a>',
                next     : '<a title="Next" class="fancybox-nav fancybox-next" href="javascript:;"><span></span></a>',
                prev     : '<a title="Previous" class="fancybox-nav fancybox-prev" href="javascript:;"><span></span></a>'
            },

            // Properties for each animation type
            // Opening fancyBox
            openEffect  : 'fade', // 'elastic', 'fade' or 'none'
            openSpeed   : 250,
            openEasing  : 'swing',
            openOpacity : true,
            openMethod  : 'zoomIn',

            // Closing fancyBox
            closeEffect  : 'fade', // 'elastic', 'fade' or 'none'
            closeSpeed   : 250,
            closeEasing  : 'swing',
            closeOpacity : true,
            closeMethod  : 'zoomOut',

            // Changing next gallery item
            nextEffect : 'elastic', // 'elastic', 'fade' or 'none'
            nextSpeed  : 250,
            nextEasing : 'swing',
            nextMethod : 'changeIn',

            // Changing previous gallery item
            prevEffect : 'elastic', // 'elastic', 'fade' or 'none'
            prevSpeed  : 250,
            prevEasing : 'swing',
            prevMethod : 'changeOut',

            // Enable default helpers
            helpers : {
                overlay : true,
                title   : true
            },

            // Callbacks
            onCancel     : $.noop, // If canceling
            beforeLoad   : $.noop, // Before loading
            afterLoad    : $.noop, // After loading
            beforeShow   : $.noop, // Before changing in current item
            afterShow    : $.noop, // After opening
            beforeChange : $.noop, // Before changing gallery item
            beforeClose  : $.noop, // Before closing
            afterClose   : $.noop  // After closing
        },

        //Current state
        group    : {}, // Selected group
        opts     : {}, // Group options
        previous : null,  // Previous element
        coming   : null,  // Element being loaded
        current  : null,  // Currently loaded element
        isActive : false, // Is activated
        isOpen   : false, // Is currently open
        isOpened : false, // Have been fully opened at least once

        wrap  : null,
        skin  : null,
        outer : null,
        inner : null,

        player : {
            timer    : null,
            isActive : false
        },

        // Loaders
        ajaxLoad   : null,
        imgPreload : null,

        // Some collections
        transitions : {},
        helpers     : {},

        /*
         *	Static methods
         */

        open: function (group, opts) {
            if (!group) {
                return;
            }

            if (!$.isPlainObject(opts)) {
                opts = {};
            }

            // Close if already active
            if (false === F.close(true)) {
                return;
            }

            // Normalize group
            if (!$.isArray(group)) {
                group = isQuery(group) ? $(group).get() : [group];
            }

            // Recheck if the type of each element is `object` and set content type (image, ajax, etc)
            $.each(group, function(i, element) {
                var obj = {},
                    href,
                    title,
                    content,
                    type,
                    rez,
                    hrefParts,
                    selector;

                if ($.type(element) === "object") {
                    // Check if is DOM element
                    if (element.nodeType) {
                        element = $(element);
                    }

                    if (isQuery(element)) {
                        obj = {
                            href    : element.data('fancybox-href') || element.attr('href'),
                            title   : element.data('fancybox-title') || element.attr('title'),
                            isDom   : true,
                            element : element
                        };

                        if ($.metadata) {
                            $.extend(true, obj, element.metadata());
                        }

                    } else {
                        obj = element;
                    }
                }

                href  = opts.href  || obj.href || (isString(element) ? element : null);
                title = opts.title !== undefined ? opts.title : obj.title || '';

                content = opts.content || obj.content;
                type    = content ? 'html' : (opts.type  || obj.type);

                if (!type && obj.isDom) {
                    type = element.data('fancybox-type');

                    if (!type) {
                        rez  = element.prop('class').match(/fancybox\.(\w+)/);
                        type = rez ? rez[1] : null;
                    }
                }

                if (isString(href)) {
                    // Try to guess the content type
                    if (!type) {
                        if (F.isImage(href)) {
                            type = 'image';

                        } else if (F.isSWF(href)) {
                            type = 'swf';

                        } else if (href.charAt(0) === '#') {
                            type = 'inline';

                        } else if (isString(element)) {
                            type    = 'html';
                            content = element;
                        }
                    }

                    // Split url into two pieces with fancybox url and content selector, e.g,
                    // "/mypage.html #my_id" will load "/mypage.html" and display element having id "my_id"
                    if (type === 'ajax') {
                        hrefParts = href.split(/\s+/, 2);
                        href      = hrefParts.shift();
                        selector  = hrefParts.shift();
                    }
                }

                if (!content) {
                    if (type === 'inline') {
                        if (href) {
                            content = $( isString(href) ? href.replace(/.*(?=#[^\s]+$)/, '') : href ); //strip for ie7

                        } else if (obj.isDom) {
                            content = element;
                        }

                    } else if (type === 'html') {
                        content = href;

                    } else if (!type && !href && obj.isDom) {
                        type    = 'inline';
                        content = element;
                    }
                }

                $.extend(obj, {
                    href     : href,
                    type     : type,
                    content  : content,
                    title    : title,
                    selector : selector
                });

                group[ i ] = obj;
            });

            // Extend the defaults
            F.opts = $.extend(true, {}, F.defaults, opts);

            // All options are merged recursive except keys
            if (opts.keys !== undefined) {
                F.opts.keys = opts.keys ? $.extend({}, F.defaults.keys, opts.keys) : false;
            }

            F.group = group;

            return F._start(F.opts.index);
        },

        // Cancel image loading or abort ajax request
        cancel: function () {
            var coming = F.coming;

            if (!coming || false === F.trigger('onCancel')) {
                return;
            }

            F.hideLoading();

            if (F.ajaxLoad) {
                F.ajaxLoad.abort();
            }

            F.ajaxLoad = null;

            if (F.imgPreload) {
                F.imgPreload.onload = F.imgPreload.onerror = null;
            }

            if (coming.wrap) {
                coming.wrap.stop(true, true).trigger('onReset').remove();
            }

            F.coming = null;

            // If the first item has been canceled, then clear everything
            if (!F.current) {
                F._afterZoomOut( coming );
            }
        },

        // Start closing animation if is open; remove immediately if opening/closing
        close: function (event) {
            F.cancel();

            if (false === F.trigger('beforeClose')) {
                return;
            }

            F.unbindEvents();

            if (!F.isActive) {
                return;
            }

            if (!F.isOpen || event === true) {
                $('.fancybox-wrap').stop(true).trigger('onReset').remove();

                F._afterZoomOut();

            } else {
                F.isOpen = F.isOpened = false;
                F.isClosing = true;

                $('.fancybox-item, .fancybox-nav').remove();

                F.wrap.stop(true, true).removeClass('fancybox-opened');

                F.transitions[ F.current.closeMethod ]();
            }
        },

        // Manage slideshow:
        //   $.fancybox.play(); - toggle slideshow
        //   $.fancybox.play( true ); - start
        //   $.fancybox.play( false ); - stop
        play: function ( action ) {
            var clear = function () {
                    clearTimeout(F.player.timer);
                },
                set = function () {
                    clear();

                    if (F.current && F.player.isActive) {
                        F.player.timer = setTimeout(F.next, F.current.playSpeed);
                    }
                },
                stop = function () {
                    clear();

                    D.unbind('.player');

                    F.player.isActive = false;

                    F.trigger('onPlayEnd');
                },
                start = function () {
                    if (F.current && (F.current.loop || F.current.index < F.group.length - 1)) {
                        F.player.isActive = true;

                        D.bind({
                            'onCancel.player beforeClose.player' : stop,
                            'onUpdate.player'   : set,
                            'beforeLoad.player' : clear
                        });

                        set();

                        F.trigger('onPlayStart');
                    }
                };

            if (action === true || (!F.player.isActive && action !== false)) {
                start();
            } else {
                stop();
            }
        },

        // Navigate to next gallery item
        next: function ( direction ) {
            var current = F.current;

            if (current) {
                if (!isString(direction)) {
                    direction = current.direction.next;
                }

                F.jumpto(current.index + 1, direction, 'next');
            }
        },

        // Navigate to previous gallery item
        prev: function ( direction ) {
            var current = F.current;

            if (current) {
                if (!isString(direction)) {
                    direction = current.direction.prev;
                }

                F.jumpto(current.index - 1, direction, 'prev');
            }
        },

        // Navigate to gallery item by index
        jumpto: function ( index, direction, router ) {
            var current = F.current;

            if (!current) {
                return;
            }

            index = getScalar(index);

            F.direction = direction || current.direction[ (index >= current.index ? 'next' : 'prev') ];
            F.router    = router || 'jumpto';

            if (current.loop) {
                if (index < 0) {
                    index = current.group.length + (index % current.group.length);
                }

                index = index % current.group.length;
            }

            if (current.group[ index ] !== undefined) {
                F.cancel();

                F._start(index);
            }
        },

        // Center inside viewport and toggle position type to fixed or absolute if needed
        reposition: function (e, onlyAbsolute) {
            var current = F.current,
                wrap    = current ? current.wrap : null,
                pos;

            if (wrap) {
                pos = F._getPosition(onlyAbsolute);

                if (e && e.type === 'scroll') {
                    delete pos.position;

                    wrap.stop(true, true).animate(pos, 200);

                } else {
                    wrap.css(pos);

                    current.pos = $.extend({}, current.dim, pos);
                }
            }
        },

        update: function (e) {
            var type = (e && e.type),
                anyway = !type || type === 'orientationchange';

            if (anyway) {
                clearTimeout(didUpdate);

                didUpdate = null;
            }

            if (!F.isOpen || didUpdate) {
                return;
            }

            didUpdate = setTimeout(function() {
                var current = F.current;

                if (!current || F.isClosing) {
                    return;
                }

                F.wrap.removeClass('fancybox-tmp');

                if (anyway || type === 'load' || (type === 'resize' && current.autoResize)) {
                    F._setDimension();
                }

                if (!(type === 'scroll' && current.canShrink)) {
                    F.reposition(e);
                }

                F.trigger('onUpdate');

                didUpdate = null;

            }, (anyway && !isTouch ? 0 : 300));
        },

        // Shrink content to fit inside viewport or restore if resized
        toggle: function ( action ) {
            if (F.isOpen) {
                F.current.fitToView = $.type(action) === "boolean" ? action : !F.current.fitToView;

                // Help browser to restore document dimensions
                if (isTouch) {
                    F.wrap.removeAttr('style').addClass('fancybox-tmp');

                    F.trigger('onUpdate');
                }

                F.update();
            }
        },

        hideLoading: function () {
            D.unbind('.loading');

            $('#fancybox-loading').remove();
        },

        showLoading: function () {
            var el, viewport;

            F.hideLoading();

            el = $('<div id="fancybox-loading"><div></div></div>').click(F.cancel).appendTo('body');

            // If user will press the escape-button, the request will be canceled
            D.bind('keydown.loading', function(e) {
                if ((e.which || e.keyCode) === 27) {
                    e.preventDefault();

                    F.cancel();
                }
            });

            if (!F.defaults.fixed) {
                viewport = F.getViewport();

                el.css({
                    position : 'absolute',
                    top  : (viewport.h * 0.5) + viewport.y,
                    left : (viewport.w * 0.5) + viewport.x
                });
            }
        },

        getViewport: function () {
            var locked = (F.current && F.current.locked) || false,
                rez    = {
                    x: W.scrollLeft(),
                    y: W.scrollTop()
                };

            if (locked) {
                rez.w = locked[0].clientWidth;
                rez.h = locked[0].clientHeight;

            } else {
                // See http://bugs.jquery.com/ticket/6724
                rez.w = isTouch && window.innerWidth  ? window.innerWidth  : W.width();
                rez.h = isTouch && window.innerHeight ? window.innerHeight : W.height();
            }

            return rez;
        },

        // Unbind the keyboard / clicking actions
        unbindEvents: function () {
            if (F.wrap && isQuery(F.wrap)) {
                F.wrap.unbind('.fb');
            }

            D.unbind('.fb');
            W.unbind('.fb');
        },

        bindEvents: function () {
            var current = F.current,
                keys;

            if (!current) {
                return;
            }

            // Changing document height on iOS devices triggers a 'resize' event,
            // that can change document height... repeating infinitely
            W.bind('orientationchange.fb' + (isTouch ? '' : ' resize.fb') + (current.autoCenter && !current.locked ? ' scroll.fb' : ''), F.update);

            keys = current.keys;

            if (keys) {
                D.bind('keydown.fb', function (e) {
                    var code   = e.which || e.keyCode,
                        target = e.target || e.srcElement;

                    // Skip esc key if loading, because showLoading will cancel preloading
                    if (code === 27 && F.coming) {
                        return false;
                    }

                    // Ignore key combinations and key events within form elements
                    if (!e.ctrlKey && !e.altKey && !e.shiftKey && !e.metaKey && !(target && (target.type || $(target).is('[contenteditable]')))) {
                        $.each(keys, function(i, val) {
                            if (current.group.length > 1 && val[ code ] !== undefined) {
                                F[ i ]( val[ code ] );

                                e.preventDefault();
                                return false;
                            }

                            if ($.inArray(code, val) > -1) {
                                F[ i ] ();

                                e.preventDefault();
                                return false;
                            }
                        });
                    }
                });
            }

            if ($.fn.mousewheel && current.mouseWheel) {
                F.wrap.bind('mousewheel.fb', function (e, delta, deltaX, deltaY) {
                    var target = e.target || null,
                        parent = $(target),
                        canScroll = false;

                    while (parent.length) {
                        if (canScroll || parent.is('.fancybox-skin') || parent.is('.fancybox-wrap')) {
                            break;
                        }

                        canScroll = isScrollable( parent[0] );
                        parent    = $(parent).parent();
                    }

                    if (delta !== 0 && !canScroll) {
                        if (F.group.length > 1 && !current.canShrink) {
                            if (deltaY > 0 || deltaX > 0) {
                                F.prev( deltaY > 0 ? 'down' : 'left' );

                            } else if (deltaY < 0 || deltaX < 0) {
                                F.next( deltaY < 0 ? 'up' : 'right' );
                            }

                            e.preventDefault();
                        }
                    }
                });
            }
        },

        trigger: function (event, o) {
            var ret, obj = o || F.coming || F.current;

            if (!obj) {
                return;
            }

            if ($.isFunction( obj[event] )) {
                ret = obj[event].apply(obj, Array.prototype.slice.call(arguments, 1));
            }

            if (ret === false) {
                return false;
            }

            if (obj.helpers) {
                $.each(obj.helpers, function (helper, opts) {
                    if (opts && F.helpers[helper] && $.isFunction(F.helpers[helper][event])) {
                        F.helpers[helper][event]($.extend(true, {}, F.helpers[helper].defaults, opts), obj);
                    }
                });
            }

            D.trigger(event);
        },

        isImage: function (str) {
            return isString(str) && str.match(/(^data:image\/.*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg)((\?|#).*)?$)/i);
        },

        isSWF: function (str) {
            return isString(str) && str.match(/\.(swf)((\?|#).*)?$/i);
        },

        _start: function (index) {
            var coming = {},
                obj,
                href,
                type,
                margin,
                padding;

            index = getScalar( index );
            obj   = F.group[ index ] || null;

            if (!obj) {
                return false;
            }

            coming = $.extend(true, {}, F.opts, obj);

            // Convert margin and padding properties to array - top, right, bottom, left
            margin  = coming.margin;
            padding = coming.padding;

            if ($.type(margin) === 'number') {
                coming.margin = [margin, margin, margin, margin];
            }

            if ($.type(padding) === 'number') {
                coming.padding = [padding, padding, padding, padding];
            }

            // 'modal' propery is just a shortcut
            if (coming.modal) {
                $.extend(true, coming, {
                    closeBtn   : false,
                    closeClick : false,
                    nextClick  : false,
                    arrows     : false,
                    mouseWheel : false,
                    keys       : null,
                    helpers: {
                        overlay : {
                            closeClick : false
                        }
                    }
                });
            }

            // 'autoSize' property is a shortcut, too
            if (coming.autoSize) {
                coming.autoWidth = coming.autoHeight = true;
            }

            if (coming.width === 'auto') {
                coming.autoWidth = true;
            }

            if (coming.height === 'auto') {
                coming.autoHeight = true;
            }

            /*
             * Add reference to the group, so it`s possible to access from callbacks, example:
             * afterLoad : function() {
             *     this.title = 'Image ' + (this.index + 1) + ' of ' + this.group.length + (this.title ? ' - ' + this.title : '');
             * }
             */

            coming.group  = F.group;
            coming.index  = index;

            // Give a chance for callback or helpers to update coming item (type, title, etc)
            F.coming = coming;

            if (false === F.trigger('beforeLoad')) {
                F.coming = null;

                return;
            }

            type = coming.type;
            href = coming.href;

            if (!type) {
                F.coming = null;

                //If we can not determine content type then drop silently or display next/prev item if looping through gallery
                if (F.current && F.router && F.router !== 'jumpto') {
                    F.current.index = index;

                    return F[ F.router ]( F.direction );
                }

                return false;
            }

            F.isActive = true;

            if (type === 'image' || type === 'swf') {
                coming.autoHeight = coming.autoWidth = false;
                coming.scrolling  = 'visible';
            }

            if (type === 'image') {
                coming.aspectRatio = true;
            }

            if (type === 'iframe' && isTouch) {
                coming.scrolling = 'scroll';
            }

            // Build the neccessary markup
            coming.wrap = $(coming.tpl.wrap).addClass('fancybox-' + (isTouch ? 'mobile' : 'desktop') + ' fancybox-type-' + type + ' fancybox-tmp ' + coming.wrapCSS).appendTo( coming.parent || 'body' );

            $.extend(coming, {
                skin  : $('.fancybox-skin',  coming.wrap),
                outer : $('.fancybox-outer', coming.wrap),
                inner : $('.fancybox-inner', coming.wrap)
            });

            $.each(["Top", "Right", "Bottom", "Left"], function(i, v) {
                coming.skin.css('padding' + v, getValue(coming.padding[ i ]));
            });

            F.trigger('onReady');

            // Check before try to load; 'inline' and 'html' types need content, others - href
            if (type === 'inline' || type === 'html') {
                if (!coming.content || !coming.content.length) {
                    return F._error( 'content' );
                }

            } else if (!href) {
                return F._error( 'href' );
            }

            if (type === 'image') {
                F._loadImage();

            } else if (type === 'ajax') {
                F._loadAjax();

            } else if (type === 'iframe') {
                F._loadIframe();

            } else {
                F._afterLoad();
            }
        },

        _error: function ( type ) {
            $.extend(F.coming, {
                type       : 'html',
                autoWidth  : true,
                autoHeight : true,
                minWidth   : 0,
                minHeight  : 0,
                scrolling  : 'no',
                hasError   : type,
                content    : F.coming.tpl.error
            });

            F._afterLoad();
        },

        _loadImage: function () {
            // Reset preload image so it is later possible to check "complete" property
            var img = F.imgPreload = new Image();

            img.onload = function () {
                this.onload = this.onerror = null;

                F.coming.width  = this.width / F.opts.pixelRatio;
                F.coming.height = this.height / F.opts.pixelRatio;

                F._afterLoad();
            };

            img.onerror = function () {
                this.onload = this.onerror = null;

                F._error( 'image' );
            };

            img.src = F.coming.href;

            if (img.complete !== true) {
                F.showLoading();
            }
        },

        _loadAjax: function () {
            var coming = F.coming;

            F.showLoading();

            F.ajaxLoad = $.ajax($.extend({}, coming.ajax, {
                url: coming.href,
                error: function (jqXHR, textStatus) {
                    if (F.coming && textStatus !== 'abort') {
                        F._error( 'ajax', jqXHR );

                    } else {
                        F.hideLoading();
                    }
                },
                success: function (data, textStatus) {
                    if (textStatus === 'success') {
                        coming.content = data;

                        F._afterLoad();
                    }
                }
            }));
        },

        _loadIframe: function() {
            var coming = F.coming,
                iframe = $(coming.tpl.iframe.replace(/\{rnd\}/g, new Date().getTime()))
                    .attr('scrolling', isTouch ? 'auto' : coming.iframe.scrolling)
                    .attr('src', coming.href);

            // This helps IE
            $(coming.wrap).bind('onReset', function () {
                try {
                    $(this).find('iframe').hide().attr('src', '//about:blank').end().empty();
                } catch (e) {}
            });

            if (coming.iframe.preload) {
                F.showLoading();

                iframe.one('load', function() {
                    $(this).data('ready', 1);

                    // iOS will lose scrolling if we resize
                    if (!isTouch) {
                        $(this).bind('load.fb', F.update);
                    }

                    // Without this trick:
                    //   - iframe won't scroll on iOS devices
                    //   - IE7 sometimes displays empty iframe
                    $(this).parents('.fancybox-wrap').width('100%').removeClass('fancybox-tmp').show();

                    F._afterLoad();
                });
            }

            coming.content = iframe.appendTo( coming.inner );

            if (!coming.iframe.preload) {
                F._afterLoad();
            }
        },

        _preloadImages: function() {
            var group   = F.group,
                current = F.current,
                len     = group.length,
                cnt     = current.preload ? Math.min(current.preload, len - 1) : 0,
                item,
                i;

            for (i = 1; i <= cnt; i += 1) {
                item = group[ (current.index + i ) % len ];

                if (item.type === 'image' && item.href) {
                    new Image().src = item.href;
                }
            }
        },

        _afterLoad: function () {
            var coming   = F.coming,
                previous = F.current,
                placeholder = 'fancybox-placeholder',
                current,
                content,
                type,
                scrolling,
                href,
                embed;

            F.hideLoading();

            if (!coming || F.isActive === false) {
                return;
            }

            if (false === F.trigger('afterLoad', coming, previous)) {
                coming.wrap.stop(true).trigger('onReset').remove();

                F.coming = null;

                return;
            }

            if (previous) {
                F.trigger('beforeChange', previous);

                previous.wrap.stop(true).removeClass('fancybox-opened')
                    .find('.fancybox-item, .fancybox-nav')
                    .remove();
            }

            F.unbindEvents();

            current   = coming;
            content   = coming.content;
            type      = coming.type;
            scrolling = coming.scrolling;

            $.extend(F, {
                wrap  : current.wrap,
                skin  : current.skin,
                outer : current.outer,
                inner : current.inner,
                current  : current,
                previous : previous
            });

            href = current.href;

            switch (type) {
                case 'inline':
                case 'ajax':
                case 'html':
                    if (current.selector) {
                        content = $('<div>').html(content).find(current.selector);

                    } else if (isQuery(content)) {
                        if (!content.data(placeholder)) {
                            content.data(placeholder, $('<div class="' + placeholder + '"></div>').insertAfter( content ).hide() );
                        }

                        content = content.show().detach();

                        current.wrap.bind('onReset', function () {
                            if ($(this).find(content).length) {
                                content.hide().replaceAll( content.data(placeholder) ).data(placeholder, false);
                            }
                        });
                    }
                    break;

                case 'image':
                    content = current.tpl.image.replace('{href}', href);
                    break;

                case 'swf':
                    content = '<object id="fancybox-swf" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="100%" height="100%"><param name="movie" value="' + href + '"></param>';
                    embed   = '';

                    $.each(current.swf, function(name, val) {
                        content += '<param name="' + name + '" value="' + val + '"></param>';
                        embed   += ' ' + name + '="' + val + '"';
                    });

                    content += '<embed src="' + href + '" type="application/x-shockwave-flash" width="100%" height="100%"' + embed + '></embed></object>';
                    break;
            }

            if (!(isQuery(content) && content.parent().is(current.inner))) {
                current.inner.append( content );
            }

            // Give a chance for helpers or callbacks to update elements
            F.trigger('beforeShow');

            // Set scrolling before calculating dimensions
            current.inner.css('overflow', scrolling === 'yes' ? 'scroll' : (scrolling === 'no' ? 'hidden' : scrolling));

            // Set initial dimensions and start position
            F._setDimension();

            F.reposition();

            F.isOpen = false;
            F.coming = null;

            F.bindEvents();

            if (!F.isOpened) {
                $('.fancybox-wrap').not( current.wrap ).stop(true).trigger('onReset').remove();

            } else if (previous.prevMethod) {
                F.transitions[ previous.prevMethod ]();
            }

            F.transitions[ F.isOpened ? current.nextMethod : current.openMethod ]();

            F._preloadImages();
        },

        _setDimension: function () {
            var viewport   = F.getViewport(),
                steps      = 0,
                canShrink  = false,
                canExpand  = false,
                wrap       = F.wrap,
                skin       = F.skin,
                inner      = F.inner,
                current    = F.current,
                width      = current.width,
                height     = current.height,
                minWidth   = current.minWidth,
                minHeight  = current.minHeight,
                maxWidth   = current.maxWidth,
                maxHeight  = current.maxHeight,
                scrolling  = current.scrolling,
                scrollOut  = current.scrollOutside ? current.scrollbarWidth : 0,
                margin     = current.margin,
                wMargin    = getScalar(margin[1] + margin[3]),
                hMargin    = getScalar(margin[0] + margin[2]),
                wPadding,
                hPadding,
                wSpace,
                hSpace,
                origWidth,
                origHeight,
                origMaxWidth,
                origMaxHeight,
                ratio,
                width_,
                height_,
                maxWidth_,
                maxHeight_,
                iframe,
                body;

            // Reset dimensions so we could re-check actual size
            wrap.add(skin).add(inner).width('auto').height('auto').removeClass('fancybox-tmp');

            wPadding = getScalar(skin.outerWidth(true)  - skin.width());
            hPadding = getScalar(skin.outerHeight(true) - skin.height());

            // Any space between content and viewport (margin, padding, border, title)
            wSpace = wMargin + wPadding;
            hSpace = hMargin + hPadding;

            origWidth  = isPercentage(width)  ? (viewport.w - wSpace) * getScalar(width)  / 100 : width;
            origHeight = isPercentage(height) ? (viewport.h - hSpace) * getScalar(height) / 100 : height;

            if (current.type === 'iframe') {
                iframe = current.content;

                if (current.autoHeight && iframe.data('ready') === 1) {
                    try {
                        if (iframe[0].contentWindow.document.location) {
                            inner.width( origWidth ).height(9999);

                            body = iframe.contents().find('body');

                            if (scrollOut) {
                                body.css('overflow-x', 'hidden');
                            }

                            origHeight = body.outerHeight(true);
                        }

                    } catch (e) {}
                }

            } else if (current.autoWidth || current.autoHeight) {
                inner.addClass( 'fancybox-tmp' );

                // Set width or height in case we need to calculate only one dimension
                if (!current.autoWidth) {
                    inner.width( origWidth );
                }

                if (!current.autoHeight) {
                    inner.height( origHeight );
                }

                if (current.autoWidth) {
                    origWidth = inner.width();
                }

                if (current.autoHeight) {
                    origHeight = inner.height();
                }

                inner.removeClass( 'fancybox-tmp' );
            }

            width  = getScalar( origWidth );
            height = getScalar( origHeight );

            ratio  = origWidth / origHeight;

            // Calculations for the content
            minWidth  = getScalar(isPercentage(minWidth) ? getScalar(minWidth, 'w') - wSpace : minWidth);
            maxWidth  = getScalar(isPercentage(maxWidth) ? getScalar(maxWidth, 'w') - wSpace : maxWidth);

            minHeight = getScalar(isPercentage(minHeight) ? getScalar(minHeight, 'h') - hSpace : minHeight);
            maxHeight = getScalar(isPercentage(maxHeight) ? getScalar(maxHeight, 'h') - hSpace : maxHeight);

            // These will be used to determine if wrap can fit in the viewport
            origMaxWidth  = maxWidth;
            origMaxHeight = maxHeight;

            if (current.fitToView) {
                maxWidth  = Math.min(viewport.w - wSpace, maxWidth);
                maxHeight = Math.min(viewport.h - hSpace, maxHeight);
            }

            maxWidth_  = viewport.w - wMargin;
            maxHeight_ = viewport.h - hMargin;

            if (current.aspectRatio) {
                if (width > maxWidth) {
                    width  = maxWidth;
                    height = getScalar(width / ratio);
                }

                if (height > maxHeight) {
                    height = maxHeight;
                    width  = getScalar(height * ratio);
                }

                if (width < minWidth) {
                    width  = minWidth;
                    height = getScalar(width / ratio);
                }

                if (height < minHeight) {
                    height = minHeight;
                    width  = getScalar(height * ratio);
                }

            } else {
                width = Math.max(minWidth, Math.min(width, maxWidth));

                if (current.autoHeight && current.type !== 'iframe') {
                    inner.width( width );

                    height = inner.height();
                }

                height = Math.max(minHeight, Math.min(height, maxHeight));
            }

            // Try to fit inside viewport (including the title)
            if (current.fitToView) {
                inner.width( width ).height( height );

                wrap.width( width + wPadding );

                // Real wrap dimensions
                width_  = wrap.width();
                height_ = wrap.height();

                if (current.aspectRatio) {
                    while ((width_ > maxWidth_ || height_ > maxHeight_) && width > minWidth && height > minHeight) {
                        if (steps++ > 19) {
                            break;
                        }

                        height = Math.max(minHeight, Math.min(maxHeight, height - 10));
                        width  = getScalar(height * ratio);

                        if (width < minWidth) {
                            width  = minWidth;
                            height = getScalar(width / ratio);
                        }

                        if (width > maxWidth) {
                            width  = maxWidth;
                            height = getScalar(width / ratio);
                        }

                        inner.width( width ).height( height );

                        wrap.width( width + wPadding );

                        width_  = wrap.width();
                        height_ = wrap.height();
                    }

                } else {
                    width  = Math.max(minWidth,  Math.min(width,  width  - (width_  - maxWidth_)));
                    height = Math.max(minHeight, Math.min(height, height - (height_ - maxHeight_)));
                }
            }

            if (scrollOut && scrolling === 'auto' && height < origHeight && (width + wPadding + scrollOut) < maxWidth_) {
                width += scrollOut;
            }

            inner.width( width ).height( height );

            wrap.width( width + wPadding );

            width_  = wrap.width();
            height_ = wrap.height();

            canShrink = (width_ > maxWidth_ || height_ > maxHeight_) && width > minWidth && height > minHeight;
            canExpand = current.aspectRatio ? (width < origMaxWidth && height < origMaxHeight && width < origWidth && height < origHeight) : ((width < origMaxWidth || height < origMaxHeight) && (width < origWidth || height < origHeight));

            $.extend(current, {
                dim : {
                    width	: getValue( width_ ),
                    height	: getValue( height_ )
                },
                origWidth  : origWidth,
                origHeight : origHeight,
                canShrink  : canShrink,
                canExpand  : canExpand,
                wPadding   : wPadding,
                hPadding   : hPadding,
                wrapSpace  : height_ - skin.outerHeight(true),
                skinSpace  : skin.height() - height
            });

            if (!iframe && current.autoHeight && height > minHeight && height < maxHeight && !canExpand) {
                inner.height('auto');
            }
        },

        _getPosition: function (onlyAbsolute) {
            var current  = F.current,
                viewport = F.getViewport(),
                margin   = current.margin,
                width    = F.wrap.width()  + margin[1] + margin[3],
                height   = F.wrap.height() + margin[0] + margin[2],
                rez      = {
                    position: 'absolute',
                    top  : margin[0],
                    left : margin[3]
                };

            if (current.autoCenter && current.fixed && !onlyAbsolute && height <= viewport.h && width <= viewport.w) {
                rez.position = 'fixed';

            } else if (!current.locked) {
                rez.top  += viewport.y;
                rez.left += viewport.x;
            }

            rez.top  = getValue(Math.max(rez.top,  rez.top  + ((viewport.h - height) * current.topRatio)));
            rez.left = getValue(Math.max(rez.left, rez.left + ((viewport.w - width)  * current.leftRatio)));

            return rez;
        },

        _afterZoomIn: function () {
            var current = F.current;

            if (!current) {
                return;
            }

            F.isOpen = F.isOpened = true;

            F.wrap.css('overflow', 'visible').addClass('fancybox-opened');

            F.update();

            // Assign a click event
            if ( current.closeClick || (current.nextClick && F.group.length > 1) ) {
                F.inner.css('cursor', 'pointer').bind('click.fb', function(e) {
                    if (!$(e.target).is('a') && !$(e.target).parent().is('a')) {
                        e.preventDefault();

                        F[ current.closeClick ? 'close' : 'next' ]();
                    }
                });
            }

            // Create a close button
            if (current.closeBtn) {
                $(current.tpl.closeBtn).appendTo(F.skin).bind('click.fb', function(e) {
                    e.preventDefault();

                    F.close();
                });
            }

            // Create navigation arrows
            if (current.arrows && F.group.length > 1) {
                if (current.loop || current.index > 0) {
                    $(current.tpl.prev).appendTo(F.outer).bind('click.fb', F.prev);
                }

                if (current.loop || current.index < F.group.length - 1) {
                    $(current.tpl.next).appendTo(F.outer).bind('click.fb', F.next);
                }
            }

            F.trigger('afterShow');

            // Stop the slideshow if this is the last item
            if (!current.loop && current.index === current.group.length - 1) {
                F.play( false );

            } else if (F.opts.autoPlay && !F.player.isActive) {
                F.opts.autoPlay = false;

                F.play();
            }
        },

        _afterZoomOut: function ( obj ) {
            obj = obj || F.current;

            $('.fancybox-wrap').trigger('onReset').remove();

            $.extend(F, {
                group  : {},
                opts   : {},
                router : false,
                current   : null,
                isActive  : false,
                isOpened  : false,
                isOpen    : false,
                isClosing : false,
                wrap   : null,
                skin   : null,
                outer  : null,
                inner  : null
            });

            F.trigger('afterClose', obj);
        }
    });

    /*
     *	Default transitions
     */

    F.transitions = {
        getOrigPosition: function () {
            var current  = F.current,
                element  = current.element,
                orig     = current.orig,
                pos      = {},
                width    = 50,
                height   = 50,
                hPadding = current.hPadding,
                wPadding = current.wPadding,
                viewport = F.getViewport();

            if (!orig && current.isDom && element.is(':visible')) {
                orig = element.find('img:first');

                if (!orig.length) {
                    orig = element;
                }
            }

            if (isQuery(orig)) {
                pos = orig.offset();

                if (orig.is('img')) {
                    width  = orig.outerWidth();
                    height = orig.outerHeight();
                }

            } else {
                pos.top  = viewport.y + (viewport.h - height) * current.topRatio;
                pos.left = viewport.x + (viewport.w - width)  * current.leftRatio;
            }

            if (F.wrap.css('position') === 'fixed' || current.locked) {
                pos.top  -= viewport.y;
                pos.left -= viewport.x;
            }

            pos = {
                top     : getValue(pos.top  - hPadding * current.topRatio),
                left    : getValue(pos.left - wPadding * current.leftRatio),
                width   : getValue(width  + wPadding),
                height  : getValue(height + hPadding)
            };

            return pos;
        },

        step: function (now, fx) {
            var ratio,
                padding,
                value,
                prop       = fx.prop,
                current    = F.current,
                wrapSpace  = current.wrapSpace,
                skinSpace  = current.skinSpace;

            if (prop === 'width' || prop === 'height') {
                ratio = fx.end === fx.start ? 1 : (now - fx.start) / (fx.end - fx.start);

                if (F.isClosing) {
                    ratio = 1 - ratio;
                }

                padding = prop === 'width' ? current.wPadding : current.hPadding;
                value   = now - padding;

                F.skin[ prop ](  getScalar( prop === 'width' ?  value : value - (wrapSpace * ratio) ) );
                F.inner[ prop ]( getScalar( prop === 'width' ?  value : value - (wrapSpace * ratio) - (skinSpace * ratio) ) );
            }
        },

        zoomIn: function () {
            var current  = F.current,
                startPos = current.pos,
                effect   = current.openEffect,
                elastic  = effect === 'elastic',
                endPos   = $.extend({opacity : 1}, startPos);

            // Remove "position" property that breaks older IE
            delete endPos.position;

            if (elastic) {
                startPos = this.getOrigPosition();

                if (current.openOpacity) {
                    startPos.opacity = 0.1;
                }

            } else if (effect === 'fade') {
                startPos.opacity = 0.1;
            }

            F.wrap.css(startPos).animate(endPos, {
                duration : effect === 'none' ? 0 : current.openSpeed,
                easing   : current.openEasing,
                step     : elastic ? this.step : null,
                complete : F._afterZoomIn
            });
        },

        zoomOut: function () {
            var current  = F.current,
                effect   = current.closeEffect,
                elastic  = effect === 'elastic',
                endPos   = {opacity : 0.1};

            if (elastic) {
                endPos = this.getOrigPosition();

                if (current.closeOpacity) {
                    endPos.opacity = 0.1;
                }
            }

            F.wrap.animate(endPos, {
                duration : effect === 'none' ? 0 : current.closeSpeed,
                easing   : current.closeEasing,
                step     : elastic ? this.step : null,
                complete : F._afterZoomOut
            });
        },

        changeIn: function () {
            var current   = F.current,
                effect    = current.nextEffect,
                startPos  = current.pos,
                endPos    = { opacity : 1 },
                direction = F.direction,
                distance  = 200,
                field;

            startPos.opacity = 0.1;

            if (effect === 'elastic') {
                field = direction === 'down' || direction === 'up' ? 'top' : 'left';

                if (direction === 'down' || direction === 'right') {
                    startPos[ field ] = getValue(getScalar(startPos[ field ]) - distance);
                    endPos[ field ]   = '+=' + distance + 'px';

                } else {
                    startPos[ field ] = getValue(getScalar(startPos[ field ]) + distance);
                    endPos[ field ]   = '-=' + distance + 'px';
                }
            }

            // Workaround for http://bugs.jquery.com/ticket/12273
            if (effect === 'none') {
                F._afterZoomIn();

            } else {
                F.wrap.css(startPos).animate(endPos, {
                    duration : current.nextSpeed,
                    easing   : current.nextEasing,
                    complete : F._afterZoomIn
                });
            }
        },

        changeOut: function () {
            var previous  = F.previous,
                effect    = previous.prevEffect,
                endPos    = { opacity : 0.1 },
                direction = F.direction,
                distance  = 200;

            if (effect === 'elastic') {
                endPos[ direction === 'down' || direction === 'up' ? 'top' : 'left' ] = ( direction === 'up' || direction === 'left' ? '-' : '+' ) + '=' + distance + 'px';
            }

            previous.wrap.animate(endPos, {
                duration : effect === 'none' ? 0 : previous.prevSpeed,
                easing   : previous.prevEasing,
                complete : function () {
                    $(this).trigger('onReset').remove();
                }
            });
        }
    };

    /*
     *	Overlay helper
     */

    F.helpers.overlay = {
        defaults : {
            closeClick : true,      // if true, fancyBox will be closed when user clicks on the overlay
            speedOut   : 200,       // duration of fadeOut animation
            showEarly  : true,      // indicates if should be opened immediately or wait until the content is ready
            css        : {},        // custom CSS properties
            locked     : !isTouch,  // if true, the content will be locked into overlay
            fixed      : true       // if false, the overlay CSS position property will not be set to "fixed"
        },

        overlay : null,      // current handle
        fixed   : false,     // indicates if the overlay has position "fixed"
        el      : $('html'), // element that contains "the lock"

        // Public methods
        create : function(opts) {
            opts = $.extend({}, this.defaults, opts);

            if (this.overlay) {
                this.close();
            }

            this.overlay = $('<div class="fancybox-overlay"></div>').appendTo( F.coming ? F.coming.parent : opts.parent );
            this.fixed   = false;

            if (opts.fixed && F.defaults.fixed) {
                this.overlay.addClass('fancybox-overlay-fixed');

                this.fixed = true;
            }
        },

        open : function(opts) {
            var that = this;

            opts = $.extend({}, this.defaults, opts);

            if (this.overlay) {
                this.overlay.unbind('.overlay').width('auto').height('auto');

            } else {
                this.create(opts);
            }

            if (!this.fixed) {
                W.bind('resize.overlay', $.proxy( this.update, this) );

                this.update();
            }

            if (opts.closeClick) {
                this.overlay.bind('click.overlay', function(e) {
                    if ($(e.target).hasClass('fancybox-overlay')) {
                        if (F.isActive) {
                            F.close();
                        } else {
                            that.close();
                        }

                        return false;
                    }
                });
            }

            this.overlay.css( opts.css ).show();
        },

        close : function() {
            var scrollV, scrollH;

            W.unbind('resize.overlay');

            if (this.el.hasClass('fancybox-lock')) {
                $('.fancybox-margin').removeClass('fancybox-margin');

                scrollV = W.scrollTop();
                scrollH = W.scrollLeft();

                this.el.removeClass('fancybox-lock');

                W.scrollTop( scrollV ).scrollLeft( scrollH );
            }

            $('.fancybox-overlay').remove().hide();

            $.extend(this, {
                overlay : null,
                fixed   : false
            });
        },

        // Private, callbacks

        update : function () {
            var width = '100%', offsetWidth;

            // Reset width/height so it will not mess
            this.overlay.width(width).height('100%');

            // jQuery does not return reliable result for IE
            if (IE) {
                offsetWidth = Math.max(document.documentElement.offsetWidth, document.body.offsetWidth);

                if (D.width() > offsetWidth) {
                    width = D.width();
                }

            } else if (D.width() > W.width()) {
                width = D.width();
            }

            this.overlay.width(width).height(D.height());
        },

        // This is where we can manipulate DOM, because later it would cause iframes to reload
        onReady : function (opts, obj) {
            var overlay = this.overlay;

            $('.fancybox-overlay').stop(true, true);

            if (!overlay) {
                this.create(opts);
            }

            if (opts.locked && this.fixed && obj.fixed) {
                if (!overlay) {
                    this.margin = D.height() > W.height() ? $('html').css('margin-right').replace("px", "") : false;
                }

                obj.locked = this.overlay.append( obj.wrap );
                obj.fixed  = false;
            }

            if (opts.showEarly === true) {
                this.beforeShow.apply(this, arguments);
            }
        },

        beforeShow : function(opts, obj) {
            var scrollV, scrollH;

            if (obj.locked) {
                if (this.margin !== false) {
                    $('*').filter(function(){
                        return ($(this).css('position') === 'fixed' && !$(this).hasClass("fancybox-overlay") && !$(this).hasClass("fancybox-wrap") );
                    }).addClass('fancybox-margin');

                    this.el.addClass('fancybox-margin');
                }

                scrollV = W.scrollTop();
                scrollH = W.scrollLeft();

                this.el.addClass('fancybox-lock');

                W.scrollTop( scrollV ).scrollLeft( scrollH );
            }

            this.open(opts);
        },

        onUpdate : function() {
            if (!this.fixed) {
                this.update();
            }
        },

        afterClose: function (opts) {
            // Remove overlay if exists and fancyBox is not opening
            // (e.g., it is not being open using afterClose callback)
            //if (this.overlay && !F.isActive) {
            if (this.overlay && !F.coming) {
                this.overlay.fadeOut(opts.speedOut, $.proxy( this.close, this ));
            }
        }
    };

    /*
     *	Title helper
     */

    F.helpers.title = {
        defaults : {
            type     : 'float', // 'float', 'inside', 'outside' or 'over',
            position : 'bottom' // 'top' or 'bottom'
        },

        beforeShow: function (opts) {
            var current = F.current,
                text    = current.title,
                type    = opts.type,
                title,
                target;

            if ($.isFunction(text)) {
                text = text.call(current.element, current);
            }

            if (!isString(text) || $.trim(text) === '') {
                return;
            }

            title = $('<div class="fancybox-title fancybox-title-' + type + '-wrap">' + text + '</div>');

            switch (type) {
                case 'inside':
                    target = F.skin;
                    break;

                case 'outside':
                    target = F.wrap;
                    break;

                case 'over':
                    target = F.inner;
                    break;

                default: // 'float'
                    target = F.skin;

                    title.appendTo('body');

                    if (IE) {
                        title.width( title.width() );
                    }

                    title.wrapInner('<span class="child"></span>');

                    //Increase bottom margin so this title will also fit into viewport
                    F.current.margin[2] += Math.abs( getScalar(title.css('margin-bottom')) );
                    break;
            }

            title[ (opts.position === 'top' ? 'prependTo'  : 'appendTo') ](target);
        }
    };

    // jQuery plugin initialization
    $.fn.fancybox = function (options) {
        var index,
            that     = $(this),
            selector = this.selector || '',
            run      = function(e) {
                var what = $(this).blur(), idx = index, relType, relVal;

                if (!(e.ctrlKey || e.altKey || e.shiftKey || e.metaKey) && !what.is('.fancybox-wrap')) {
                    relType = options.groupAttr || 'data-fancybox-group';
                    relVal  = what.attr(relType);

                    if (!relVal) {
                        relType = 'rel';
                        relVal  = what.get(0)[ relType ];
                    }

                    if (relVal && relVal !== '' && relVal !== 'nofollow') {
                        what = selector.length ? $(selector) : that;
                        what = what.filter('[' + relType + '="' + relVal + '"]');
                        idx  = what.index(this);
                    }

                    options.index = idx;

                    // Stop an event from bubbling if everything is fine
                    if (F.open(what, options) !== false) {
                        e.preventDefault();
                    }
                }
            };

        options = options || {};
        index   = options.index || 0;

        if (!selector || options.live === false) {
            that.unbind('click.fb-start').bind('click.fb-start', run);

        } else {
            D.undelegate(selector, 'click.fb-start').delegate(selector + ":not('.fancybox-item, .fancybox-nav')", 'click.fb-start', run);
        }

        this.filter('[data-fancybox-start=1]').trigger('click');

        return this;
    };

    // Tests that need a body at doc ready
    D.ready(function() {
        var w1, w2;

        if ( $.scrollbarWidth === undefined ) {
            // http://benalman.com/projects/jquery-misc-plugins/#scrollbarwidth
            $.scrollbarWidth = function() {
                var parent = $('<div style="width:50px;height:50px;overflow:auto"><div/></div>').appendTo('body'),
                    child  = parent.children(),
                    width  = child.innerWidth() - child.height( 99 ).innerWidth();

                parent.remove();

                return width;
            };
        }

        if ( $.support.fixedPosition === undefined ) {
            $.support.fixedPosition = (function() {
                var elem  = $('<div style="position:fixed;top:20px;"></div>').appendTo('body'),
                    fixed = ( elem[0].offsetTop === 20 || elem[0].offsetTop === 15 );

                elem.remove();

                return fixed;
            }());
        }

        $.extend(F.defaults, {
            scrollbarWidth : $.scrollbarWidth(),
            fixed  : $.support.fixedPosition,
            parent : $('body')
        });

        //Get real width of page scroll-bar
        w1 = $(window).width();

        H.addClass('fancybox-lock-test');

        w2 = $(window).width();

        H.removeClass('fancybox-lock-test');

        $("<style type='text/css'>.fancybox-margin{margin-right:" + (w2 - w1) + "px;}</style>").appendTo("head");
    });

}(window, document, jQuery));

/*!
 * Bootstrap v3.3.5 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */

/*!
 * Generated using the Bootstrap Customizer (http://bootstrap-3.ru/customize.php?id=b02da3ea73b19de3f21a)
 * Config saved to config.json and https://gist.github.com/b02da3ea73b19de3f21a
 */
if("undefined"==typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery");+function(t){"use strict";var e=t.fn.jquery.split(" ")[0].split(".");if(e[0]<2&&e[1]<9||1==e[0]&&9==e[1]&&e[2]<1)throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher")}(jQuery),+function(t){"use strict";function e(e){return this.each(function(){var i=t(this),n=i.data("bs.alert");n||i.data("bs.alert",n=new o(this)),"string"==typeof e&&n[e].call(i)})}var i='[data-dismiss="alert"]',o=function(e){t(e).on("click",i,this.close)};o.VERSION="3.3.5",o.TRANSITION_DURATION=150,o.prototype.close=function(e){function i(){a.detach().trigger("closed.bs.alert").remove()}var n=t(this),s=n.attr("data-target");s||(s=n.attr("href"),s=s&&s.replace(/.*(?=#[^\s]*$)/,""));var a=t(s);e&&e.preventDefault(),a.length||(a=n.closest(".alert")),a.trigger(e=t.Event("close.bs.alert")),e.isDefaultPrevented()||(a.removeClass("in"),t.support.transition&&a.hasClass("fade")?a.one("bsTransitionEnd",i).emulateTransitionEnd(o.TRANSITION_DURATION):i())};var n=t.fn.alert;t.fn.alert=e,t.fn.alert.Constructor=o,t.fn.alert.noConflict=function(){return t.fn.alert=n,this},t(document).on("click.bs.alert.data-api",i,o.prototype.close)}(jQuery),+function(t){"use strict";function e(e){return this.each(function(){var o=t(this),n=o.data("bs.button"),s="object"==typeof e&&e;n||o.data("bs.button",n=new i(this,s)),"toggle"==e?n.toggle():e&&n.setState(e)})}var i=function(e,o){this.$element=t(e),this.options=t.extend({},i.DEFAULTS,o),this.isLoading=!1};i.VERSION="3.3.5",i.DEFAULTS={loadingText:"loading..."},i.prototype.setState=function(e){var i="disabled",o=this.$element,n=o.is("input")?"val":"html",s=o.data();e+="Text",null==s.resetText&&o.data("resetText",o[n]()),setTimeout(t.proxy(function(){o[n](null==s[e]?this.options[e]:s[e]),"loadingText"==e?(this.isLoading=!0,o.addClass(i).attr(i,i)):this.isLoading&&(this.isLoading=!1,o.removeClass(i).removeAttr(i))},this),0)},i.prototype.toggle=function(){var t=!0,e=this.$element.closest('[data-toggle="buttons"]');if(e.length){var i=this.$element.find("input");"radio"==i.prop("type")?(i.prop("checked")&&(t=!1),e.find(".active").removeClass("active"),this.$element.addClass("active")):"checkbox"==i.prop("type")&&(i.prop("checked")!==this.$element.hasClass("active")&&(t=!1),this.$element.toggleClass("active")),i.prop("checked",this.$element.hasClass("active")),t&&i.trigger("change")}else this.$element.attr("aria-pressed",!this.$element.hasClass("active")),this.$element.toggleClass("active")};var o=t.fn.button;t.fn.button=e,t.fn.button.Constructor=i,t.fn.button.noConflict=function(){return t.fn.button=o,this},t(document).on("click.bs.button.data-api",'[data-toggle^="button"]',function(i){var o=t(i.target);o.hasClass("btn")||(o=o.closest(".btn")),e.call(o,"toggle"),t(i.target).is('input[type="radio"]')||t(i.target).is('input[type="checkbox"]')||i.preventDefault()}).on("focus.bs.button.data-api blur.bs.button.data-api",'[data-toggle^="button"]',function(e){t(e.target).closest(".btn").toggleClass("focus",/^focus(in)?$/.test(e.type))})}(jQuery),+function(t){"use strict";function e(e){return this.each(function(){var o=t(this),n=o.data("bs.affix"),s="object"==typeof e&&e;n||o.data("bs.affix",n=new i(this,s)),"string"==typeof e&&n[e]()})}var i=function(e,o){this.options=t.extend({},i.DEFAULTS,o),this.$target=t(this.options.target).on("scroll.bs.affix.data-api",t.proxy(this.checkPosition,this)).on("click.bs.affix.data-api",t.proxy(this.checkPositionWithEventLoop,this)),this.$element=t(e),this.affixed=null,this.unpin=null,this.pinnedOffset=null,this.checkPosition()};i.VERSION="3.3.5",i.RESET="affix affix-top affix-bottom",i.DEFAULTS={offset:0,target:window},i.prototype.getState=function(t,e,i,o){var n=this.$target.scrollTop(),s=this.$element.offset(),a=this.$target.height();if(null!=i&&"top"==this.affixed)return i>n?"top":!1;if("bottom"==this.affixed)return null!=i?n+this.unpin<=s.top?!1:"bottom":t-o>=n+a?!1:"bottom";var r=null==this.affixed,f=r?n:s.top,l=r?a:e;return null!=i&&i>=n?"top":null!=o&&f+l>=t-o?"bottom":!1},i.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(i.RESET).addClass("affix");var t=this.$target.scrollTop(),e=this.$element.offset();return this.pinnedOffset=e.top-t},i.prototype.checkPositionWithEventLoop=function(){setTimeout(t.proxy(this.checkPosition,this),1)},i.prototype.checkPosition=function(){if(this.$element.is(":visible")){var e=this.$element.height(),o=this.options.offset,n=o.top,s=o.bottom,a=Math.max(t(document).height(),t(document.body).height());"object"!=typeof o&&(s=n=o),"function"==typeof n&&(n=o.top(this.$element)),"function"==typeof s&&(s=o.bottom(this.$element));var r=this.getState(a,e,n,s);if(this.affixed!=r){null!=this.unpin&&this.$element.css("top","");var f="affix"+(r?"-"+r:""),l=t.Event(f+".bs.affix");if(this.$element.trigger(l),l.isDefaultPrevented())return;this.affixed=r,this.unpin="bottom"==r?this.getPinnedOffset():null,this.$element.removeClass(i.RESET).addClass(f).trigger(f.replace("affix","affixed")+".bs.affix")}"bottom"==r&&this.$element.offset({top:a-e-s})}};var o=t.fn.affix;t.fn.affix=e,t.fn.affix.Constructor=i,t.fn.affix.noConflict=function(){return t.fn.affix=o,this},t(window).on("load",function(){t('[data-spy="affix"]').each(function(){var i=t(this),o=i.data();o.offset=o.offset||{},null!=o.offsetBottom&&(o.offset.bottom=o.offsetBottom),null!=o.offsetTop&&(o.offset.top=o.offsetTop),e.call(i,o)})})}(jQuery);

$(document).ready(function(){

    window.BXReady.Market.Menu =  {

        flexButtonWidth: 50,
        fixedTop: 0,
        fixedHeight: 0,

        init: function(){
            window.BXReady.Market.Menu.resize();
            if($('ul.bxr-flex-menu').is('.menu-level2'))
                window.BXReady.Market.Menu.resizeLevel2();
            window.BXReady.Market.Menu.resizeWidth();
            window.BXReady.Market.Menu.searchForm();
            window.BXReady.Market.Menu.fixed();
            window.BXReady.Market.Menu.createMobileMenu();

            $(window).resize(function() {
                window.BXReady.Market.Menu.resize();
                if($('ul.bxr-flex-menu').is('.menu-level2'))
                    window.BXReady.Market.Menu.resizeLevel2();
                window.BXReady.Market.Menu.resizeWidth();
                //window.BXReady.Market.Menu.fixed();
            });

        },

        showMenu: function() {
            var menu = $('.bxr-top-menu');
            menu.css("visibility", "visible");
            menu.data("visibility", "1");
        },

        resizeWidth: function() {
            fullWidth = $('ul.bxr-flex-menu').width();
            fullLiWidth = 0;
            p1 = 0;
            i = 0;
            j = 0;

            $('ul.bxr-flex-menu > li:visible').each(function(){
                if($(this).is(".other") || $(this).is(".li-visible"))
                    ++j;
                else {
                    ++i;
                    fullLiWidth += $(this).width();
                }
            });

            p1 = fullWidth/100;
            lastElement = 0;

            if($('.bxr-top-menu > li.other').is(":visible"))
                lastElement += 55;

            if($('.bxr-top-menu > li.li-visible').length > 0)
                lastElement += 50;

            width = (fullWidth-fullLiWidth-lastElement)/i;

            $('ul.bxr-flex-menu > li:visible').each(function(){
                w = 0;
                if(!$(this).is(".other") && !$(this).is(".li-visible")) {
                    w = Math.floor(($(this).width()+width)/p1);
                    w = Math.floor(($(this).width()+width));
                    fullLiWidth += $(this).width(w+"px");
                }
            });

            window.BXReady.Market.Menu.showMenu();

        },

        fixed: function(){

            fixedElement = $('ul.bxr-flex-menu').parents(".bxr-v-line_menu");

            if( fixedElement.data("fixed") != "Y" )
                return;

            fixedElement = fixedElement.parents(".bxr-menuline");

            fixedTop = fixedElement.offset().top;

            fixedElement.on('affix.bs.affix', function () {
                $(this).css({"box-shadow": "0 1px 5px rgba(0, 0, 0, 0.136)"});
            });

            fixedElement.on('affix-top.bs.affix', function () {
                $(".bxr-full-width.bxr-top-headline.affix").removeClass("affix-fixed");
                $(this).css({"box-shadow": "none"});
            });

            var windowHeight = $(window).height();
            var bodyHeight = $(document).height();

            if(bodyHeight>(950+fixedElement.height())) {
                fixedElement.affix({
                    offset: {
                        top: function(e) {
                            $(".title-search-result").hide();
                            curTop = $(".bxr-full-width.bxr-top-headline.affix").height() + $("#panel").height();
                            e.css({"top": curTop + "px", "z-index": "1015"});
                            return fixedTop;
                        }
                    }
                });

                fixedElement.on('affix.bs.affix', function () {
                    $(".bxr-full-width.bxr-top-headline.affix").addClass("affix-fixed");
                    var tWirth = $(document).width();
                    if(tWirth==0)
                        tWirth =screen.width;

                    if (tWirth<992) {
                        $(this).css({"box-shadow": "none"});
                        $(this).removeClass('affix');
                        return false;
                    }
                });
            }

        },

        resizeLevel2: function() {
            stock = 100;
            line = $('ul.bxr-flex-menu > .selected > ul');
            fullWidth = $('ul.bxr-flex-menu').width()-stock;

            var tWirth = window.outerWidth;
            if(tWirth==0)
                tWirth =screen.width;

            if (tWirth<768 && $('ul.bxr-flex-menu').css('display') != 'none') {
                return;
            }

            allWidth = 0;
            displayWidth = 0;
            flagFull = false;
            e = 0;

            line.find('>li').each(function(){
                allWidth += $(this).width();
                if(fullWidth>allWidth) {
                    ++e;
                    displayWidth += $(this).width();
                }
            });

            line.find('>li:lt(' + (e) + ')').css("display", "block");

            if(fullWidth<allWidth)
                flagFull = true;

            if(displayWidth!=0) {
                $('ul.bxr-flex-menu').height(81);
            }

            if (flagFull){
                line.find(".level2").remove();
                addHTML = '<li class="level2"><a href="#"><span class="glyphicon glyphicon-option-horizontal"></span></a>';
                strAddUL = '<ul>';

                line.find('>li:gt(' + (e-1) + ')').each(function(){

                    $(this).css("display", "none");
                    strAddUL += '<li class="l-2">'+$(this).children('a').get(0).outerHTML+'</li>';
                });

                strAddUL += '</ul></li>';
                $('ul.bxr-flex-menu > .selected > ul').append(addHTML+strAddUL);
                leve2Width = $('.level2 > ul').width();

                if((displayWidth+leve2Width)>(fullWidth+stock))
                    $('.level2 > ul').css("left", (fullWidth-displayWidth-leve2Width+stock)+"px");

            }
        },

        resize: function(){

            $('ul.bxr-flex-menu').css('width', '100%');
            fullWidth = $('ul.bxr-flex-menu').width();

            var tWirth = window.outerWidth;
            if(tWirth==0)
                tWirth =screen.width;

            if (tWirth <768 && $('ul.flex-menu').css('display') != 'none') {
                return;
            }

            $('ul.bxr-flex-menu>li').each(function(){
                $(this).css('display','block');
                if (!$(this).is('.other') && !$(this).is('.li-visible'))
                    $(this).css('width','auto');
            });

            $('#bxr-flex-menu-li').css('display','none');


            maxWidth = $('ul.bxr-flex-menu').width()-30-window.BXReady.Market.Menu.flexButtonWidth;

            allWidth = 0;
            flagFull = false;
            lastFull = false;

            $('ul.bxr-flex-menu > li > ul > li').each(function(){
                if ($(this).children( "ul").length>0){
                    $(this).children( "a").addClass('sub-item');
                }
            });


            $('ul.bxr-flex-menu>li>a').each(function(){

                lastFull = $(this);

                $(this).data('visible', 1);
                $(this).parent().data('visible', 1);

                if ($(this).is('#bxr-flex-menu-li')){
                    $(this).parent().css('width', window.BXReady.Market.Menu.lastItemWidth+'px');
                }

                if (!$(this).is('#bxr-flex-menu-li') && !flagFull){
                    if ($(this).parent().css('display') == 'none'){
                        $(this).parent().css('display', 'block');
                    }

                    oldWidth = allWidth;
                    paddingAdd = 0;

                    if ($(this).parent().children( "ul").length>0){
                        $(this).addClass('sub-item');
                    }

                    paddingAdd = parseInt($(this).css('padding-left'))+parseInt($(this).css('padding-right'));
                    allWidth += $(this).width()+ paddingAdd+2;

                    if (maxWidth<allWidth){
                        allWidth = oldWidth;
                        $(this).parent().css('display', 'none');
                        flagFull = true;
                        $(this).data('visible', 0);
                        $(this).parent().data('visible', 0);
                    }
                }else{
                    $(this).parent().css('display', 'none');
                    $(this).data('visible', 0);
                    $(this).parent().data('visible', 0);
                }

            });


            if (!flagFull){
                delta = 0;
                if ($('ul.bxr-flex-menu').hasClass('compound')){
                    $('ul.bxr-flex-menu').css({
                        'width':(allWidth)+'px',
                        'float': 'right'
                    });
                    lastFull.parent().addClass('last');
                }
                $('ul.bxr-flex-menu').css('overflow','visible');
                return;
            }else{
                enableWidth = maxWidth - window.BXReady.Market.Menu.flexButtonWidth;
            }

            if (flagFull){
                $('#bxr-flex-menu-li').css('width', window.BXReady.Market.Menu.flexButtonWidth+'px').css('display', 'block');
                $('#bxr-flex-menu-li').html('');
                addHTML = '<a href="#"><span class="fa fa-ellipsis-h"></span></a>';
                strAddUL = '<ul>';

                divMenu = "bxr-top-menu-other";
                if($("ul.bxr-top-menu").data("style-menu") == "colored_light")
                    divMenu += " menu-arrow-top";

                liHover = "";
                switch ($("ul.bxr-top-menu").data("style-menu-hover")) {
                    case "colored_color": liHover = "bxr-color-flat bxr-bg-hover-dark-flat"; break;
                    case "colored_light": liHover = "bxr-bg-hover-flat"; break;
                }

                var ie = 0;
                $('ul.bxr-flex-menu>li').each(function(){

                    if (
                        !$(this).is('.other')
                        && !$(this).is('.li-visible')
                        && $(this).data('visible') == 0){
                        strAddUL += '<li class="l-2 ' + liHover + '">'+$(this).children('a').get(0).outerHTML+'</li>';
                        ++ie;
                    }
                });

                $('.li-visible').css('display', 'inline-block');

                strAddUL += '</ul>';
                strAddUL = "<div class='" + divMenu + "'>"+strAddUL+"</div>";

                $('#bxr-flex-menu-li').html(addHTML+strAddUL);
                otherWidth = $('.other').width();
                otherUlWidth = $('.other > ul').width();
                $('.other > ul').css('left', (otherWidth - otherUlWidth));
                if(ie == 0)
                    $('#bxr-flex-menu-li').css('display', 'none');
            }else{
                $('#bxr-flex-menu-li').css('display', 'none');
                lastFull.parent().addClass("last");
            }


            if ($('ul.bxr-flex-menu').hasClass('compound')){
                $('ul.bxr-flex-menu').css({
                    'width':allWidth+40+window.BXReady.Market.Menu.flexButtonWidth+'px',
                    'float': 'right'
                });
            }

            $('ul.bxr-flex-menu').css('overflow','visible');

            if ($('ul.bxr-flex-menu').hasClass('compound')){
                $('ul.bxr-flex-menu').css({
                    'width':'auto',
                    'height': 'auto'
                });
            }
        },

        searchForm: function(){
            $("ul.bxr-flex-menu  > li .fa-search").parents("a").on('click', function(){
                e = $('#search-line').parents(".dcontainer").find(".dcontainer");
                e = $('#bxr-menu-search-line');

                if(e.is(":visible"))
                    e.fadeOut();
                else
                    e.fadeIn();

                return false;
            });

            $("#search-line .big_search").on('click', function(){
                e = $('#search-line').parents(".dcontainer").find(".dcontainer");
                m = $('.dcontainer-search-form').parents(".dcontainer").find("> .container");
                e.css("display", "none");
                m.css("display", "block");
                return false;
            });
        },


        createMobileMenu: function(){
            addHTML='<div id="bxr-mobile-menu-content">';

            identity = 0;
            submenyHTML = "";
            $('ul.bxr-flex-menu>li').each(function(){
                identity++;
                if ($(this).data('nomobile') != 1 && !$(this).is('#bxr-flex-menu-li') && !$(this).is('.li-visible')){
                    addNode = false;
                    submenyHTML += '<div class="bxr-children-color-hover" data-main="1" data-active="0" data-item="'+identity+'">';
                    submenyHTML += $(this).children( "a").get(0).outerHTML;
                    submenyHTML += '</div>';

                    if ($(this).children("div").children("ul").length>0){
                        addNode = true;
                        submenyHTML += '<div class="submenu_item" data-parent="'+identity+'">';
                        $(this).children("div").children( "ul").children("li").each(function(){
                            textThis = $(this).clone();
                            textThis.find("img").remove();
                            textThis.find("ul").remove();
                            textThis.find("i").remove();
                            submenyHTML += "<div class='bxr-children-color-hover'>" + textThis.html() + "</div>";
                        });
                        submenyHTML += '</div>';
                    } else if ($(this).children("div.bxr-list-hover-menu").children("div.bxr-element-hover-menu").length > 0) {
                        addNode = true;
                        submenyHTML += '<div class="submenu_item" data-parent="'+identity+'">';
                        $(this).children("div.bxr-list-hover-menu").children("div.bxr-element-hover-menu").each(function(){
                            textThis = $(this).children(".bxr-element-content").clone();
                            textThis.find("img").remove();
                            textThis.find("ul").remove();
                            textThis.find("i").remove();
                            submenyHTML += "<div class='bxr-children-color-hover'>" + textThis.html() + "</div>";
                        });
                        submenyHTML += '</div>';
                    }
                }
            });

            addHTML +=submenyHTML+'</div><div class="clearfix"></div>';

            $('#bxr-mobile-menu-body').html(addHTML);
            $('#bxr-mobile-menu-body div.submenu_item').each(function(){
                $('#bxr-mobile-menu-body div[data-item='+$(this).data('parent')+']').children('a').addClass('sub-item');
            });
            this.initMobileMenuEvents();
            $('#bxr-mobile-menu-body div').each(function(){
                if($(this).data("parent")!=undefined)
                    $(this).find("span").remove();
            });
        },

        initMobileMenuEvents: function(){
            $(document).on(
                'click',
                '#bxr-menuitem',
                function(){
                    if ($('#bxr-mobile-menu-content').css('display') == 'none'){
                        $('#bxr-mobile-menu-content').slideDown(200);
                    }else{
                        $('#bxr-mobile-menu-content').slideUp(200);
                    }
                }
            );

            $(document).on(
                'click',
                '#bxr-menu-search-form',
                function(){
                    if ($('.bxs-search-mobil-menu').css('display') == 'none'){
                        $('.bxs-search-mobil-menu').slideDown(200);
                    }else{
                        $('.bxs-search-mobil-menu').slideUp(200);
                    }
                }
            );

            $(document).on(
                'click',
                '#bxr-mobile-menu-content > div > a.sub-item',
                function(){
                    if ($(this).parent().is('div.submenu_item'))
                        return;

                    nItem = $(this).parent().data('item');

                    if ($(this).data('show') == 1){
                        var element = this;
                        $("div [data-parent="+nItem+"]").slideUp(200, function(){
                            pItem = $("div [data-item="+nItem+"]").children('a');
                            pItem.data('show', 0);
                            pItem.removeClass('hover');
                            pItem.parent("div").removeClass("bxr-color-flat");
                        });
                    }else{
                        $("div [data-parent="+nItem+"]").slideDown(200, function(){
                            pItem = $("div [data-item="+nItem+"]").children('a');
                            pItem.data('show', 1);
                            pItem.addClass('hover');
                            pItem.parent("div").addClass("bxr-color-flat");
                        });
                    }

                    return false;
                }
            );
        }

    }

    $(document).ready(function(){
        window.BXReady.Market.Menu.init();
    });
});

/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.5.7
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
/* global window, document, define, jQuery, setInterval, clearInterval */
(function(factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports !== 'undefined') {
        module.exports = factory(require('jquery'));
    } else {
        factory(jQuery);
    }

}(function($) {
    'use strict';
    var Slick = window.Slick || {};

    Slick = (function() {

        var instanceUid = 0;

        function Slick(element, settings) {

            var _ = this, dataSettings;

            _.defaults = {
                accessibility: true,
                adaptiveHeight: false,
                appendArrows: $(element),
                appendDots: $(element),
                arrows: true,
                asNavFor: null,
                prevArrow: '<button type="button" data-role="none" class="slick-prev" aria-label="Previous" tabindex="0" role="button">Previous</button>',
                nextArrow: '<button type="button" data-role="none" class="slick-next" aria-label="Next" tabindex="0" role="button">Next</button>',
                autoplay: false,
                autoplaySpeed: 3000,
                centerMode: false,
                centerPadding: '50px',
                cssEase: 'ease',
                customPaging: function(slider, i) {
                    return '<button type="button" data-role="none" role="button" aria-required="false" tabindex="0">' + (i + 1) + '</button>';
                },
                dots: false,
                dotsClass: 'slick-dots',
                draggable: true,
                easing: 'linear',
                edgeFriction: 0.35,
                fade: false,
                focusOnSelect: false,
                infinite: true,
                initialSlide: 0,
                lazyLoad: 'ondemand',
                mobileFirst: false,
                pauseOnHover: true,
                pauseOnDotsHover: false,
                respondTo: 'window',
                responsive: null,
                rows: 1,
                rtl: false,
                slide: '',
                slidesPerRow: 1,
                slidesToShow: 1,
                slidesToScroll: 1,
                speed: 500,
                swipe: true,
                swipeToSlide: false,
                touchMove: true,
                touchThreshold: 5,
                useCSS: true,
                variableWidth: false,
                vertical: false,
                verticalSwiping: false,
                waitForAnimate: true,
                zIndex: 1000
            };

            _.initials = {
                animating: false,
                dragging: false,
                autoPlayTimer: null,
                currentDirection: 0,
                currentLeft: null,
                currentSlide: 0,
                direction: 1,
                $dots: null,
                listWidth: null,
                listHeight: null,
                loadIndex: 0,
                $nextArrow: null,
                $prevArrow: null,
                slideCount: null,
                slideWidth: null,
                $slideTrack: null,
                $slides: null,
                sliding: false,
                slideOffset: 0,
                swipeLeft: null,
                $list: null,
                touchObject: {},
                transformsEnabled: false,
                unslicked: false
            };

            $.extend(_, _.initials);

            _.activeBreakpoint = null;
            _.animType = null;
            _.animProp = null;
            _.breakpoints = [];
            _.breakpointSettings = [];
            _.cssTransitions = false;
            _.hidden = 'hidden';
            _.paused = false;
            _.positionProp = null;
            _.respondTo = null;
            _.rowCount = 1;
            _.shouldClick = true;
            _.$slider = $(element);
            _.$slidesCache = null;
            _.transformType = null;
            _.transitionType = null;
            _.visibilityChange = 'visibilitychange';
            _.windowWidth = 0;
            _.windowTimer = null;

            dataSettings = $(element).data('slick') || {};

            _.options = $.extend({}, _.defaults, dataSettings, settings);

            _.currentSlide = _.options.initialSlide;

            _.originalSettings = _.options;

            if (typeof document.mozHidden !== 'undefined') {
                _.hidden = 'mozHidden';
                _.visibilityChange = 'mozvisibilitychange';
            } else if (typeof document.webkitHidden !== 'undefined') {
                _.hidden = 'webkitHidden';
                _.visibilityChange = 'webkitvisibilitychange';
            }

            _.autoPlay = $.proxy(_.autoPlay, _);
            _.autoPlayClear = $.proxy(_.autoPlayClear, _);
            _.changeSlide = $.proxy(_.changeSlide, _);
            _.clickHandler = $.proxy(_.clickHandler, _);
            _.selectHandler = $.proxy(_.selectHandler, _);
            _.setPosition = $.proxy(_.setPosition, _);
            _.swipeHandler = $.proxy(_.swipeHandler, _);
            _.dragHandler = $.proxy(_.dragHandler, _);
            _.keyHandler = $.proxy(_.keyHandler, _);
            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);

            _.instanceUid = instanceUid++;

            // A simple way to check for HTML strings
            // Strict HTML recognition (must start with <)
            // Extracted from jQuery v1.11 source
            _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;


            _.registerBreakpoints();
            _.init(true);
            _.checkResponsive(true);

        }

        return Slick;

    }());

    Slick.prototype.addSlide = Slick.prototype.slickAdd = function(markup, index, addBefore) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            addBefore = index;
            index = null;
        } else if (index < 0 || (index >= _.slideCount)) {
            return false;
        }

        _.unload();

        if (typeof(index) === 'number') {
            if (index === 0 && _.$slides.length === 0) {
                $(markup).appendTo(_.$slideTrack);
            } else if (addBefore) {
                $(markup).insertBefore(_.$slides.eq(index));
            } else {
                $(markup).insertAfter(_.$slides.eq(index));
            }
        } else {
            if (addBefore === true) {
                $(markup).prependTo(_.$slideTrack);
            } else {
                $(markup).appendTo(_.$slideTrack);
            }
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slides.each(function(index, element) {
            $(element).attr('data-slick-index', index);
        });

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.animateHeight = function() {
        var _ = this;
        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.animate({
                height: targetHeight
            }, _.options.speed);
        }
    };

    Slick.prototype.animateSlide = function(targetLeft, callback) {

        var animProps = {},
            _ = this;

        _.animateHeight();

        if (_.options.rtl === true && _.options.vertical === false) {
            targetLeft = -targetLeft;
        }
        if (_.transformsEnabled === false) {
            if (_.options.vertical === false) {
                _.$slideTrack.animate({
                    left: targetLeft
                }, _.options.speed, _.options.easing, callback);
            } else {
                _.$slideTrack.animate({
                    top: targetLeft
                }, _.options.speed, _.options.easing, callback);
            }

        } else {

            if (_.cssTransitions === false) {
                if (_.options.rtl === true) {
                    _.currentLeft = -(_.currentLeft);
                }
                $({
                    animStart: _.currentLeft
                }).animate({
                    animStart: targetLeft
                }, {
                    duration: _.options.speed,
                    easing: _.options.easing,
                    step: function(now) {
                        now = Math.ceil(now);
                        if (_.options.vertical === false) {
                            animProps[_.animType] = 'translate(' +
                                now + 'px, 0px)';
                            _.$slideTrack.css(animProps);
                        } else {
                            animProps[_.animType] = 'translate(0px,' +
                                now + 'px)';
                            _.$slideTrack.css(animProps);
                        }
                    },
                    complete: function() {
                        if (callback) {
                            callback.call();
                        }
                    }
                });

            } else {

                _.applyTransition();
                targetLeft = Math.ceil(targetLeft);

                if (_.options.vertical === false) {
                    animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
                } else {
                    animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
                }
                _.$slideTrack.css(animProps);

                if (callback) {
                    setTimeout(function() {

                        _.disableTransition();

                        callback.call();
                    }, _.options.speed);
                }

            }

        }

    };

    Slick.prototype.asNavFor = function(index) {

        var _ = this,
            asNavFor = _.options.asNavFor;

        if ( asNavFor && asNavFor !== null ) {
            asNavFor = $(asNavFor).not(_.$slider);
        }

        if ( asNavFor !== null && typeof asNavFor === 'object' ) {
            asNavFor.each(function() {
                var target = $(this).slick('getSlick');
                if(!target.unslicked) {
                    target.slideHandler(index, true);
                }
            });
        }

    };

    Slick.prototype.applyTransition = function(slide) {

        var _ = this,
            transition = {};

        if (_.options.fade === false) {
            transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
        } else {
            transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
        }

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.autoPlay = function() {

        var _ = this;

        if (_.autoPlayTimer) {
            clearInterval(_.autoPlayTimer);
        }

        if (_.slideCount > _.options.slidesToShow && _.paused !== true) {
            _.autoPlayTimer = setInterval(_.autoPlayIterator,
                _.options.autoplaySpeed);
        }

    };

    Slick.prototype.autoPlayClear = function() {

        var _ = this;
        if (_.autoPlayTimer) {
            clearInterval(_.autoPlayTimer);
        }

    };

    Slick.prototype.autoPlayIterator = function() {

        var _ = this;

        if (_.options.infinite === false) {

            if (_.direction === 1) {

                if ((_.currentSlide + 1) === _.slideCount -
                    1) {
                    _.direction = 0;
                }

                _.slideHandler(_.currentSlide + _.options.slidesToScroll);

            } else {

                if ((_.currentSlide - 1 === 0)) {

                    _.direction = 1;

                }

                _.slideHandler(_.currentSlide - _.options.slidesToScroll);

            }

        } else {

            _.slideHandler(_.currentSlide + _.options.slidesToScroll);

        }

    };

    Slick.prototype.buildArrows = function() {

        var _ = this;

        if (_.options.arrows === true ) {

            _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
            _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');

            if( _.slideCount > _.options.slidesToShow ) {

                _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');
                _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

                if (_.htmlExpr.test(_.options.prevArrow)) {
                    _.$prevArrow.prependTo(_.options.appendArrows);
                }

                if (_.htmlExpr.test(_.options.nextArrow)) {
                    _.$nextArrow.appendTo(_.options.appendArrows);
                }

                if (_.options.infinite !== true) {
                    _.$prevArrow
                        .addClass('slick-disabled')
                        .attr('aria-disabled', 'true');
                }

            } else {

                _.$prevArrow.add( _.$nextArrow )

                    .addClass('slick-hidden')
                    .attr({
                        'aria-disabled': 'true',
                        'tabindex': '-1'
                    });

            }

        }

    };

    Slick.prototype.buildDots = function() {

        var _ = this,
            i, dotString;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            dotString = '<ul class="' + _.options.dotsClass + '">';

            for (i = 0; i <= _.getDotCount(); i += 1) {
                dotString += '<li>' + _.options.customPaging.call(this, _, i) + '</li>';
            }

            dotString += '</ul>';

            _.$dots = $(dotString).appendTo(
                _.options.appendDots);

            _.$dots.find('li').first().addClass('slick-active').attr('aria-hidden', 'false');

        }

    };

    Slick.prototype.buildOut = function() {

        var _ = this;

        _.$slides =
            _.$slider
                .children( _.options.slide + ':not(.slick-cloned)')
                .addClass('slick-slide');

        _.slideCount = _.$slides.length;

        _.$slides.each(function(index, element) {
            $(element)
                .attr('data-slick-index', index)
                .data('originalStyling', $(element).attr('style') || '');
        });

        _.$slidesCache = _.$slides;

        _.$slider.addClass('slick-slider');

        _.$slideTrack = (_.slideCount === 0) ?
            $('<div class="slick-track"/>').appendTo(_.$slider) :
            _.$slides.wrapAll('<div class="slick-track"/>').parent();

        _.$list = _.$slideTrack.wrap(
            '<div aria-live="polite" class="slick-list"/>').parent();
        _.$slideTrack.css('opacity', 0);

        if (_.options.centerMode === true || _.options.swipeToSlide === true) {
            _.options.slidesToScroll = 1;
        }

        $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

        _.setupInfinite();

        _.buildArrows();

        _.buildDots();

        _.updateDots();


        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        if (_.options.draggable === true) {
            _.$list.addClass('draggable');
        }

    };

    Slick.prototype.buildRows = function() {

        var _ = this, a, b, c, newSlides, numOfSlides, originalSlides,slidesPerSection;

        newSlides = document.createDocumentFragment();
        originalSlides = _.$slider.children();

        if(_.options.rows > 1) {

            slidesPerSection = _.options.slidesPerRow * _.options.rows;
            numOfSlides = Math.ceil(
                originalSlides.length / slidesPerSection
            );

            for(a = 0; a < numOfSlides; a++){
                var slide = document.createElement('div');
                for(b = 0; b < _.options.rows; b++) {
                    var row = document.createElement('div');
                    for(c = 0; c < _.options.slidesPerRow; c++) {
                        var target = (a * slidesPerSection + ((b * _.options.slidesPerRow) + c));
                        if (originalSlides.get(target)) {
                            row.appendChild(originalSlides.get(target));
                        }
                    }
                    slide.appendChild(row);
                }
                newSlides.appendChild(slide);
            }

            _.$slider.html(newSlides);
            _.$slider.children().children().children()
                .css({
                    'width':(100 / _.options.slidesPerRow) + '%',
                    'display': 'inline-block'
                });

        }

    };

    Slick.prototype.checkResponsive = function(initial, forceUpdate) {

        var _ = this,
            breakpoint, targetBreakpoint, respondToWidth, triggerBreakpoint = false;
        var sliderWidth = _.$slider.width();
        var windowWidth = window.innerWidth || $(window).width();

        if (_.respondTo === 'window') {
            respondToWidth = windowWidth;
        } else if (_.respondTo === 'slider') {
            respondToWidth = sliderWidth;
        } else if (_.respondTo === 'min') {
            respondToWidth = Math.min(windowWidth, sliderWidth);
        }

        if ( _.options.responsive &&
            _.options.responsive.length &&
            _.options.responsive !== null) {

            targetBreakpoint = null;

            for (breakpoint in _.breakpoints) {
                if (_.breakpoints.hasOwnProperty(breakpoint)) {
                    if (_.originalSettings.mobileFirst === false) {
                        if (respondToWidth < _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    } else {
                        if (respondToWidth > _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    }
                }
            }

            if (targetBreakpoint !== null) {
                if (_.activeBreakpoint !== null) {
                    if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
                        _.activeBreakpoint =
                            targetBreakpoint;
                        if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                            _.unslick(targetBreakpoint);
                        } else {
                            _.options = $.extend({}, _.originalSettings,
                                _.breakpointSettings[
                                    targetBreakpoint]);
                            if (initial === true) {
                                _.currentSlide = _.options.initialSlide;
                            }
                            _.refresh(initial);
                        }
                        triggerBreakpoint = targetBreakpoint;
                    }
                } else {
                    _.activeBreakpoint = targetBreakpoint;
                    if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                        _.unslick(targetBreakpoint);
                    } else {
                        _.options = $.extend({}, _.originalSettings,
                            _.breakpointSettings[
                                targetBreakpoint]);
                        if (initial === true) {
                            _.currentSlide = _.options.initialSlide;
                        }
                        _.refresh(initial);
                    }
                    triggerBreakpoint = targetBreakpoint;
                }
            } else {
                if (_.activeBreakpoint !== null) {
                    _.activeBreakpoint = null;
                    _.options = _.originalSettings;
                    if (initial === true) {
                        _.currentSlide = _.options.initialSlide;
                    }
                    _.refresh(initial);
                    triggerBreakpoint = targetBreakpoint;
                }
            }

            // only trigger breakpoints during an actual break. not on initialize.
            if( !initial && triggerBreakpoint !== false ) {
                _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
            }
        }

    };

    Slick.prototype.changeSlide = function(event, dontAnimate) {

        var _ = this,
            $target = $(event.target),
            indexOffset, slideOffset, unevenOffset;

        // If target is a link, prevent default action.
        if($target.is('a')) {
            event.preventDefault();
        }

        // If target is not the <li> element (ie: a child), find the <li>.
        if(!$target.is('li')) {
            $target = $target.closest('li');
        }

        unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);
        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

        switch (event.data.message) {

            case 'previous':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
                }
                break;

            case 'next':
                slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
                if (_.slideCount > _.options.slidesToShow) {
                    _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
                }
                break;

            case 'index':
                var index = event.data.index === 0 ? 0 :
                    event.data.index || $target.index() * _.options.slidesToScroll;

                _.slideHandler(_.checkNavigable(index), false, dontAnimate);
                $target.children().trigger('focus');
                break;

            default:
                return;
        }

    };

    Slick.prototype.checkNavigable = function(index) {

        var _ = this,
            navigables, prevNavigable;

        navigables = _.getNavigableIndexes();
        prevNavigable = 0;
        if (index > navigables[navigables.length - 1]) {
            index = navigables[navigables.length - 1];
        } else {
            for (var n in navigables) {
                if (index < navigables[n]) {
                    index = prevNavigable;
                    break;
                }
                prevNavigable = navigables[n];
            }
        }

        return index;
    };

    Slick.prototype.cleanUpEvents = function() {

        var _ = this;

        if (_.options.dots && _.$dots !== null) {

            $('li', _.$dots).off('click.slick', _.changeSlide);

            if (_.options.pauseOnDotsHover === true && _.options.autoplay === true) {

                $('li', _.$dots)
                    .off('mouseenter.slick', $.proxy(_.setPaused, _, true))
                    .off('mouseleave.slick', $.proxy(_.setPaused, _, false));

            }

        }

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
            _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);
        }

        _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
        _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
        _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
        _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

        _.$list.off('click.slick', _.clickHandler);

        $(document).off(_.visibilityChange, _.visibility);

        _.$list.off('mouseenter.slick', $.proxy(_.setPaused, _, true));
        _.$list.off('mouseleave.slick', $.proxy(_.setPaused, _, false));

        if (_.options.accessibility === true) {
            _.$list.off('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().off('click.slick', _.selectHandler);
        }

        $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);

        $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);

        $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);

        $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(document).off('ready.slick.slick-' + _.instanceUid, _.setPosition);
    };

    Slick.prototype.cleanUpRows = function() {

        var _ = this, originalSlides;

        if(_.options.rows > 1) {
            originalSlides = _.$slides.children().children();
            originalSlides.removeAttr('style');
            _.$slider.html(originalSlides);
        }

    };

    Slick.prototype.clickHandler = function(event) {

        var _ = this;

        if (_.shouldClick === false) {
            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
        }

    };

    Slick.prototype.destroy = function(refresh) {

        var _ = this;

        _.autoPlayClear();

        _.touchObject = {};

        _.cleanUpEvents();

        $('.slick-cloned', _.$slider).detach();

        if (_.$dots) {
            _.$dots.remove();
        }

        if ( _.options.arrows === true ) {

            if ( _.$prevArrow && _.$prevArrow.length ) {

                _.$prevArrow
                    .removeClass('slick-disabled slick-arrow slick-hidden')
                    .removeAttr('aria-hidden aria-disabled tabindex')
                    .css("display","");

                if ( _.htmlExpr.test( _.options.prevArrow )) {
                    _.$prevArrow.remove();
                }
            }

            if ( _.$nextArrow && _.$nextArrow.length ) {

                _.$nextArrow
                    .removeClass('slick-disabled slick-arrow slick-hidden')
                    .removeAttr('aria-hidden aria-disabled tabindex')
                    .css("display","");

                if ( _.htmlExpr.test( _.options.nextArrow )) {
                    _.$nextArrow.remove();
                }
            }

        }

        if (_.$slides) {

            _.$slides
                .removeClass('slick-slide slick-active slick-center slick-visible slick-current')
                .removeAttr('aria-hidden')
                .removeAttr('data-slick-index')
                .each(function(){
                    $(this).attr('style', $(this).data('originalStyling'));
                });

            _.$slideTrack.children(this.options.slide).detach();

            _.$slideTrack.detach();

            _.$list.detach();

            _.$slider.append(_.$slides);
        }

        _.cleanUpRows();

        _.$slider.removeClass('slick-slider');
        _.$slider.removeClass('slick-initialized');

        _.unslicked = true;

        if(!refresh) {
            _.$slider.trigger('destroy', [_]);
        }

    };

    Slick.prototype.disableTransition = function(slide) {

        var _ = this,
            transition = {};

        transition[_.transitionType] = '';

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.fadeSlide = function(slideIndex, callback) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).css({
                zIndex: _.options.zIndex
            });

            _.$slides.eq(slideIndex).animate({
                opacity: 1
            }, _.options.speed, _.options.easing, callback);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 1,
                zIndex: _.options.zIndex
            });

            if (callback) {
                setTimeout(function() {

                    _.disableTransition(slideIndex);

                    callback.call();
                }, _.options.speed);
            }

        }

    };

    Slick.prototype.fadeSlideOut = function(slideIndex) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).animate({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            }, _.options.speed, _.options.easing);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            });

        }

    };

    Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {

        var _ = this;

        if (filter !== null) {

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {

        var _ = this;
        return _.currentSlide;

    };

    Slick.prototype.getDotCount = function() {

        var _ = this;

        var breakPoint = 0;
        var counter = 0;
        var pagerQty = 0;

        if(_.options.infinite === true) {
            pagerQty = Math.ceil(_.slideCount / _.options.slidesToScroll);
        } else if (_.options.centerMode === true) {
            pagerQty = _.slideCount;
        } else {
            while (breakPoint < _.slideCount){
                ++pagerQty;
                breakPoint = counter + _.options.slidesToShow;
                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll  : _.options.slidesToShow;
            }
        }

        return pagerQty - 1;

    };

    Slick.prototype.getLeft = function(slideIndex) {

        var _ = this,
            targetLeft,
            verticalHeight,
            verticalOffset = 0,
            targetSlide;

        _.slideOffset = 0;
        verticalHeight = _.$slides.first().outerHeight(true);

        if (_.options.infinite === true) {
            if (_.slideCount > _.options.slidesToShow) {
                _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;
                verticalOffset = (verticalHeight * _.options.slidesToShow) * -1;
            }
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
                    if (slideIndex > _.slideCount) {
                        _.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;
                        verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;
                    } else {
                        _.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;
                        verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;
                    }
                }
            }
        } else {
            if (slideIndex + _.options.slidesToShow > _.slideCount) {
                _.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;
                verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;
            }
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.slideOffset = 0;
            verticalOffset = 0;
        }

        if (_.options.centerMode === true && _.options.infinite === true) {
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
        } else if (_.options.centerMode === true) {
            _.slideOffset = 0;
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
        }

        if (_.options.vertical === false) {
            targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;
        } else {
            targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;
        }

        if (_.options.variableWidth === true) {

            if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
            } else {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
            }

            targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;

            if (_.options.centerMode === true) {
                if (_.options.infinite === false) {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
                } else {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
                }
                targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
            }
        }

        return targetLeft;

    };

    Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {

        var _ = this;

        return _.options[option];

    };

    Slick.prototype.getNavigableIndexes = function() {

        var _ = this,
            breakPoint = 0,
            counter = 0,
            indexes = [],
            max;

        if (_.options.infinite === false) {
            max = _.slideCount;
        } else {
            breakPoint = _.options.slidesToScroll * -1;
            counter = _.options.slidesToScroll * -1;
            max = _.slideCount * 2;
        }

        while (breakPoint < max) {
            indexes.push(breakPoint);
            breakPoint = counter + _.options.slidesToScroll;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        }

        return indexes;

    };

    Slick.prototype.getSlick = function() {

        return this;

    };

    Slick.prototype.getSlideCount = function() {

        var _ = this,
            slidesTraversed, swipedSlide, centerOffset;

        centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;

        if (_.options.swipeToSlide === true) {
            _.$slideTrack.find('.slick-slide').each(function(index, slide) {
                if (slide.offsetLeft - centerOffset + ($(slide).outerWidth() / 2) > (_.swipeLeft * -1)) {
                    swipedSlide = slide;
                    return false;
                }
            });

            slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;

            return slidesTraversed;

        } else {
            return _.options.slidesToScroll;
        }

    };

    Slick.prototype.goTo = Slick.prototype.slickGoTo = function(slide, dontAnimate) {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'index',
                index: parseInt(slide)
            }
        }, dontAnimate);

    };

    Slick.prototype.init = function(creation) {

        var _ = this;

        if (!$(_.$slider).hasClass('slick-initialized')) {

            $(_.$slider).addClass('slick-initialized');

            _.buildRows();
            _.buildOut();
            _.setProps();
            _.startLoad();
            _.loadSlider();
            _.initializeEvents();
            _.updateArrows();
            _.updateDots();

        }

        if (creation) {
            _.$slider.trigger('init', [_]);
        }

        if (_.options.accessibility === true) {
            _.initADA();
        }

    };

    Slick.prototype.initArrowEvents = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow.on('click.slick', {
                message: 'previous'
            }, _.changeSlide);
            _.$nextArrow.on('click.slick', {
                message: 'next'
            }, _.changeSlide);
        }

    };

    Slick.prototype.initDotEvents = function() {

        var _ = this;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
            $('li', _.$dots).on('click.slick', {
                message: 'index'
            }, _.changeSlide);
        }

        if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.options.autoplay === true) {
            $('li', _.$dots)
                .on('mouseenter.slick', $.proxy(_.setPaused, _, true))
                .on('mouseleave.slick', $.proxy(_.setPaused, _, false));
        }

    };

    Slick.prototype.initializeEvents = function() {

        var _ = this;

        _.initArrowEvents();

        _.initDotEvents();

        _.$list.on('touchstart.slick mousedown.slick', {
            action: 'start'
        }, _.swipeHandler);
        _.$list.on('touchmove.slick mousemove.slick', {
            action: 'move'
        }, _.swipeHandler);
        _.$list.on('touchend.slick mouseup.slick', {
            action: 'end'
        }, _.swipeHandler);
        _.$list.on('touchcancel.slick mouseleave.slick', {
            action: 'end'
        }, _.swipeHandler);

        _.$list.on('click.slick', _.clickHandler);

        $(document).on(_.visibilityChange, $.proxy(_.visibility, _));

        _.$list.on('mouseenter.slick', $.proxy(_.setPaused, _, true));
        _.$list.on('mouseleave.slick', $.proxy(_.setPaused, _, false));

        if (_.options.accessibility === true) {
            _.$list.on('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));

        $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));

        $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);

        $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(document).on('ready.slick.slick-' + _.instanceUid, _.setPosition);

    };

    Slick.prototype.initUI = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.show();
            _.$nextArrow.show();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.show();

        }

        if (_.options.autoplay === true) {

            _.autoPlay();

        }

    };

    Slick.prototype.keyHandler = function(event) {

        var _ = this;
        //Dont slide if the cursor is inside the form fields and arrow keys are pressed
        if(!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
            if (event.keyCode === 37 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: 'previous'
                    }
                });
            } else if (event.keyCode === 39 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: 'next'
                    }
                });
            }
        }

    };

    Slick.prototype.lazyLoad = function() {

        var _ = this,
            loadRange, cloneRange, rangeStart, rangeEnd;

        function loadImages(imagesScope) {
            $('img[data-lazy]', imagesScope).each(function() {

                var image = $(this),
                    imageSource = $(this).attr('data-lazy'),
                    imageToLoad = document.createElement('img');

                imageToLoad.onload = function() {
                    image
                        .animate({ opacity: 0 }, 100, function() {
                            image
                                .attr('src', imageSource)
                                .animate({ opacity: 1 }, 200, function() {
                                    image
                                        .removeAttr('data-lazy')
                                        .removeClass('slick-loading');
                                });
                        });
                };

                imageToLoad.src = imageSource;

            });
        }

        if (_.options.centerMode === true) {
            if (_.options.infinite === true) {
                rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
                rangeEnd = rangeStart + _.options.slidesToShow + 2;
            } else {
                rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
                rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
            }
        } else {
            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
            rangeEnd = rangeStart + _.options.slidesToShow;
            if (_.options.fade === true) {
                if (rangeStart > 0) rangeStart--;
                if (rangeEnd <= _.slideCount) rangeEnd++;
            }
        }

        loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);
        loadImages(loadRange);

        if (_.slideCount <= _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-slide');
            loadImages(cloneRange);
        } else
        if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
            loadImages(cloneRange);
        } else if (_.currentSlide === 0) {
            cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
            loadImages(cloneRange);
        }

    };

    Slick.prototype.loadSlider = function() {

        var _ = this;

        _.setPosition();

        _.$slideTrack.css({
            opacity: 1
        });

        _.$slider.removeClass('slick-loading');

        _.initUI();

        if (_.options.lazyLoad === 'progressive') {
            _.progressiveLazyLoad();
        }

    };

    Slick.prototype.next = Slick.prototype.slickNext = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'next'
            }
        });

    };

    Slick.prototype.orientationChange = function() {

        var _ = this;

        _.checkResponsive();
        _.setPosition();

    };

    Slick.prototype.pause = Slick.prototype.slickPause = function() {

        var _ = this;

        _.autoPlayClear();
        _.paused = true;

    };

    Slick.prototype.play = Slick.prototype.slickPlay = function() {

        var _ = this;

        _.paused = false;
        _.autoPlay();

    };

    Slick.prototype.postSlide = function(index) {

        var _ = this;

        _.$slider.trigger('afterChange', [_, index]);

        _.animating = false;

        _.setPosition();

        _.swipeLeft = null;

        if (_.options.autoplay === true && _.paused === false) {
            _.autoPlay();
        }
        if (_.options.accessibility === true) {
            _.initADA();
        }

    };

    Slick.prototype.prev = Slick.prototype.slickPrev = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'previous'
            }
        });

    };

    Slick.prototype.preventDefault = function(e) {
        e.preventDefault();
    };

    Slick.prototype.progressiveLazyLoad = function() {

        var _ = this,
            imgCount, targetImage;

        imgCount = $('img[data-lazy]', _.$slider).length;

        if (imgCount > 0) {
            targetImage = $('img[data-lazy]', _.$slider).first();
            targetImage.attr('src', targetImage.attr('data-lazy')).removeClass('slick-loading').load(function() {
                targetImage.removeAttr('data-lazy');
                _.progressiveLazyLoad();

                if (_.options.adaptiveHeight === true) {
                    _.setPosition();
                }
            })
                .error(function() {
                    targetImage.removeAttr('data-lazy');
                    _.progressiveLazyLoad();
                });
        }

    };

    Slick.prototype.refresh = function( initializing ) {

        var _ = this,
            currentSlide = _.currentSlide;

        _.destroy(true);

        $.extend(_, _.initials, { currentSlide: currentSlide });

        _.init();

        if( !initializing ) {

            _.changeSlide({
                data: {
                    message: 'index',
                    index: currentSlide
                }
            }, false);

        }

    };

    Slick.prototype.registerBreakpoints = function() {

        var _ = this, breakpoint, currentBreakpoint, l,
            responsiveSettings = _.options.responsive || null;

        if ( $.type(responsiveSettings) === "array" && responsiveSettings.length ) {

            _.respondTo = _.options.respondTo || 'window';

            for ( breakpoint in responsiveSettings ) {

                l = _.breakpoints.length-1;
                currentBreakpoint = responsiveSettings[breakpoint].breakpoint;

                if (responsiveSettings.hasOwnProperty(breakpoint)) {

                    // loop through the breakpoints and cut out any existing
                    // ones with the same breakpoint number, we don't want dupes.
                    while( l >= 0 ) {
                        if( _.breakpoints[l] && _.breakpoints[l] === currentBreakpoint ) {
                            _.breakpoints.splice(l,1);
                        }
                        l--;
                    }

                    _.breakpoints.push(currentBreakpoint);
                    _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;

                }

            }

            _.breakpoints.sort(function(a, b) {
                return ( _.options.mobileFirst ) ? a-b : b-a;
            });

        }

    };

    Slick.prototype.reinit = function() {

        var _ = this;

        _.$slides =
            _.$slideTrack
                .children(_.options.slide)
                .addClass('slick-slide');

        _.slideCount = _.$slides.length;

        if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
            _.currentSlide = _.currentSlide - _.options.slidesToScroll;
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.currentSlide = 0;
        }

        _.registerBreakpoints();

        _.setProps();
        _.setupInfinite();
        _.buildArrows();
        _.updateArrows();
        _.initArrowEvents();
        _.buildDots();
        _.updateDots();
        _.initDotEvents();

        _.checkResponsive(false, true);

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        _.setSlideClasses(0);

        _.setPosition();

        _.$slider.trigger('reInit', [_]);

        if (_.options.autoplay === true) {
            _.focusHandler();
        }

    };

    Slick.prototype.resize = function() {

        var _ = this;

        if ($(window).width() !== _.windowWidth) {
            clearTimeout(_.windowDelay);
            _.windowDelay = window.setTimeout(function() {
                _.windowWidth = $(window).width();
                _.checkResponsive();
                if( !_.unslicked ) { _.setPosition(); }
            }, 50);
        }
    };

    Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(index, removeBefore, removeAll) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            removeBefore = index;
            index = removeBefore === true ? 0 : _.slideCount - 1;
        } else {
            index = removeBefore === true ? --index : index;
        }

        if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
            return false;
        }

        _.unload();

        if (removeAll === true) {
            _.$slideTrack.children().remove();
        } else {
            _.$slideTrack.children(this.options.slide).eq(index).remove();
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.setCSS = function(position) {

        var _ = this,
            positionProps = {},
            x, y;

        if (_.options.rtl === true) {
            position = -position;
        }
        x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
        y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';

        positionProps[_.positionProp] = position;

        if (_.transformsEnabled === false) {
            _.$slideTrack.css(positionProps);
        } else {
            positionProps = {};
            if (_.cssTransitions === false) {
                positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
                _.$slideTrack.css(positionProps);
            } else {
                positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
                _.$slideTrack.css(positionProps);
            }
        }

    };

    Slick.prototype.setDimensions = function() {

        var _ = this;

        if (_.options.vertical === false) {
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: ('0px ' + _.options.centerPadding)
                });
            }
        } else {
            _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: (_.options.centerPadding + ' 0px')
                });
            }
        }

        _.listWidth = _.$list.width();
        _.listHeight = _.$list.height();


        if (_.options.vertical === false && _.options.variableWidth === false) {
            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
            _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));

        } else if (_.options.variableWidth === true) {
            _.$slideTrack.width(5000 * _.slideCount);
        } else {
            _.slideWidth = Math.ceil(_.listWidth);
            _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));
        }

        var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
        if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);

    };

    Slick.prototype.setFade = function() {

        var _ = this,
            targetLeft;

        _.$slides.each(function(index, element) {
            targetLeft = (_.slideWidth * index) * -1;
            if (_.options.rtl === true) {
                $(element).css({
                    position: 'relative',
                    right: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            } else {
                $(element).css({
                    position: 'relative',
                    left: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            }
        });

        _.$slides.eq(_.currentSlide).css({
            zIndex: _.options.zIndex - 1,
            opacity: 1
        });

    };

    Slick.prototype.setHeight = function() {

        var _ = this;

        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.css('height', targetHeight);
        }

    };

    Slick.prototype.setOption = Slick.prototype.slickSetOption = function(option, value, refresh) {

        var _ = this, l, item;

        if( option === "responsive" && $.type(value) === "array" ) {
            for ( item in value ) {
                if( $.type( _.options.responsive ) !== "array" ) {
                    _.options.responsive = [ value[item] ];
                } else {
                    l = _.options.responsive.length-1;
                    // loop through the responsive object and splice out duplicates.
                    while( l >= 0 ) {
                        if( _.options.responsive[l].breakpoint === value[item].breakpoint ) {
                            _.options.responsive.splice(l,1);
                        }
                        l--;
                    }
                    _.options.responsive.push( value[item] );
                }
            }
        } else {
            _.options[option] = value;
        }

        if (refresh === true) {
            _.unload();
            _.reinit();
        }

    };

    Slick.prototype.setPosition = function() {

        var _ = this;

        _.setDimensions();

        _.setHeight();

        if (_.options.fade === false) {
            _.setCSS(_.getLeft(_.currentSlide));
        } else {
            _.setFade();
        }

        _.$slider.trigger('setPosition', [_]);

    };

    Slick.prototype.setProps = function() {

        var _ = this,
            bodyStyle = document.body.style;

        _.positionProp = _.options.vertical === true ? 'top' : 'left';

        if (_.positionProp === 'top') {
            _.$slider.addClass('slick-vertical');
        } else {
            _.$slider.removeClass('slick-vertical');
        }

        if (bodyStyle.WebkitTransition !== undefined ||
            bodyStyle.MozTransition !== undefined ||
            bodyStyle.msTransition !== undefined) {
            if (_.options.useCSS === true) {
                _.cssTransitions = true;
            }
        }

        if ( _.options.fade ) {
            if ( typeof _.options.zIndex === 'number' ) {
                if( _.options.zIndex < 3 ) {
                    _.options.zIndex = 3;
                }
            } else {
                _.options.zIndex = _.defaults.zIndex;
            }
        }

        if (bodyStyle.OTransform !== undefined) {
            _.animType = 'OTransform';
            _.transformType = '-o-transform';
            _.transitionType = 'OTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.MozTransform !== undefined) {
            _.animType = 'MozTransform';
            _.transformType = '-moz-transform';
            _.transitionType = 'MozTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.webkitTransform !== undefined) {
            _.animType = 'webkitTransform';
            _.transformType = '-webkit-transform';
            _.transitionType = 'webkitTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
        }
        if (bodyStyle.msTransform !== undefined) {
            _.animType = 'msTransform';
            _.transformType = '-ms-transform';
            _.transitionType = 'msTransition';
            if (bodyStyle.msTransform === undefined) _.animType = false;
        }
        if (bodyStyle.transform !== undefined && _.animType !== false) {
            _.animType = 'transform';
            _.transformType = 'transform';
            _.transitionType = 'transition';
        }
        _.transformsEnabled = (_.animType !== null && _.animType !== false);

    };


    Slick.prototype.setSlideClasses = function(index) {

        var _ = this,
            centerOffset, allSlides, indexOffset, remainder;

        allSlides = _.$slider
            .find('.slick-slide')
            .removeClass('slick-active slick-center slick-current')
            .attr('aria-hidden', 'true');

        _.$slides
            .eq(index)
            .addClass('slick-current');

        if (_.options.centerMode === true) {

            centerOffset = Math.floor(_.options.slidesToShow / 2);

            if (_.options.infinite === true) {

                if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {

                    _.$slides
                        .slice(index - centerOffset, index + centerOffset + 1)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                } else {

                    indexOffset = _.options.slidesToShow + index;
                    allSlides
                        .slice(indexOffset - centerOffset + 1, indexOffset + centerOffset + 2)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                }

                if (index === 0) {

                    allSlides
                        .eq(allSlides.length - 1 - _.options.slidesToShow)
                        .addClass('slick-center');

                } else if (index === _.slideCount - 1) {

                    allSlides
                        .eq(_.options.slidesToShow)
                        .addClass('slick-center');

                }

            }

            _.$slides
                .eq(index)
                .addClass('slick-center');

        } else {

            if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {

                _.$slides
                    .slice(index, index + _.options.slidesToShow)
                    .addClass('slick-active')
                    .attr('aria-hidden', 'false');

            } else if (allSlides.length <= _.options.slidesToShow) {

                allSlides
                    .addClass('slick-active')
                    .attr('aria-hidden', 'false');

            } else {

                remainder = _.slideCount % _.options.slidesToShow;
                indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;

                if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {

                    allSlides
                        .slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                } else {

                    allSlides
                        .slice(indexOffset, indexOffset + _.options.slidesToShow)
                        .addClass('slick-active')
                        .attr('aria-hidden', 'false');

                }

            }

        }

        if (_.options.lazyLoad === 'ondemand') {
            _.lazyLoad();
        }

    };

    Slick.prototype.setupInfinite = function() {

        var _ = this,
            i, slideIndex, infiniteCount;

        if (_.options.fade === true) {
            _.options.centerMode = false;
        }

        if (_.options.infinite === true && _.options.fade === false) {

            slideIndex = null;

            if (_.slideCount > _.options.slidesToShow) {

                if (_.options.centerMode === true) {
                    infiniteCount = _.options.slidesToShow + 1;
                } else {
                    infiniteCount = _.options.slidesToShow;
                }

                for (i = _.slideCount; i > (_.slideCount -
                    infiniteCount); i -= 1) {
                    slideIndex = i - 1;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '')
                        .attr('data-slick-index', slideIndex - _.slideCount)
                        .prependTo(_.$slideTrack).addClass('slick-cloned');
                }
                for (i = 0; i < infiniteCount; i += 1) {
                    slideIndex = i;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '')
                        .attr('data-slick-index', slideIndex + _.slideCount)
                        .appendTo(_.$slideTrack).addClass('slick-cloned');
                }
                _.$slideTrack.find('.slick-cloned').find('[id]').each(function() {
                    $(this).attr('id', '');
                });

            }

        }

    };

    Slick.prototype.setPaused = function(paused) {

        var _ = this;

        if (_.options.autoplay === true && _.options.pauseOnHover === true) {
            _.paused = paused;
            if (!paused) {
                _.autoPlay();
            } else {
                _.autoPlayClear();
            }
        }
    };

    Slick.prototype.selectHandler = function(event) {

        var _ = this;

        var targetElement =
            $(event.target).is('.slick-slide') ?
                $(event.target) :
                $(event.target).parents('.slick-slide');

        var index = parseInt(targetElement.attr('data-slick-index'));

        if (!index) index = 0;

        if (_.slideCount <= _.options.slidesToShow) {

            _.setSlideClasses(index);
            _.asNavFor(index);
            return;

        }

        _.slideHandler(index);

    };

    Slick.prototype.slideHandler = function(index, sync, dontAnimate) {

        var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,
            _ = this;

        sync = sync || false;

        if (_.animating === true && _.options.waitForAnimate === true) {
            return;
        }

        if (_.options.fade === true && _.currentSlide === index) {
            return;
        }

        if (_.slideCount <= _.options.slidesToShow) {
            return;
        }

        if (sync === false) {
            _.asNavFor(index);
        }

        targetSlide = index;
        targetLeft = _.getLeft(targetSlide);
        slideLeft = _.getLeft(_.currentSlide);

        _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

        if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        }

        if (_.options.autoplay === true) {
            clearInterval(_.autoPlayTimer);
        }

        if (targetSlide < 0) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);
            } else {
                animSlide = _.slideCount + targetSlide;
            }
        } else if (targetSlide >= _.slideCount) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = 0;
            } else {
                animSlide = targetSlide - _.slideCount;
            }
        } else {
            animSlide = targetSlide;
        }

        _.animating = true;

        _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

        oldSlide = _.currentSlide;
        _.currentSlide = animSlide;

        _.setSlideClasses(_.currentSlide);

        _.updateDots();
        _.updateArrows();

        if (_.options.fade === true) {
            if (dontAnimate !== true) {

                _.fadeSlideOut(oldSlide);

                _.fadeSlide(animSlide, function() {
                    _.postSlide(animSlide);
                });

            } else {
                _.postSlide(animSlide);
            }
            _.animateHeight();
            return;
        }

        if (dontAnimate !== true) {
            _.animateSlide(targetLeft, function() {
                _.postSlide(animSlide);
            });
        } else {
            _.postSlide(animSlide);
        }

    };

    Slick.prototype.startLoad = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.hide();
            _.$nextArrow.hide();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.hide();

        }

        _.$slider.addClass('slick-loading');

    };

    Slick.prototype.swipeDirection = function() {

        var xDist, yDist, r, swipeAngle, _ = this;

        xDist = _.touchObject.startX - _.touchObject.curX;
        yDist = _.touchObject.startY - _.touchObject.curY;
        r = Math.atan2(yDist, xDist);

        swipeAngle = Math.round(r * 180 / Math.PI);
        if (swipeAngle < 0) {
            swipeAngle = 360 - Math.abs(swipeAngle);
        }

        if ((swipeAngle <= 45) && (swipeAngle >= 0)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle <= 360) && (swipeAngle >= 315)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle >= 135) && (swipeAngle <= 225)) {
            return (_.options.rtl === false ? 'right' : 'left');
        }
        if (_.options.verticalSwiping === true) {
            if ((swipeAngle >= 35) && (swipeAngle <= 135)) {
                return 'left';
            } else {
                return 'right';
            }
        }

        return 'vertical';

    };

    Slick.prototype.swipeEnd = function(event) {

        var _ = this,
            slideCount;

        _.dragging = false;

        _.shouldClick = (_.touchObject.swipeLength > 10) ? false : true;

        if (_.touchObject.curX === undefined) {
            return false;
        }

        if (_.touchObject.edgeHit === true) {
            _.$slider.trigger('edge', [_, _.swipeDirection()]);
        }

        if (_.touchObject.swipeLength >= _.touchObject.minSwipe) {

            switch (_.swipeDirection()) {
                case 'left':
                    slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide + _.getSlideCount()) : _.currentSlide + _.getSlideCount();
                    _.slideHandler(slideCount);
                    _.currentDirection = 0;
                    _.touchObject = {};
                    _.$slider.trigger('swipe', [_, 'left']);
                    break;

                case 'right':
                    slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide - _.getSlideCount()) : _.currentSlide - _.getSlideCount();
                    _.slideHandler(slideCount);
                    _.currentDirection = 1;
                    _.touchObject = {};
                    _.$slider.trigger('swipe', [_, 'right']);
                    break;
            }
        } else {
            if (_.touchObject.startX !== _.touchObject.curX) {
                _.slideHandler(_.currentSlide);
                _.touchObject = {};
            }
        }

    };

    Slick.prototype.swipeHandler = function(event) {

        var _ = this;

        if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {
            return;
        } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
            return;
        }

        _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ?
            event.originalEvent.touches.length : 1;

        _.touchObject.minSwipe = _.listWidth / _.options
            .touchThreshold;

        if (_.options.verticalSwiping === true) {
            _.touchObject.minSwipe = _.listHeight / _.options
                .touchThreshold;
        }

        switch (event.data.action) {

            case 'start':
                _.swipeStart(event);
                break;

            case 'move':
                _.swipeMove(event);
                break;

            case 'end':
                _.swipeEnd(event);
                break;

        }

    };

    Slick.prototype.swipeMove = function(event) {

        var _ = this,
            edgeWasHit = false,
            curLeft, swipeDirection, swipeLength, positionOffset, touches;

        touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

        if (!_.dragging || touches && touches.length !== 1) {
            return false;
        }

        curLeft = _.getLeft(_.currentSlide);

        _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
        _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

        _.touchObject.swipeLength = Math.round(Math.sqrt(
            Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

        if (_.options.verticalSwiping === true) {
            _.touchObject.swipeLength = Math.round(Math.sqrt(
                Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));
        }

        swipeDirection = _.swipeDirection();

        if (swipeDirection === 'vertical') {
            return;
        }

        if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
            event.preventDefault();
        }

        positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
        if (_.options.verticalSwiping === true) {
            positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
        }


        swipeLength = _.touchObject.swipeLength;

        _.touchObject.edgeHit = false;

        if (_.options.infinite === false) {
            if ((_.currentSlide === 0 && swipeDirection === 'right') || (_.currentSlide >= _.getDotCount() && swipeDirection === 'left')) {
                swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
                _.touchObject.edgeHit = true;
            }
        }

        if (_.options.vertical === false) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        } else {
            _.swipeLeft = curLeft + (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;
        }
        if (_.options.verticalSwiping === true) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        }

        if (_.options.fade === true || _.options.touchMove === false) {
            return false;
        }

        if (_.animating === true) {
            _.swipeLeft = null;
            return false;
        }

        _.setCSS(_.swipeLeft);

    };

    Slick.prototype.swipeStart = function(event) {

        var _ = this,
            touches;

        if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
            _.touchObject = {};
            return false;
        }

        if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
            touches = event.originalEvent.touches[0];
        }

        _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
        _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

        _.dragging = true;

    };

    Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {

        var _ = this;

        if (_.$slidesCache !== null) {

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.unload = function() {

        var _ = this;

        $('.slick-cloned', _.$slider).remove();

        if (_.$dots) {
            _.$dots.remove();
        }

        if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
            _.$prevArrow.remove();
        }

        if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
            _.$nextArrow.remove();
        }

        _.$slides
            .removeClass('slick-slide slick-active slick-visible slick-current')
            .attr('aria-hidden', 'true')
            .css('width', '');

    };

    Slick.prototype.unslick = function(fromBreakpoint) {

        var _ = this;
        _.$slider.trigger('unslick', [_, fromBreakpoint]);
        _.destroy();

    };

    Slick.prototype.updateArrows = function() {

        var _ = this,
            centerOffset;

        centerOffset = Math.floor(_.options.slidesToShow / 2);

        if ( _.options.arrows === true &&
            _.slideCount > _.options.slidesToShow &&
            !_.options.infinite ) {

            _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
            _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            if (_.currentSlide === 0) {

                _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            }

        }

    };

    Slick.prototype.updateDots = function() {

        var _ = this;

        if (_.$dots !== null) {

            _.$dots
                .find('li')
                .removeClass('slick-active')
                .attr('aria-hidden', 'true');

            _.$dots
                .find('li')
                .eq(Math.floor(_.currentSlide / _.options.slidesToScroll))
                .addClass('slick-active')
                .attr('aria-hidden', 'false');

        }

    };

    Slick.prototype.visibility = function() {

        var _ = this;

        if (document[_.hidden]) {
            _.paused = true;
            _.autoPlayClear();
        } else {
            if (_.options.autoplay === true) {
                _.paused = false;
                _.autoPlay();
            }
        }

    };
    Slick.prototype.initADA = function() {
        var _ = this;
        _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
            'aria-hidden': 'true',
            'tabindex': '-1'
        }).find('a, input, button, select').attr({
            'tabindex': '-1'
        });

        _.$slideTrack.attr('role', 'listbox');

        _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function(i) {
            $(this).attr({
                'role': 'option',
                'aria-describedby': 'slick-slide' + _.instanceUid + i + ''
            });
        });

        if (_.$dots !== null) {
            _.$dots.attr('role', 'tablist').find('li').each(function(i) {
                $(this).attr({
                    'role': 'presentation',
                    'aria-selected': 'false',
                    'aria-controls': 'navigation' + _.instanceUid + i + '',
                    'id': 'slick-slide' + _.instanceUid + i + ''
                });
            })
                .first().attr('aria-selected', 'true').end()
                .find('button').attr('role', 'button').end()
                .closest('div').attr('role', 'toolbar');
        }
        _.activateADA();

    };

    Slick.prototype.activateADA = function() {
        var _ = this,
            _isSlideOnFocus =_.$slider.find('*').is(':focus');
        // _isSlideOnFocus = _.$slides.is(':focus') || _.$slides.find('*').is(':focus');

        _.$slideTrack.find('.slick-active').attr({
            'aria-hidden': 'false',
            'tabindex': '0'
        }).find('a, input, button, select').attr({
            'tabindex': '0'
        });

        (_isSlideOnFocus) &&  _.$slideTrack.find('.slick-active').focus();

    };

    Slick.prototype.focusHandler = function() {
        var _ = this;
        _.$slider.on('focus.slick blur.slick', '*', function(event) {
            event.stopImmediatePropagation();
            var sf = $(this);
            setTimeout(function() {
                if (_.isPlay) {
                    if (sf.is(':focus')) {
                        _.autoPlayClear();
                        _.paused = true;
                    } else {
                        _.paused = false;
                        _.autoPlay();
                    }
                }
            }, 0);
        });
    };

    $.fn.slick = function() {
        var _ = this,
            opt = arguments[0],
            args = Array.prototype.slice.call(arguments, 1),
            l = _.length,
            i = 0,
            ret;
        for (i; i < l; i++) {
            if (typeof opt == 'object' || typeof opt == 'undefined')
                _[i].slick = new Slick(_[i], opt);
            else
                ret = _[i].slick[opt].apply(_[i].slick, args);
            if (typeof ret != 'undefined') return ret;
        }
        return _;
    };

}));
if (window){
    window.catalogEcommerceV2Lite = {
        resizeVerticalBlock: function(){
            var $maxHeight = [];
            var $maxNameHeight = [];

            // resize names

            $('.bxr-ecommerce-v2-lite[data-resize=1]').each(function(){

                uid = $(this).data('uid');
                $nameContainer = $(this).children('.bxr-element-container').children('.bxr-element-name');

                if (!(uid in $maxNameHeight)) {
                    $maxNameHeight[uid] = 0;
                }

                if ($nameContainer.height() > $maxNameHeight[uid]) $maxNameHeight[uid] = $nameContainer.height();

            });

            $('.bxr-ecommerce-v2-lite[data-resize=1]').each(function(){

                uid = $(this).data('uid');
                $nameContainer = $(this).children('.bxr-element-container').children('.bxr-element-name');

                if ($nameContainer.height() <= $maxNameHeight[uid]) {
                    $nameContainer.height($maxNameHeight[uid]);
                }

            });

            // resize container

            $('.bxr-ecommerce-v2-lite[data-resize=1]').each(function(){

                uid = $(this).data('uid');
                if (!(uid in $maxHeight)) {
                    $maxHeight[uid] = 0;
                }
                if ($(this).height()>$maxHeight[uid]) $maxHeight[uid] = $(this).height();
            });

            $('.bxr-ecommerce-v2-lite[data-resize=1]').each(function(){

                uid = $(this).data('uid');
                if ($(this).height() <= $maxHeight[uid]) {
                    $(this).children('.bxr-element-container').height($maxHeight[uid]);
                    $(this).height($maxHeight[uid]);
                }
            });
        }
    }

    $(document).ready(function(){

        catalogEcommerceV2Lite.resizeVerticalBlock();

    });

    if (typeof BXReady.Market.loader != 'object')
        BXReady.Market.loader = [];
    BXReady.Market.loader.push(catalogEcommerceV2Lite.resizeVerticalBlock);

    $(window).resize(function(){
        catalogEcommerceV2Lite.resizeVerticalBlock();
    });

    var current_offer_id;
    var trade_id;
    var trade_name;
    var trade_link;
    var formRequestMsg;

    $(document).on("mouseover", ".bxr-ecommerce-v2-lite .bxr-trade-request", function() {
        current_offer_id = $(this).data('offer-id');
        trade_id = $(this).data('trade-id');
        trade_name = $(this).data('trade-name');
        trade_link = $(this).data('trade-link');

        strParams = "";
        $(this).closest('.bxr-ecommerce-v2-lite').find('li.bx_active').each(function() {
            strParams += $(this).data('prop-name')+': '+$(this).attr('title')+', ';
        });
        strParams = strParams.slice(0,-2);

        formRequestMsg = $(this).data('msg').replace("#PARAMS#",strParams);
    });

}
;(function() {

    if (typeof window.BX === 'function')
    {
        return;
    }

    /**
     * Babel external helpers
     * (c) 2018 Babel
     * @license MIT
     */
    (function (global) {
        var babelHelpers = global.babelHelpers = {};

        function _typeof(obj) {
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                babelHelpers.typeof = _typeof = function (obj) {
                    return typeof obj;
                };
            } else {
                babelHelpers.typeof = _typeof = function (obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
            }

            return _typeof(obj);
        }

        babelHelpers.typeof = _typeof;
        var REACT_ELEMENT_TYPE;

        function _createRawReactElement(type, props, key, children) {
            if (!REACT_ELEMENT_TYPE) {
                REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 0xeac7;
            }

            var defaultProps = type && type.defaultProps;
            var childrenLength = arguments.length - 3;

            if (!props && childrenLength !== 0) {
                props = {
                    children: void 0
                };
            }

            if (props && defaultProps) {
                for (var propName in defaultProps) {
                    if (props[propName] === void 0) {
                        props[propName] = defaultProps[propName];
                    }
                }
            } else if (!props) {
                props = defaultProps || {};
            }

            if (childrenLength === 1) {
                props.children = children;
            } else if (childrenLength > 1) {
                var childArray = new Array(childrenLength);

                for (var i = 0; i < childrenLength; i++) {
                    childArray[i] = arguments[i + 3];
                }

                props.children = childArray;
            }

            return {
                $$typeof: REACT_ELEMENT_TYPE,
                type: type,
                key: key === undefined ? null : '' + key,
                ref: null,
                props: props,
                _owner: null
            };
        }

        babelHelpers.jsx = _createRawReactElement;

        function _asyncIterator(iterable) {
            var method;

            if (typeof Symbol === "function") {
                if (Symbol.asyncIterator) {
                    method = iterable[Symbol.asyncIterator];
                    if (method != null) return method.call(iterable);
                }

                if (Symbol.iterator) {
                    method = iterable[Symbol.iterator];
                    if (method != null) return method.call(iterable);
                }
            }

            throw new TypeError("Object is not async iterable");
        }

        babelHelpers.asyncIterator = _asyncIterator;

        function _AwaitValue(value) {
            this.wrapped = value;
        }

        babelHelpers.AwaitValue = _AwaitValue;

        function AsyncGenerator(gen) {
            var front, back;

            function send(key, arg) {
                return new Promise(function (resolve, reject) {
                    var request = {
                        key: key,
                        arg: arg,
                        resolve: resolve,
                        reject: reject,
                        next: null
                    };

                    if (back) {
                        back = back.next = request;
                    } else {
                        front = back = request;
                        resume(key, arg);
                    }
                });
            }

            function resume(key, arg) {
                try {
                    var result = gen[key](arg);
                    var value = result.value;
                    var wrappedAwait = value instanceof babelHelpers.AwaitValue;
                    Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
                        if (wrappedAwait) {
                            resume("next", arg);
                            return;
                        }

                        settle(result.done ? "return" : "normal", arg);
                    }, function (err) {
                        resume("throw", err);
                    });
                } catch (err) {
                    settle("throw", err);
                }
            }

            function settle(type, value) {
                switch (type) {
                    case "return":
                        front.resolve({
                            value: value,
                            done: true
                        });
                        break;

                    case "throw":
                        front.reject(value);
                        break;

                    default:
                        front.resolve({
                            value: value,
                            done: false
                        });
                        break;
                }

                front = front.next;

                if (front) {
                    resume(front.key, front.arg);
                } else {
                    back = null;
                }
            }

            this._invoke = send;

            if (typeof gen.return !== "function") {
                this.return = undefined;
            }
        }

        if (typeof Symbol === "function" && Symbol.asyncIterator) {
            AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
                return this;
            };
        }

        AsyncGenerator.prototype.next = function (arg) {
            return this._invoke("next", arg);
        };

        AsyncGenerator.prototype.throw = function (arg) {
            return this._invoke("throw", arg);
        };

        AsyncGenerator.prototype.return = function (arg) {
            return this._invoke("return", arg);
        };

        babelHelpers.AsyncGenerator = AsyncGenerator;

        function _wrapAsyncGenerator(fn) {
            return function () {
                return new babelHelpers.AsyncGenerator(fn.apply(this, arguments));
            };
        }

        babelHelpers.wrapAsyncGenerator = _wrapAsyncGenerator;

        function _awaitAsyncGenerator(value) {
            return new babelHelpers.AwaitValue(value);
        }

        babelHelpers.awaitAsyncGenerator = _awaitAsyncGenerator;

        function _asyncGeneratorDelegate(inner, awaitWrap) {
            var iter = {},
                waiting = false;

            function pump(key, value) {
                waiting = true;
                value = new Promise(function (resolve) {
                    resolve(inner[key](value));
                });
                return {
                    done: false,
                    value: awaitWrap(value)
                };
            }

            ;

            if (typeof Symbol === "function" && Symbol.iterator) {
                iter[Symbol.iterator] = function () {
                    return this;
                };
            }

            iter.next = function (value) {
                if (waiting) {
                    waiting = false;
                    return value;
                }

                return pump("next", value);
            };

            if (typeof inner.throw === "function") {
                iter.throw = function (value) {
                    if (waiting) {
                        waiting = false;
                        throw value;
                    }

                    return pump("throw", value);
                };
            }

            if (typeof inner.return === "function") {
                iter.return = function (value) {
                    return pump("return", value);
                };
            }

            return iter;
        }

        babelHelpers.asyncGeneratorDelegate = _asyncGeneratorDelegate;

        function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
            try {
                var info = gen[key](arg);
                var value = info.value;
            } catch (error) {
                reject(error);
                return;
            }

            if (info.done) {
                resolve(value);
            } else {
                Promise.resolve(value).then(_next, _throw);
            }
        }

        function _asyncToGenerator(fn) {
            return function () {
                var self = this,
                    args = arguments;
                return new Promise(function (resolve, reject) {
                    var gen = fn.apply(self, args);

                    function _next(value) {
                        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                    }

                    function _throw(err) {
                        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                    }

                    _next(undefined);
                });
            };
        }

        babelHelpers.asyncToGenerator = _asyncToGenerator;

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }

        babelHelpers.classCallCheck = _classCallCheck;

        function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
        }

        babelHelpers.createClass = _createClass;

        function _defineEnumerableProperties(obj, descs) {
            for (var key in descs) {
                var desc = descs[key];
                desc.configurable = desc.enumerable = true;
                if ("value" in desc) desc.writable = true;
                Object.defineProperty(obj, key, desc);
            }

            if (Object.getOwnPropertySymbols) {
                var objectSymbols = Object.getOwnPropertySymbols(descs);

                for (var i = 0; i < objectSymbols.length; i++) {
                    var sym = objectSymbols[i];
                    var desc = descs[sym];
                    desc.configurable = desc.enumerable = true;
                    if ("value" in desc) desc.writable = true;
                    Object.defineProperty(obj, sym, desc);
                }
            }

            return obj;
        }

        babelHelpers.defineEnumerableProperties = _defineEnumerableProperties;

        function _defaults(obj, defaults) {
            var keys = Object.getOwnPropertyNames(defaults);

            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = Object.getOwnPropertyDescriptor(defaults, key);

                if (value && value.configurable && obj[key] === undefined) {
                    Object.defineProperty(obj, key, value);
                }
            }

            return obj;
        }

        babelHelpers.defaults = _defaults;

        function _defineProperty(obj, key, value) {
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                });
            } else {
                obj[key] = value;
            }

            return obj;
        }

        babelHelpers.defineProperty = _defineProperty;

        function _extends() {
            babelHelpers.extends = _extends = Object.assign || function (target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];

                    for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }

                return target;
            };

            return _extends.apply(this, arguments);
        }

        babelHelpers.extends = _extends;

        function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                var ownKeys = Object.keys(source);

                if (typeof Object.getOwnPropertySymbols === 'function') {
                    ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
                        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                    }));
                }

                ownKeys.forEach(function (key) {
                    babelHelpers.defineProperty(target, key, source[key]);
                });
            }

            return target;
        }

        babelHelpers.objectSpread = _objectSpread;

        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) babelHelpers.setPrototypeOf(subClass, superClass);
        }

        babelHelpers.inherits = _inherits;

        function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
        }

        babelHelpers.inheritsLoose = _inheritsLoose;

        function _getPrototypeOf(o) {
            babelHelpers.getPrototypeOf = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
            };
            return _getPrototypeOf(o);
        }

        babelHelpers.getPrototypeOf = _getPrototypeOf;

        function _setPrototypeOf(o, p) {
            babelHelpers.setPrototypeOf = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                o.__proto__ = p;
                return o;
            };

            return _setPrototypeOf(o, p);
        }

        babelHelpers.setPrototypeOf = _setPrototypeOf;

        function isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if (typeof Proxy === "function") return true;

            try {
                Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
                return true;
            } catch (e) {
                return false;
            }
        }

        function _construct(Parent, args, Class) {
            if (isNativeReflectConstruct()) {
                babelHelpers.construct = _construct = Reflect.construct;
            } else {
                babelHelpers.construct = _construct = function _construct(Parent, args, Class) {
                    var a = [null];
                    a.push.apply(a, args);
                    var Constructor = Function.bind.apply(Parent, a);
                    var instance = new Constructor();
                    if (Class) babelHelpers.setPrototypeOf(instance, Class.prototype);
                    return instance;
                };
            }

            return _construct.apply(null, arguments);
        }

        babelHelpers.construct = _construct;

        function _isNativeFunction(fn) {
            return Function.toString.call(fn).indexOf("[native code]") !== -1;
        }

        babelHelpers.isNativeFunction = _isNativeFunction;

        function _wrapNativeSuper(Class) {
            var _cache = typeof Map === "function" ? new Map() : undefined;

            babelHelpers.wrapNativeSuper = _wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (Class === null || !babelHelpers.isNativeFunction(Class)) return Class;

                if (typeof Class !== "function") {
                    throw new TypeError("Super expression must either be null or a function");
                }

                if (typeof _cache !== "undefined") {
                    if (_cache.has(Class)) return _cache.get(Class);

                    _cache.set(Class, Wrapper);
                }

                function Wrapper() {
                    return babelHelpers.construct(Class, arguments, babelHelpers.getPrototypeOf(this).constructor);
                }

                Wrapper.prototype = Object.create(Class.prototype, {
                    constructor: {
                        value: Wrapper,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
                return babelHelpers.setPrototypeOf(Wrapper, Class);
            };

            return _wrapNativeSuper(Class);
        }

        babelHelpers.wrapNativeSuper = _wrapNativeSuper;

        function _instanceof(left, right) {
            if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
                return right[Symbol.hasInstance](left);
            } else {
                return left instanceof right;
            }
        }

        babelHelpers.instanceof = _instanceof;

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }

        babelHelpers.interopRequireDefault = _interopRequireDefault;

        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
                return obj;
            } else {
                var newObj = {};

                if (obj != null) {
                    for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) {
                            var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

                            if (desc.get || desc.set) {
                                Object.defineProperty(newObj, key, desc);
                            } else {
                                newObj[key] = obj[key];
                            }
                        }
                    }
                }

                newObj.default = obj;
                return newObj;
            }
        }

        babelHelpers.interopRequireWildcard = _interopRequireWildcard;

        function _newArrowCheck(innerThis, boundThis) {
            if (innerThis !== boundThis) {
                throw new TypeError("Cannot instantiate an arrow function");
            }
        }

        babelHelpers.newArrowCheck = _newArrowCheck;

        function _objectDestructuringEmpty(obj) {
            if (obj == null) throw new TypeError("Cannot destructure undefined");
        }

        babelHelpers.objectDestructuringEmpty = _objectDestructuringEmpty;

        function _objectWithoutPropertiesLoose(source, excluded) {
            if (source == null) return {};
            var target = {};
            var sourceKeys = Object.keys(source);
            var key, i;

            for (i = 0; i < sourceKeys.length; i++) {
                key = sourceKeys[i];
                if (excluded.indexOf(key) >= 0) continue;
                target[key] = source[key];
            }

            return target;
        }

        babelHelpers.objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;

        function _objectWithoutProperties(source, excluded) {
            if (source == null) return {};
            var target = babelHelpers.objectWithoutPropertiesLoose(source, excluded);
            var key, i;

            if (Object.getOwnPropertySymbols) {
                var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

                for (i = 0; i < sourceSymbolKeys.length; i++) {
                    key = sourceSymbolKeys[i];
                    if (excluded.indexOf(key) >= 0) continue;
                    if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
                    target[key] = source[key];
                }
            }

            return target;
        }

        babelHelpers.objectWithoutProperties = _objectWithoutProperties;

        function _assertThisInitialized(self) {
            if (self === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return self;
        }

        babelHelpers.assertThisInitialized = _assertThisInitialized;

        function _possibleConstructorReturn(self, call) {
            if (call && (typeof call === "object" || typeof call === "function")) {
                return call;
            }

            return babelHelpers.assertThisInitialized(self);
        }

        babelHelpers.possibleConstructorReturn = _possibleConstructorReturn;

        function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = babelHelpers.getPrototypeOf(object);
                if (object === null) break;
            }

            return object;
        }

        babelHelpers.superPropBase = _superPropBase;

        function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
                babelHelpers.get = _get = Reflect.get;
            } else {
                babelHelpers.get = _get = function _get(target, property, receiver) {
                    var base = babelHelpers.superPropBase(target, property);
                    if (!base) return;
                    var desc = Object.getOwnPropertyDescriptor(base, property);

                    if (desc.get) {
                        return desc.get.call(receiver);
                    }

                    return desc.value;
                };
            }

            return _get(target, property, receiver || target);
        }

        babelHelpers.get = _get;

        function set(target, property, value, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.set) {
                set = Reflect.set;
            } else {
                set = function set(target, property, value, receiver) {
                    var base = babelHelpers.superPropBase(target, property);
                    var desc;

                    if (base) {
                        desc = Object.getOwnPropertyDescriptor(base, property);

                        if (desc.set) {
                            desc.set.call(receiver, value);
                            return true;
                        } else if (!desc.writable) {
                            return false;
                        }
                    }

                    desc = Object.getOwnPropertyDescriptor(receiver, property);

                    if (desc) {
                        if (!desc.writable) {
                            return false;
                        }

                        desc.value = value;
                        Object.defineProperty(receiver, property, desc);
                    } else {
                        babelHelpers.defineProperty(receiver, property, value);
                    }

                    return true;
                };
            }

            return set(target, property, value, receiver);
        }

        function _set(target, property, value, receiver, isStrict) {
            var s = set(target, property, value, receiver || target);

            if (!s && isStrict) {
                throw new Error('failed to set property');
            }

            return value;
        }

        babelHelpers.set = _set;

        function _taggedTemplateLiteral(strings, raw) {
            if (!raw) {
                raw = strings.slice(0);
            }

            return Object.freeze(Object.defineProperties(strings, {
                raw: {
                    value: Object.freeze(raw)
                }
            }));
        }

        babelHelpers.taggedTemplateLiteral = _taggedTemplateLiteral;

        function _taggedTemplateLiteralLoose(strings, raw) {
            if (!raw) {
                raw = strings.slice(0);
            }

            strings.raw = raw;
            return strings;
        }

        babelHelpers.taggedTemplateLiteralLoose = _taggedTemplateLiteralLoose;

        function _temporalRef(val, name) {
            if (val === babelHelpers.temporalUndefined) {
                throw new ReferenceError(name + " is not defined - temporal dead zone");
            } else {
                return val;
            }
        }

        babelHelpers.temporalRef = _temporalRef;

        function _readOnlyError(name) {
            throw new Error("\"" + name + "\" is read-only");
        }

        babelHelpers.readOnlyError = _readOnlyError;

        function _classNameTDZError(name) {
            throw new Error("Class \"" + name + "\" cannot be referenced in computed property keys.");
        }

        babelHelpers.classNameTDZError = _classNameTDZError;
        babelHelpers.temporalUndefined = {};

        function _slicedToArray(arr, i) {
            return babelHelpers.arrayWithHoles(arr) || babelHelpers.iterableToArrayLimit(arr, i) || babelHelpers.nonIterableRest();
        }

        babelHelpers.slicedToArray = _slicedToArray;

        function _slicedToArrayLoose(arr, i) {
            return babelHelpers.arrayWithHoles(arr) || babelHelpers.iterableToArrayLimitLoose(arr, i) || babelHelpers.nonIterableRest();
        }

        babelHelpers.slicedToArrayLoose = _slicedToArrayLoose;

        function _toArray(arr) {
            return babelHelpers.arrayWithHoles(arr) || babelHelpers.iterableToArray(arr) || babelHelpers.nonIterableRest();
        }

        babelHelpers.toArray = _toArray;

        function _toConsumableArray(arr) {
            return babelHelpers.arrayWithoutHoles(arr) || babelHelpers.iterableToArray(arr) || babelHelpers.nonIterableSpread();
        }

        babelHelpers.toConsumableArray = _toConsumableArray;

        function _arrayWithoutHoles(arr) {
            if (Array.isArray(arr)) {
                for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

                return arr2;
            }
        }

        babelHelpers.arrayWithoutHoles = _arrayWithoutHoles;

        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr;
        }

        babelHelpers.arrayWithHoles = _arrayWithHoles;

        function _iterableToArray(iter) {
            if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
        }

        babelHelpers.iterableToArray = _iterableToArray;

        function _iterableToArrayLimit(arr, i) {
            var _arr = [];
            var _n = true;
            var _d = false;
            var _e = undefined;

            try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                    _arr.push(_s.value);

                    if (i && _arr.length === i) break;
                }
            } catch (err) {
                _d = true;
                _e = err;
            } finally {
                try {
                    if (!_n && _i["return"] != null) _i["return"]();
                } finally {
                    if (_d) throw _e;
                }
            }

            return _arr;
        }

        babelHelpers.iterableToArrayLimit = _iterableToArrayLimit;

        function _iterableToArrayLimitLoose(arr, i) {
            var _arr = [];

            for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
                _arr.push(_step.value);

                if (i && _arr.length === i) break;
            }

            return _arr;
        }

        babelHelpers.iterableToArrayLimitLoose = _iterableToArrayLimitLoose;

        function _nonIterableSpread() {
            throw new TypeError("Invalid attempt to spread non-iterable instance");
        }

        babelHelpers.nonIterableSpread = _nonIterableSpread;

        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }

        babelHelpers.nonIterableRest = _nonIterableRest;

        function _skipFirstGeneratorNext(fn) {
            return function () {
                var it = fn.apply(this, arguments);
                it.next();
                return it;
            };
        }

        babelHelpers.skipFirstGeneratorNext = _skipFirstGeneratorNext;

        function _toPropertyKey(key) {
            if (typeof key === "symbol") {
                return key;
            } else {
                return String(key);
            }
        }

        babelHelpers.toPropertyKey = _toPropertyKey;

        function _initializerWarningHelper(descriptor, context) {
            throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');
        }

        babelHelpers.initializerWarningHelper = _initializerWarningHelper;

        function _initializerDefineProperty(target, property, descriptor, context) {
            if (!descriptor) return;
            Object.defineProperty(target, property, {
                enumerable: descriptor.enumerable,
                configurable: descriptor.configurable,
                writable: descriptor.writable,
                value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
            });
        }

        babelHelpers.initializerDefineProperty = _initializerDefineProperty;

        function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
            var desc = {};
            Object['ke' + 'ys'](descriptor).forEach(function (key) {
                desc[key] = descriptor[key];
            });
            desc.enumerable = !!desc.enumerable;
            desc.configurable = !!desc.configurable;

            if ('value' in desc || desc.initializer) {
                desc.writable = true;
            }

            desc = decorators.slice().reverse().reduce(function (desc, decorator) {
                return decorator(target, property, desc) || desc;
            }, desc);

            if (context && desc.initializer !== void 0) {
                desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
                desc.initializer = undefined;
            }

            if (desc.initializer === void 0) {
                Object['define' + 'Property'](target, property, desc);
                desc = null;
            }

            return desc;
        }

        babelHelpers.applyDecoratedDescriptor = _applyDecoratedDescriptor;
        var id = 0;

        function _classPrivateFieldKey(name) {
            return "__private_" + id++ + "_" + name;
        }

        babelHelpers.classPrivateFieldLooseKey = _classPrivateFieldKey;

        function _classPrivateFieldBase(receiver, privateKey) {
            if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
                throw new TypeError("attempted to use private field on non-instance");
            }

            return receiver;
        }

        babelHelpers.classPrivateFieldLooseBase = _classPrivateFieldBase;

        function _classPrivateFieldGet(receiver, privateMap) {
            if (!privateMap.has(receiver)) {
                throw new TypeError("attempted to get private field on non-instance");
            }

            return privateMap.get(receiver).value;
        }

        babelHelpers.classPrivateFieldGet = _classPrivateFieldGet;

        function _classPrivateFieldSet(receiver, privateMap, value) {
            if (!privateMap.has(receiver)) {
                throw new TypeError("attempted to set private field on non-instance");
            }

            var descriptor = privateMap.get(receiver);

            if (!descriptor.writable) {
                throw new TypeError("attempted to set read only private field");
            }

            descriptor.value = value;
            return value;
        }

        babelHelpers.classPrivateFieldSet = _classPrivateFieldSet;
    })(typeof global === "undefined" ? window : global);

    /**
     * Copyright (c) 2014-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    !(function(global) {
        "use strict";

        var Op = Object.prototype;
        var hasOwn = Op.hasOwnProperty;
        var undefined; // More compressible than void 0.
        var $Symbol = typeof Symbol === "function" ? Symbol : {};
        var iteratorSymbol = $Symbol.iterator || "@@iterator";
        var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
        var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

        // Define the runtime globally (as expected by generated code) as either
        // module.exports (if we're in a module) or a new, empty object.
        var runtime = global.regeneratorRuntime = {};

        function wrap(innerFn, outerFn, self, tryLocsList) {
            // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
            var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
            var generator = Object.create(protoGenerator.prototype);
            var context = new Context(tryLocsList || []);

            // The ._invoke method unifies the implementations of the .next,
            // .throw, and .return methods.
            generator._invoke = makeInvokeMethod(innerFn, self, context);

            return generator;
        }
        runtime.wrap = wrap;

        // Try/catch helper to minimize deoptimizations. Returns a completion
        // record like context.tryEntries[i].completion. This interface could
        // have been (and was previously) designed to take a closure to be
        // invoked without arguments, but in all the cases we care about we
        // already have an existing method we want to call, so there's no need
        // to create a new function object. We can even get away with assuming
        // the method takes exactly one argument, since that happens to be true
        // in every case, so we don't have to touch the arguments object. The
        // only additional allocation required is the completion record, which
        // has a stable shape and so hopefully should be cheap to allocate.
        function tryCatch(fn, obj, arg) {
            try {
                return { type: "normal", arg: fn.call(obj, arg) };
            } catch (err) {
                return { type: "throw", arg: err };
            }
        }

        var GenStateSuspendedStart = "suspendedStart";
        var GenStateSuspendedYield = "suspendedYield";
        var GenStateExecuting = "executing";
        var GenStateCompleted = "completed";

        // Returning this object from the innerFn has the same effect as
        // breaking out of the dispatch switch statement.
        var ContinueSentinel = {};

        // Dummy constructor functions that we use as the .constructor and
        // .constructor.prototype properties for functions that return Generator
        // objects. For full spec compliance, you may wish to configure your
        // minifier not to mangle the names of these two functions.
        function Generator() {}
        function GeneratorFunction() {}
        function GeneratorFunctionPrototype() {}

        // This is a polyfill for %IteratorPrototype% for environments that
        // don't natively support it.
        var IteratorPrototype = {};
        IteratorPrototype[iteratorSymbol] = function () {
            return this;
        };

        var getProto = Object.getPrototypeOf;
        var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
        if (NativeIteratorPrototype &&
            NativeIteratorPrototype !== Op &&
            hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
            // This environment has a native %IteratorPrototype%; use it instead
            // of the polyfill.
            IteratorPrototype = NativeIteratorPrototype;
        }

        var Gp = GeneratorFunctionPrototype.prototype =
            Generator.prototype = Object.create(IteratorPrototype);
        GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
        GeneratorFunctionPrototype.constructor = GeneratorFunction;
        GeneratorFunctionPrototype[toStringTagSymbol] =
            GeneratorFunction.displayName = "GeneratorFunction";

        // Helper for defining the .next, .throw, and .return methods of the
        // Iterator interface in terms of a single ._invoke method.
        function defineIteratorMethods(prototype) {
            ["next", "throw", "return"].forEach(function(method) {
                prototype[method] = function(arg) {
                    return this._invoke(method, arg);
                };
            });
        }

        runtime.isGeneratorFunction = function(genFun) {
            var ctor = typeof genFun === "function" && genFun.constructor;
            return ctor
                ? ctor === GeneratorFunction ||
                // For the native GeneratorFunction constructor, the best we can
                // do is to check its .name property.
                (ctor.displayName || ctor.name) === "GeneratorFunction"
                : false;
        };

        runtime.mark = function(genFun) {
            if (Object.setPrototypeOf) {
                Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
            } else {
                genFun.__proto__ = GeneratorFunctionPrototype;
                if (!(toStringTagSymbol in genFun)) {
                    genFun[toStringTagSymbol] = "GeneratorFunction";
                }
            }
            genFun.prototype = Object.create(Gp);
            return genFun;
        };

        // Within the body of any async function, `await x` is transformed to
        // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
        // `hasOwn.call(value, "__await")` to determine if the yielded value is
        // meant to be awaited.
        runtime.awrap = function(arg) {
            return { __await: arg };
        };

        function AsyncIterator(generator) {
            function invoke(method, arg, resolve, reject) {
                var record = tryCatch(generator[method], generator, arg);
                if (record.type === "throw") {
                    reject(record.arg);
                } else {
                    var result = record.arg;
                    var value = result.value;
                    if (value &&
                        typeof value === "object" &&
                        hasOwn.call(value, "__await")) {
                        return Promise.resolve(value.__await).then(function(value) {
                            invoke("next", value, resolve, reject);
                        }, function(err) {
                            invoke("throw", err, resolve, reject);
                        });
                    }

                    return Promise.resolve(value).then(function(unwrapped) {
                        // When a yielded Promise is resolved, its final value becomes
                        // the .value of the Promise<{value,done}> result for the
                        // current iteration. If the Promise is rejected, however, the
                        // result for this iteration will be rejected with the same
                        // reason. Note that rejections of yielded Promises are not
                        // thrown back into the generator function, as is the case
                        // when an awaited Promise is rejected. This difference in
                        // behavior between yield and await is important, because it
                        // allows the consumer to decide what to do with the yielded
                        // rejection (swallow it and continue, manually .throw it back
                        // into the generator, abandon iteration, whatever). With
                        // await, by contrast, there is no opportunity to examine the
                        // rejection reason outside the generator function, so the
                        // only option is to throw it from the await expression, and
                        // let the generator function handle the exception.
                        result.value = unwrapped;
                        resolve(result);
                    }, reject);
                }
            }

            var previousPromise;

            function enqueue(method, arg) {
                function callInvokeWithMethodAndArg() {
                    return new Promise(function(resolve, reject) {
                        invoke(method, arg, resolve, reject);
                    });
                }

                return previousPromise =
                    // If enqueue has been called before, then we want to wait until
                    // all previous Promises have been resolved before calling invoke,
                    // so that results are always delivered in the correct order. If
                    // enqueue has not been called before, then it is important to
                    // call invoke immediately, without waiting on a callback to fire,
                    // so that the async generator function has the opportunity to do
                    // any necessary setup in a predictable way. This predictability
                    // is why the Promise constructor synchronously invokes its
                    // executor callback, and why async functions synchronously
                    // execute code before the first await. Since we implement simple
                    // async functions in terms of async generators, it is especially
                    // important to get this right, even though it requires care.
                    previousPromise ? previousPromise.then(
                        callInvokeWithMethodAndArg,
                        // Avoid propagating failures to Promises returned by later
                        // invocations of the iterator.
                        callInvokeWithMethodAndArg
                    ) : callInvokeWithMethodAndArg();
            }

            // Define the unified helper method that is used to implement .next,
            // .throw, and .return (see defineIteratorMethods).
            this._invoke = enqueue;
        }

        defineIteratorMethods(AsyncIterator.prototype);
        AsyncIterator.prototype[asyncIteratorSymbol] = function () {
            return this;
        };
        runtime.AsyncIterator = AsyncIterator;

        // Note that simple async functions are implemented on top of
        // AsyncIterator objects; they just return a Promise for the value of
        // the final result produced by the iterator.
        runtime.async = function(innerFn, outerFn, self, tryLocsList) {
            var iter = new AsyncIterator(
                wrap(innerFn, outerFn, self, tryLocsList)
            );

            return runtime.isGeneratorFunction(outerFn)
                ? iter // If outerFn is a generator, return the full iterator.
                : iter.next().then(function(result) {
                    return result.done ? result.value : iter.next();
                });
        };

        function makeInvokeMethod(innerFn, self, context) {
            var state = GenStateSuspendedStart;

            return function invoke(method, arg) {
                if (state === GenStateExecuting) {
                    throw new Error("Generator is already running");
                }

                if (state === GenStateCompleted) {
                    if (method === "throw") {
                        throw arg;
                    }

                    // Be forgiving, per 25.3.3.3.3 of the spec:
                    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
                    return doneResult();
                }

                context.method = method;
                context.arg = arg;

                while (true) {
                    var delegate = context.delegate;
                    if (delegate) {
                        var delegateResult = maybeInvokeDelegate(delegate, context);
                        if (delegateResult) {
                            if (delegateResult === ContinueSentinel) continue;
                            return delegateResult;
                        }
                    }

                    if (context.method === "next") {
                        // Setting context._sent for legacy support of Babel's
                        // function.sent implementation.
                        context.sent = context._sent = context.arg;

                    } else if (context.method === "throw") {
                        if (state === GenStateSuspendedStart) {
                            state = GenStateCompleted;
                            throw context.arg;
                        }

                        context.dispatchException(context.arg);

                    } else if (context.method === "return") {
                        context.abrupt("return", context.arg);
                    }

                    state = GenStateExecuting;

                    var record = tryCatch(innerFn, self, context);
                    if (record.type === "normal") {
                        // If an exception is thrown from innerFn, we leave state ===
                        // GenStateExecuting and loop back for another invocation.
                        state = context.done
                            ? GenStateCompleted
                            : GenStateSuspendedYield;

                        if (record.arg === ContinueSentinel) {
                            continue;
                        }

                        return {
                            value: record.arg,
                            done: context.done
                        };

                    } else if (record.type === "throw") {
                        state = GenStateCompleted;
                        // Dispatch the exception by looping back around to the
                        // context.dispatchException(context.arg) call above.
                        context.method = "throw";
                        context.arg = record.arg;
                    }
                }
            };
        }

        // Call delegate.iterator[context.method](context.arg) and handle the
        // result, either by returning a { value, done } result from the
        // delegate iterator, or by modifying context.method and context.arg,
        // setting context.delegate to null, and returning the ContinueSentinel.
        function maybeInvokeDelegate(delegate, context) {
            var method = delegate.iterator[context.method];
            if (method === undefined) {
                // A .throw or .return when the delegate iterator has no .throw
                // method always terminates the yield* loop.
                context.delegate = null;

                if (context.method === "throw") {
                    if (delegate.iterator.return) {
                        // If the delegate iterator has a return method, give it a
                        // chance to clean up.
                        context.method = "return";
                        context.arg = undefined;
                        maybeInvokeDelegate(delegate, context);

                        if (context.method === "throw") {
                            // If maybeInvokeDelegate(context) changed context.method from
                            // "return" to "throw", let that override the TypeError below.
                            return ContinueSentinel;
                        }
                    }

                    context.method = "throw";
                    context.arg = new TypeError(
                        "The iterator does not provide a 'throw' method");
                }

                return ContinueSentinel;
            }

            var record = tryCatch(method, delegate.iterator, context.arg);

            if (record.type === "throw") {
                context.method = "throw";
                context.arg = record.arg;
                context.delegate = null;
                return ContinueSentinel;
            }

            var info = record.arg;

            if (! info) {
                context.method = "throw";
                context.arg = new TypeError("iterator result is not an object");
                context.delegate = null;
                return ContinueSentinel;
            }

            if (info.done) {
                // Assign the result of the finished delegate to the temporary
                // variable specified by delegate.resultName (see delegateYield).
                context[delegate.resultName] = info.value;

                // Resume execution at the desired location (see delegateYield).
                context.next = delegate.nextLoc;

                // If context.method was "throw" but the delegate handled the
                // exception, let the outer generator proceed normally. If
                // context.method was "next", forget context.arg since it has been
                // "consumed" by the delegate iterator. If context.method was
                // "return", allow the original .return call to continue in the
                // outer generator.
                if (context.method !== "return") {
                    context.method = "next";
                    context.arg = undefined;
                }

            } else {
                // Re-yield the result returned by the delegate method.
                return info;
            }

            // The delegate iterator is finished, so forget it and continue with
            // the outer generator.
            context.delegate = null;
            return ContinueSentinel;
        }

        // Define Generator.prototype.{next,throw,return} in terms of the
        // unified ._invoke helper method.
        defineIteratorMethods(Gp);

        Gp[toStringTagSymbol] = "Generator";

        // A Generator should always return itself as the iterator object when the
        // @@iterator function is called on it. Some browsers' implementations of the
        // iterator prototype chain incorrectly implement this, causing the Generator
        // object to not be returned from this call. This ensures that doesn't happen.
        // See https://github.com/facebook/regenerator/issues/274 for more details.
        Gp[iteratorSymbol] = function() {
            return this;
        };

        Gp.toString = function() {
            return "[object Generator]";
        };

        function pushTryEntry(locs) {
            var entry = { tryLoc: locs[0] };

            if (1 in locs) {
                entry.catchLoc = locs[1];
            }

            if (2 in locs) {
                entry.finallyLoc = locs[2];
                entry.afterLoc = locs[3];
            }

            this.tryEntries.push(entry);
        }

        function resetTryEntry(entry) {
            var record = entry.completion || {};
            record.type = "normal";
            delete record.arg;
            entry.completion = record;
        }

        function Context(tryLocsList) {
            // The root entry object (effectively a try statement without a catch
            // or a finally block) gives us a place to store values thrown from
            // locations where there is no enclosing try statement.
            this.tryEntries = [{ tryLoc: "root" }];
            tryLocsList.forEach(pushTryEntry, this);
            this.reset(true);
        }

        runtime.keys = function(object) {
            var keys = [];
            for (var key in object) {
                keys.push(key);
            }
            keys.reverse();

            // Rather than returning an object with a next method, we keep
            // things simple and return the next function itself.
            return function next() {
                while (keys.length) {
                    var key = keys.pop();
                    if (key in object) {
                        next.value = key;
                        next.done = false;
                        return next;
                    }
                }

                // To avoid creating an additional object, we just hang the .value
                // and .done properties off the next function object itself. This
                // also ensures that the minifier will not anonymize the function.
                next.done = true;
                return next;
            };
        };

        function values(iterable) {
            if (iterable) {
                var iteratorMethod = iterable[iteratorSymbol];
                if (iteratorMethod) {
                    return iteratorMethod.call(iterable);
                }

                if (typeof iterable.next === "function") {
                    return iterable;
                }

                if (!isNaN(iterable.length)) {
                    var i = -1, next = function next() {
                        while (++i < iterable.length) {
                            if (hasOwn.call(iterable, i)) {
                                next.value = iterable[i];
                                next.done = false;
                                return next;
                            }
                        }

                        next.value = undefined;
                        next.done = true;

                        return next;
                    };

                    return next.next = next;
                }
            }

            // Return an iterator with no values.
            return { next: doneResult };
        }
        runtime.values = values;

        function doneResult() {
            return { value: undefined, done: true };
        }

        Context.prototype = {
            constructor: Context,

            reset: function(skipTempReset) {
                this.prev = 0;
                this.next = 0;
                // Resetting context._sent for legacy support of Babel's
                // function.sent implementation.
                this.sent = this._sent = undefined;
                this.done = false;
                this.delegate = null;

                this.method = "next";
                this.arg = undefined;

                this.tryEntries.forEach(resetTryEntry);

                if (!skipTempReset) {
                    for (var name in this) {
                        // Not sure about the optimal order of these conditions:
                        if (name.charAt(0) === "t" &&
                            hasOwn.call(this, name) &&
                            !isNaN(+name.slice(1))) {
                            this[name] = undefined;
                        }
                    }
                }
            },

            stop: function() {
                this.done = true;

                var rootEntry = this.tryEntries[0];
                var rootRecord = rootEntry.completion;
                if (rootRecord.type === "throw") {
                    throw rootRecord.arg;
                }

                return this.rval;
            },

            dispatchException: function(exception) {
                if (this.done) {
                    throw exception;
                }

                var context = this;
                function handle(loc, caught) {
                    record.type = "throw";
                    record.arg = exception;
                    context.next = loc;

                    if (caught) {
                        // If the dispatched exception was caught by a catch block,
                        // then let that catch block handle the exception normally.
                        context.method = "next";
                        context.arg = undefined;
                    }

                    return !! caught;
                }

                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                    var entry = this.tryEntries[i];
                    var record = entry.completion;

                    if (entry.tryLoc === "root") {
                        // Exception thrown outside of any try block that could handle
                        // it, so set the completion value of the entire function to
                        // throw the exception.
                        return handle("end");
                    }

                    if (entry.tryLoc <= this.prev) {
                        var hasCatch = hasOwn.call(entry, "catchLoc");
                        var hasFinally = hasOwn.call(entry, "finallyLoc");

                        if (hasCatch && hasFinally) {
                            if (this.prev < entry.catchLoc) {
                                return handle(entry.catchLoc, true);
                            } else if (this.prev < entry.finallyLoc) {
                                return handle(entry.finallyLoc);
                            }

                        } else if (hasCatch) {
                            if (this.prev < entry.catchLoc) {
                                return handle(entry.catchLoc, true);
                            }

                        } else if (hasFinally) {
                            if (this.prev < entry.finallyLoc) {
                                return handle(entry.finallyLoc);
                            }

                        } else {
                            throw new Error("try statement without catch or finally");
                        }
                    }
                }
            },

            abrupt: function(type, arg) {
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                    var entry = this.tryEntries[i];
                    if (entry.tryLoc <= this.prev &&
                        hasOwn.call(entry, "finallyLoc") &&
                        this.prev < entry.finallyLoc) {
                        var finallyEntry = entry;
                        break;
                    }
                }

                if (finallyEntry &&
                    (type === "break" ||
                        type === "continue") &&
                    finallyEntry.tryLoc <= arg &&
                    arg <= finallyEntry.finallyLoc) {
                    // Ignore the finally entry if control is not jumping to a
                    // location outside the try/catch block.
                    finallyEntry = null;
                }

                var record = finallyEntry ? finallyEntry.completion : {};
                record.type = type;
                record.arg = arg;

                if (finallyEntry) {
                    this.method = "next";
                    this.next = finallyEntry.finallyLoc;
                    return ContinueSentinel;
                }

                return this.complete(record);
            },

            complete: function(record, afterLoc) {
                if (record.type === "throw") {
                    throw record.arg;
                }

                if (record.type === "break" ||
                    record.type === "continue") {
                    this.next = record.arg;
                } else if (record.type === "return") {
                    this.rval = this.arg = record.arg;
                    this.method = "return";
                    this.next = "end";
                } else if (record.type === "normal" && afterLoc) {
                    this.next = afterLoc;
                }

                return ContinueSentinel;
            },

            finish: function(finallyLoc) {
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                    var entry = this.tryEntries[i];
                    if (entry.finallyLoc === finallyLoc) {
                        this.complete(entry.completion, entry.afterLoc);
                        resetTryEntry(entry);
                        return ContinueSentinel;
                    }
                }
            },

            "catch": function(tryLoc) {
                for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                    var entry = this.tryEntries[i];
                    if (entry.tryLoc === tryLoc) {
                        var record = entry.completion;
                        if (record.type === "throw") {
                            var thrown = record.arg;
                            resetTryEntry(entry);
                        }
                        return thrown;
                    }
                }

                // The context.catch method must only be called with a location
                // argument that corresponds to a known catch block.
                throw new Error("illegal catch attempt");
            },

            delegateYield: function(iterable, resultName, nextLoc) {
                this.delegate = {
                    iterator: values(iterable),
                    resultName: resultName,
                    nextLoc: nextLoc
                };

                if (this.method === "next") {
                    // Deliberately forget the last sent value so that we don't
                    // accidentally pass it on to the delegate.
                    this.arg = undefined;
                }

                return ContinueSentinel;
            }
        };
    })(
        // In sloppy mode, unbound `this` refers to the global object, fallback to
        // Function constructor if we're in global strict mode. That is sadly a form
        // of indirect eval which violates Content Security Policy.
        (function() { return this })() || Function("return this")()
    );

    (function (exports) {
        'use strict';

        function createCommonjsModule(fn, module) {
            return module = {
                exports: {}
            }, fn(module, module.exports), module.exports;
        }

        var _global = createCommonjsModule(function (module) {
            // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
            var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
                : Function('return this')();
            if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
        });

        var hasOwnProperty = {}.hasOwnProperty;

        var _has = function (it, key) {
            return hasOwnProperty.call(it, key);
        };

        var _fails = function (exec) {
            try {
                return !!exec();
            } catch (e) {
                return true;
            }
        };

        // Thank's IE8 for his funny defineProperty
        var _descriptors = !_fails(function () {
            return Object.defineProperty({}, 'a', {
                get: function get() {
                    return 7;
                }
            }).a != 7;
        });

        var _core = createCommonjsModule(function (module) {
            var core = module.exports = {
                version: '2.6.3'
            };
            if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
        });
        var _core_1 = _core.version;

        var _isObject = function (it) {
            return babelHelpers.typeof(it) === 'object' ? it !== null : typeof it === 'function';
        };

        var _anObject = function (it) {
            if (!_isObject(it)) throw TypeError(it + ' is not an object!');
            return it;
        };

        var document$1 = _global.document; // typeof document.createElement is 'object' in old IE


        var is = _isObject(document$1) && _isObject(document$1.createElement);

        var _domCreate = function (it) {
            return is ? document$1.createElement(it) : {};
        };

        var _ie8DomDefine = !_descriptors && !_fails(function () {
            return Object.defineProperty(_domCreate('div'), 'a', {
                get: function get() {
                    return 7;
                }
            }).a != 7;
        });

        // 7.1.1 ToPrimitive(input [, PreferredType])
        // instead of the ES6 spec version, we didn't implement @@toPrimitive case
        // and the second argument - flag - preferred type is a string


        var _toPrimitive = function (it, S) {
            if (!_isObject(it)) return it;
            var fn, val;
            if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
            if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
            if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
            throw TypeError("Can't convert object to primitive value");
        };

        var dP = Object.defineProperty;
        var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
            _anObject(O);
            P = _toPrimitive(P, true);
            _anObject(Attributes);
            if (_ie8DomDefine) try {
                return dP(O, P, Attributes);
            } catch (e) {
                /* empty */
            }
            if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
            if ('value' in Attributes) O[P] = Attributes.value;
            return O;
        };

        var _objectDp = {
            f: f
        };

        var _propertyDesc = function (bitmap, value) {
            return {
                enumerable: !(bitmap & 1),
                configurable: !(bitmap & 2),
                writable: !(bitmap & 4),
                value: value
            };
        };

        var _hide = _descriptors ? function (object, key, value) {
            return _objectDp.f(object, key, _propertyDesc(1, value));
        } : function (object, key, value) {
            object[key] = value;
            return object;
        };

        var id = 0;
        var px = Math.random();

        var _uid = function (key) {
            return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
        };

        var _redefine = createCommonjsModule(function (module) {
            var SRC = _uid('src');

            var TO_STRING = 'toString';
            var $toString = Function[TO_STRING];
            var TPL = ('' + $toString).split(TO_STRING);

            _core.inspectSource = function (it) {
                return $toString.call(it);
            };

            (module.exports = function (O, key, val, safe) {
                var isFunction = typeof val == 'function';
                if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
                if (O[key] === val) return;
                if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

                if (O === _global) {
                    O[key] = val;
                } else if (!safe) {
                    delete O[key];
                    _hide(O, key, val);
                } else if (O[key]) {
                    O[key] = val;
                } else {
                    _hide(O, key, val);
                } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

            })(Function.prototype, TO_STRING, function toString() {
                return typeof this == 'function' && this[SRC] || $toString.call(this);
            });
        });

        var _aFunction = function (it) {
            if (typeof it != 'function') throw TypeError(it + ' is not a function!');
            return it;
        };

        // optional / simple context binding


        var _ctx = function (fn, that, length) {
            _aFunction(fn);
            if (that === undefined) return fn;

            switch (length) {
                case 1:
                    return function (a) {
                        return fn.call(that, a);
                    };

                case 2:
                    return function (a, b) {
                        return fn.call(that, a, b);
                    };

                case 3:
                    return function (a, b, c) {
                        return fn.call(that, a, b, c);
                    };
            }

            return function ()
                /* ...args */
            {
                return fn.apply(that, arguments);
            };
        };

        var PROTOTYPE = 'prototype';

        var $export = function $export(type, name, source) {
            var IS_FORCED = type & $export.F;
            var IS_GLOBAL = type & $export.G;
            var IS_STATIC = type & $export.S;
            var IS_PROTO = type & $export.P;
            var IS_BIND = type & $export.B;
            var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
            var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
            var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
            var key, own, out, exp;
            if (IS_GLOBAL) source = name;

            for (key in source) {
                // contains in native
                own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

                out = (own ? target : source)[key]; // bind timers to global for call from export context

                exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out; // extend global

                if (target) _redefine(target, key, out, type & $export.U); // export

                if (exports[key] != out) _hide(exports, key, exp);
                if (IS_PROTO && expProto[key] != out) expProto[key] = out;
            }
        };

        $export.F = 1; // forced

        $export.G = 2; // global

        $export.S = 4; // static

        $export.P = 8; // proto

        $export.B = 16; // bind

        $export.W = 32; // wrap

        $export.U = 64; // safe

        $export.R = 128; // real proto method for `library`

        var _export = $export;

        var _meta = createCommonjsModule(function (module) {
            var META = _uid('meta');





            var setDesc = _objectDp.f;

            var id = 0;

            var isExtensible = Object.isExtensible || function () {
                return true;
            };

            var FREEZE = !_fails(function () {
                return isExtensible(Object.preventExtensions({}));
            });

            var setMeta = function setMeta(it) {
                setDesc(it, META, {
                    value: {
                        i: 'O' + ++id,
                        // object ID
                        w: {} // weak collections IDs

                    }
                });
            };

            var fastKey = function fastKey(it, create) {
                // return primitive with prefix
                if (!_isObject(it)) return babelHelpers.typeof(it) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

                if (!_has(it, META)) {
                    // can't set metadata to uncaught frozen object
                    if (!isExtensible(it)) return 'F'; // not necessary to add metadata

                    if (!create) return 'E'; // add missing metadata

                    setMeta(it); // return object ID
                }

                return it[META].i;
            };

            var getWeak = function getWeak(it, create) {
                if (!_has(it, META)) {
                    // can't set metadata to uncaught frozen object
                    if (!isExtensible(it)) return true; // not necessary to add metadata

                    if (!create) return false; // add missing metadata

                    setMeta(it); // return hash weak collections IDs
                }

                return it[META].w;
            }; // add metadata on freeze-family methods calling


            var onFreeze = function onFreeze(it) {
                if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
                return it;
            };

            var meta = module.exports = {
                KEY: META,
                NEED: false,
                fastKey: fastKey,
                getWeak: getWeak,
                onFreeze: onFreeze
            };
        });
        var _meta_1 = _meta.KEY;
        var _meta_2 = _meta.NEED;
        var _meta_3 = _meta.fastKey;
        var _meta_4 = _meta.getWeak;
        var _meta_5 = _meta.onFreeze;

        var _library = false;

        var _shared = createCommonjsModule(function (module) {
            var SHARED = '__core-js_shared__';
            var store = _global[SHARED] || (_global[SHARED] = {});
            (module.exports = function (key, value) {
                return store[key] || (store[key] = value !== undefined ? value : {});
            })('versions', []).push({
                version: _core.version,
                mode: _library ? 'pure' : 'global',
                copyright: '(c) 2019 Denis Pushkarev (zloirock.ru)'
            });
        });

        var _wks = createCommonjsModule(function (module) {
            var store = _shared('wks');



            var _Symbol = _global.Symbol;

            var USE_SYMBOL = typeof _Symbol == 'function';

            var $exports = module.exports = function (name) {
                return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : _uid)('Symbol.' + name));
            };

            $exports.store = store;
        });

        var def = _objectDp.f;



        var TAG = _wks('toStringTag');

        var _setToStringTag = function (it, tag, stat) {
            if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
                configurable: true,
                value: tag
            });
        };

        var f$1 = _wks;

        var _wksExt = {
            f: f$1
        };

        var defineProperty = _objectDp.f;

        var _wksDefine = function (name) {
            var $Symbol = _core.Symbol || (_core.Symbol = _library ? {} : _global.Symbol || {});
            if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
                value: _wksExt.f(name)
            });
        };

        var toString = {}.toString;

        var _cof = function (it) {
            return toString.call(it).slice(8, -1);
        };

        // fallback for non-array-like ES3 and non-enumerable old V8 strings
        // eslint-disable-next-line no-prototype-builtins


        var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
            return _cof(it) == 'String' ? it.split('') : Object(it);
        };

        // 7.2.1 RequireObjectCoercible(argument)
        var _defined = function (it) {
            if (it == undefined) throw TypeError("Can't call method on  " + it);
            return it;
        };

        // to indexed object, toObject with fallback for non-array-like ES3 strings




        var _toIobject = function (it) {
            return _iobject(_defined(it));
        };

        // 7.1.4 ToInteger
        var ceil = Math.ceil;
        var floor = Math.floor;

        var _toInteger = function (it) {
            return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
        };

        // 7.1.15 ToLength


        var min = Math.min;

        var _toLength = function (it) {
            return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
        };

        var max = Math.max;
        var min$1 = Math.min;

        var _toAbsoluteIndex = function (index, length) {
            index = _toInteger(index);
            return index < 0 ? max(index + length, 0) : min$1(index, length);
        };

        // false -> Array#indexOf
        // true  -> Array#includes






        var _arrayIncludes = function (IS_INCLUDES) {
            return function ($this, el, fromIndex) {
                var O = _toIobject($this);
                var length = _toLength(O.length);
                var index = _toAbsoluteIndex(fromIndex, length);
                var value; // Array#includes uses SameValueZero equality algorithm
                // eslint-disable-next-line no-self-compare

                if (IS_INCLUDES && el != el) while (length > index) {
                    value = O[index++]; // eslint-disable-next-line no-self-compare

                    if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
                } else for (; length > index; index++) {
                    if (IS_INCLUDES || index in O) {
                        if (O[index] === el) return IS_INCLUDES || index || 0;
                    }
                }
                return !IS_INCLUDES && -1;
            };
        };

        var shared = _shared('keys');



        var _sharedKey = function (key) {
            return shared[key] || (shared[key] = _uid(key));
        };

        var arrayIndexOf = _arrayIncludes(false);

        var IE_PROTO = _sharedKey('IE_PROTO');

        var _objectKeysInternal = function (object, names) {
            var O = _toIobject(object);
            var i = 0;
            var result = [];
            var key;

            for (key in O) {
                if (key != IE_PROTO) _has(O, key) && result.push(key);
            } // Don't enum bug & hidden keys


            while (names.length > i) {
                if (_has(O, key = names[i++])) {
                    ~arrayIndexOf(result, key) || result.push(key);
                }
            }

            return result;
        };

        // IE 8- don't enum bug keys
        var _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

        // 19.1.2.14 / 15.2.3.14 Object.keys(O)




        var _objectKeys = Object.keys || function keys(O) {
            return _objectKeysInternal(O, _enumBugKeys);
        };

        var f$2 = Object.getOwnPropertySymbols;

        var _objectGops = {
            f: f$2
        };

        var f$3 = {}.propertyIsEnumerable;

        var _objectPie = {
            f: f$3
        };

        // all enumerable object keys, includes symbols






        var _enumKeys = function (it) {
            var result = _objectKeys(it);
            var getSymbols = _objectGops.f;

            if (getSymbols) {
                var symbols = getSymbols(it);
                var isEnum = _objectPie.f;
                var i = 0;
                var key;

                while (symbols.length > i) {
                    if (isEnum.call(it, key = symbols[i++])) result.push(key);
                }
            }

            return result;
        };

        // 7.2.2 IsArray(argument)


        var _isArray = Array.isArray || function isArray(arg) {
            return _cof(arg) == 'Array';
        };

        var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
            _anObject(O);
            var keys = _objectKeys(Properties);
            var length = keys.length;
            var i = 0;
            var P;

            while (length > i) {
                _objectDp.f(O, P = keys[i++], Properties[P]);
            }

            return O;
        };

        var document$2 = _global.document;

        var _html = document$2 && document$2.documentElement;

        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])






        var IE_PROTO$1 = _sharedKey('IE_PROTO');

        var Empty = function Empty() {
            /* empty */
        };

        var PROTOTYPE$1 = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

        var _createDict = function createDict() {
            // Thrash, waste and sodomy: IE GC bug
            var iframe = _domCreate('iframe');

            var i = _enumBugKeys.length;
            var lt = '<';
            var gt = '>';
            var iframeDocument;
            iframe.style.display = 'none';

            _html.appendChild(iframe);

            iframe.src = 'javascript:'; // eslint-disable-line no-script-url
            // createDict = iframe.contentWindow.Object;
            // html.removeChild(iframe);

            iframeDocument = iframe.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
            iframeDocument.close();
            _createDict = iframeDocument.F;

            while (i--) {
                delete _createDict[PROTOTYPE$1][_enumBugKeys[i]];
            }

            return _createDict();
        };

        var _objectCreate = Object.create || function create(O, Properties) {
            var result;

            if (O !== null) {
                Empty[PROTOTYPE$1] = _anObject(O);
                result = new Empty();
                Empty[PROTOTYPE$1] = null; // add "__proto__" for Object.getPrototypeOf polyfill

                result[IE_PROTO$1] = O;
            } else result = _createDict();

            return Properties === undefined ? result : _objectDps(result, Properties);
        };

        // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)


        var hiddenKeys = _enumBugKeys.concat('length', 'prototype');

        var f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
            return _objectKeysInternal(O, hiddenKeys);
        };

        var _objectGopn = {
            f: f$4
        };

        // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window


        var gOPN = _objectGopn.f;

        var toString$1 = {}.toString;
        var windowNames = (typeof window === "undefined" ? "undefined" : babelHelpers.typeof(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

        var getWindowNames = function getWindowNames(it) {
            try {
                return gOPN(it);
            } catch (e) {
                return windowNames.slice();
            }
        };

        var f$5 = function getOwnPropertyNames(it) {
            return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(_toIobject(it));
        };

        var _objectGopnExt = {
            f: f$5
        };

        var gOPD = Object.getOwnPropertyDescriptor;
        var f$6 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
            O = _toIobject(O);
            P = _toPrimitive(P, true);
            if (_ie8DomDefine) try {
                return gOPD(O, P);
            } catch (e) {
                /* empty */
            }
            if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
        };

        var _objectGopd = {
            f: f$6
        };

        var META = _meta.KEY;







































        var gOPD$1 = _objectGopd.f;
        var dP$1 = _objectDp.f;
        var gOPN$1 = _objectGopnExt.f;
        var $Symbol = _global.Symbol;
        var $JSON = _global.JSON;

        var _stringify = $JSON && $JSON.stringify;

        var PROTOTYPE$2 = 'prototype';
        var HIDDEN = _wks('_hidden');
        var TO_PRIMITIVE = _wks('toPrimitive');
        var isEnum = {}.propertyIsEnumerable;
        var SymbolRegistry = _shared('symbol-registry');
        var AllSymbols = _shared('symbols');
        var OPSymbols = _shared('op-symbols');
        var ObjectProto = Object[PROTOTYPE$2];
        var USE_NATIVE = typeof $Symbol == 'function';
        var QObject = _global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

        var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

        var setSymbolDesc = _descriptors && _fails(function () {
            return _objectCreate(dP$1({}, 'a', {
                get: function get() {
                    return dP$1(this, 'a', {
                        value: 7
                    }).a;
                }
            })).a != 7;
        }) ? function (it, key, D) {
            var protoDesc = gOPD$1(ObjectProto, key);
            if (protoDesc) delete ObjectProto[key];
            dP$1(it, key, D);
            if (protoDesc && it !== ObjectProto) dP$1(ObjectProto, key, protoDesc);
        } : dP$1;

        var wrap = function wrap(tag) {
            var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]);

            sym._k = tag;
            return sym;
        };

        var isSymbol = USE_NATIVE && babelHelpers.typeof($Symbol.iterator) == 'symbol' ? function (it) {
            return babelHelpers.typeof(it) == 'symbol';
        } : function (it) {
            return it instanceof $Symbol;
        };

        var $defineProperty = function defineProperty(it, key, D) {
            if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
            _anObject(it);
            key = _toPrimitive(key, true);
            _anObject(D);

            if (_has(AllSymbols, key)) {
                if (!D.enumerable) {
                    if (!_has(it, HIDDEN)) dP$1(it, HIDDEN, _propertyDesc(1, {}));
                    it[HIDDEN][key] = true;
                } else {
                    if (_has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
                    D = _objectCreate(D, {
                        enumerable: _propertyDesc(0, false)
                    });
                }

                return setSymbolDesc(it, key, D);
            }

            return dP$1(it, key, D);
        };

        var $defineProperties = function defineProperties(it, P) {
            _anObject(it);
            var keys = _enumKeys(P = _toIobject(P));
            var i = 0;
            var l = keys.length;
            var key;

            while (l > i) {
                $defineProperty(it, key = keys[i++], P[key]);
            }

            return it;
        };

        var $create = function create(it, P) {
            return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
        };

        var $propertyIsEnumerable = function propertyIsEnumerable(key) {
            var E = isEnum.call(this, key = _toPrimitive(key, true));
            if (this === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return false;
            return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
        };

        var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
            it = _toIobject(it);
            key = _toPrimitive(key, true);
            if (it === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return;
            var D = gOPD$1(it, key);
            if (D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
            return D;
        };

        var $getOwnPropertyNames = function getOwnPropertyNames(it) {
            var names = gOPN$1(_toIobject(it));
            var result = [];
            var i = 0;
            var key;

            while (names.length > i) {
                if (!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
            }

            return result;
        };

        var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
            var IS_OP = it === ObjectProto;
            var names = gOPN$1(IS_OP ? OPSymbols : _toIobject(it));
            var result = [];
            var i = 0;
            var key;

            while (names.length > i) {
                if (_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
            }

            return result;
        }; // 19.4.1.1 Symbol([description])


        if (!USE_NATIVE) {
            $Symbol = function _Symbol() {
                if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
                var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);

                var $set = function $set(value) {
                    if (this === ObjectProto) $set.call(OPSymbols, value);
                    if (_has(this, HIDDEN) && _has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
                    setSymbolDesc(this, tag, _propertyDesc(1, value));
                };

                if (_descriptors && setter) setSymbolDesc(ObjectProto, tag, {
                    configurable: true,
                    set: $set
                });
                return wrap(tag);
            };

            _redefine($Symbol[PROTOTYPE$2], 'toString', function toString() {
                return this._k;
            });
            _objectGopd.f = $getOwnPropertyDescriptor;
            _objectDp.f = $defineProperty;
            _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
            _objectPie.f = $propertyIsEnumerable;
            _objectGops.f = $getOwnPropertySymbols;

            if (_descriptors && !_library) {
                _redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
            }

            _wksExt.f = function (name) {
                return wrap(_wks(name));
            };
        }

        _export(_export.G + _export.W + _export.F * !USE_NATIVE, {
            Symbol: $Symbol
        });

        for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
            'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
            _wks(es6Symbols[j++]);
        }

        for (var wellKnownSymbols = _objectKeys(_wks.store), k = 0; wellKnownSymbols.length > k;) {
            _wksDefine(wellKnownSymbols[k++]);
        }

        _export(_export.S + _export.F * !USE_NATIVE, 'Symbol', {
            // 19.4.2.1 Symbol.for(key)
            'for': function _for(key) {
                return _has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
            },
            // 19.4.2.5 Symbol.keyFor(sym)
            keyFor: function keyFor(sym) {
                if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');

                for (var key in SymbolRegistry) {
                    if (SymbolRegistry[key] === sym) return key;
                }
            },
            useSetter: function useSetter() {
                setter = true;
            },
            useSimple: function useSimple() {
                setter = false;
            }
        });
        _export(_export.S + _export.F * !USE_NATIVE, 'Object', {
            // 19.1.2.2 Object.create(O [, Properties])
            create: $create,
            // 19.1.2.4 Object.defineProperty(O, P, Attributes)
            defineProperty: $defineProperty,
            // 19.1.2.3 Object.defineProperties(O, Properties)
            defineProperties: $defineProperties,
            // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
            getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
            // 19.1.2.7 Object.getOwnPropertyNames(O)
            getOwnPropertyNames: $getOwnPropertyNames,
            // 19.1.2.8 Object.getOwnPropertySymbols(O)
            getOwnPropertySymbols: $getOwnPropertySymbols
        }); // 24.3.2 JSON.stringify(value [, replacer [, space]])

        $JSON && _export(_export.S + _export.F * (!USE_NATIVE || _fails(function () {
            var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
            // WebKit converts symbol values to JSON as null
            // V8 throws on boxed symbols

            return _stringify([S]) != '[null]' || _stringify({
                a: S
            }) != '{}' || _stringify(Object(S)) != '{}';
        })), 'JSON', {
            stringify: function stringify(it) {
                var args = [it];
                var i = 1;
                var replacer, $replacer;

                while (arguments.length > i) {
                    args.push(arguments[i++]);
                }

                $replacer = replacer = args[1];
                if (!_isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

                if (!_isArray(replacer)) replacer = function replacer(key, value) {
                    if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
                    if (!isSymbol(value)) return value;
                };
                args[1] = replacer;
                return _stringify.apply($JSON, args);
            }
        }); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

        $Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]

        _setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]

        _setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]

        _setToStringTag(_global.JSON, 'JSON', true);

        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


        _export(_export.S, 'Object', {
            create: _objectCreate
        });

        // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)


        _export(_export.S + _export.F * !_descriptors, 'Object', {
            defineProperty: _objectDp.f
        });

        // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)


        _export(_export.S + _export.F * !_descriptors, 'Object', {
            defineProperties: _objectDps
        });

        // most Object methods by ES6 should accept primitives






        var _objectSap = function (KEY, exec) {
            var fn = (_core.Object || {})[KEY] || Object[KEY];
            var exp = {};
            exp[KEY] = exec(fn);
            _export(_export.S + _export.F * _fails(function () {
                fn(1);
            }), 'Object', exp);
        };

        // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)


        var $getOwnPropertyDescriptor$1 = _objectGopd.f;

        _objectSap('getOwnPropertyDescriptor', function () {
            return function getOwnPropertyDescriptor(it, key) {
                return $getOwnPropertyDescriptor$1(_toIobject(it), key);
            };
        });

        // 7.1.13 ToObject(argument)


        var _toObject = function (it) {
            return Object(_defined(it));
        };

        // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)




        var IE_PROTO$2 = _sharedKey('IE_PROTO');

        var ObjectProto$1 = Object.prototype;

        var _objectGpo = Object.getPrototypeOf || function (O) {
            O = _toObject(O);
            if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];

            if (typeof O.constructor == 'function' && O instanceof O.constructor) {
                return O.constructor.prototype;
            }

            return O instanceof Object ? ObjectProto$1 : null;
        };

        // 19.1.2.9 Object.getPrototypeOf(O)




        _objectSap('getPrototypeOf', function () {
            return function getPrototypeOf(it) {
                return _objectGpo(_toObject(it));
            };
        });

        // 19.1.2.14 Object.keys(O)




        _objectSap('keys', function () {
            return function keys(it) {
                return _objectKeys(_toObject(it));
            };
        });

        // 19.1.2.7 Object.getOwnPropertyNames(O)
        _objectSap('getOwnPropertyNames', function () {
            return _objectGopnExt.f;
        });

        // 19.1.2.5 Object.freeze(O)


        var meta = _meta.onFreeze;

        _objectSap('freeze', function ($freeze) {
            return function freeze(it) {
                return $freeze && _isObject(it) ? $freeze(meta(it)) : it;
            };
        });

        // 19.1.2.17 Object.seal(O)


        var meta$1 = _meta.onFreeze;

        _objectSap('seal', function ($seal) {
            return function seal(it) {
                return $seal && _isObject(it) ? $seal(meta$1(it)) : it;
            };
        });

        // 19.1.2.15 Object.preventExtensions(O)


        var meta$2 = _meta.onFreeze;

        _objectSap('preventExtensions', function ($preventExtensions) {
            return function preventExtensions(it) {
                return $preventExtensions && _isObject(it) ? $preventExtensions(meta$2(it)) : it;
            };
        });

        // 19.1.2.12 Object.isFrozen(O)


        _objectSap('isFrozen', function ($isFrozen) {
            return function isFrozen(it) {
                return _isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
            };
        });

        // 19.1.2.13 Object.isSealed(O)


        _objectSap('isSealed', function ($isSealed) {
            return function isSealed(it) {
                return _isObject(it) ? $isSealed ? $isSealed(it) : false : true;
            };
        });

        // 19.1.2.11 Object.isExtensible(O)


        _objectSap('isExtensible', function ($isExtensible) {
            return function isExtensible(it) {
                return _isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
            };
        });

        var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

        var _objectAssign = !$assign || _fails(function () {
            var A = {};
            var B = {}; // eslint-disable-next-line no-undef

            var S = Symbol();
            var K = 'abcdefghijklmnopqrst';
            A[S] = 7;
            K.split('').forEach(function (k) {
                B[k] = k;
            });
            return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
        }) ? function assign(target, source) {
            // eslint-disable-line no-unused-vars
            var T = _toObject(target);
            var aLen = arguments.length;
            var index = 1;
            var getSymbols = _objectGops.f;
            var isEnum = _objectPie.f;

            while (aLen > index) {
                var S = _iobject(arguments[index++]);
                var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
                var length = keys.length;
                var j = 0;
                var key;

                while (length > j) {
                    if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
                }
            }

            return T;
        } : $assign;

        // 19.1.3.1 Object.assign(target, source)


        _export(_export.S + _export.F, 'Object', {
            assign: _objectAssign
        });

        // 7.2.9 SameValue(x, y)
        var _sameValue = Object.is || function is(x, y) {
            // eslint-disable-next-line no-self-compare
            return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
        };

        // 19.1.3.10 Object.is(value1, value2)


        _export(_export.S, 'Object', {
            is: _sameValue
        });

        // Works with __proto__ only. Old v8 can't work with null proto objects.

        /* eslint-disable no-proto */




        var check = function check(O, proto) {
            _anObject(O);
            if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
        };

        var _setProto = {
            set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
                function (test, buggy, set) {
                    try {
                        set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
                        set(test, []);
                        buggy = !(test instanceof Array);
                    } catch (e) {
                        buggy = true;
                    }

                    return function setPrototypeOf(O, proto) {
                        check(O, proto);
                        if (buggy) O.__proto__ = proto;else set(O, proto);
                        return O;
                    };
                }({}, false) : undefined),
            check: check
        };

        // 19.1.3.19 Object.setPrototypeOf(O, proto)


        _export(_export.S, 'Object', {
            setPrototypeOf: _setProto.set
        });

        // getting tag from 19.1.3.6 Object.prototype.toString()


        var TAG$1 = _wks('toStringTag'); // ES3 wrong here


        var ARG = _cof(function () {
            return arguments;
        }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

        var tryGet = function tryGet(it, key) {
            try {
                return it[key];
            } catch (e) {
                /* empty */
            }
        };

        var _classof = function (it) {
            var O, T, B;
            return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
                : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T // builtinTag case
                    : ARG ? _cof(O) // ES3 arguments fallback
                        : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
        };

        var test = {};
        test[_wks('toStringTag')] = 'z';

        if (test + '' != '[object z]') {
            _redefine(Object.prototype, 'toString', function toString() {
                return '[object ' + _classof(this) + ']';
            }, true);
        }

        // fast apply, http://jsperf.lnkit.com/fast-apply/5
        var _invoke = function (fn, args, that) {
            var un = that === undefined;

            switch (args.length) {
                case 0:
                    return un ? fn() : fn.call(that);

                case 1:
                    return un ? fn(args[0]) : fn.call(that, args[0]);

                case 2:
                    return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

                case 3:
                    return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

                case 4:
                    return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
            }

            return fn.apply(that, args);
        };

        var arraySlice = [].slice;
        var factories = {};

        var construct = function construct(F, len, args) {
            if (!(len in factories)) {
                for (var n = [], i = 0; i < len; i++) {
                    n[i] = 'a[' + i + ']';
                } // eslint-disable-next-line no-new-func


                factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
            }

            return factories[len](F, args);
        };

        var _bind = Function.bind || function bind(that
                                                   /* , ...args */
        ) {
            var fn = _aFunction(this);
            var partArgs = arraySlice.call(arguments, 1);

            var bound = function bound()
                /* args... */
            {
                var args = partArgs.concat(arraySlice.call(arguments));
                return this instanceof bound ? construct(fn, args.length, args) : _invoke(fn, args, that);
            };

            if (_isObject(fn.prototype)) bound.prototype = fn.prototype;
            return bound;
        };

        // 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)


        _export(_export.P, 'Function', {
            bind: _bind
        });

        var dP$2 = _objectDp.f;

        var FProto = Function.prototype;
        var nameRE = /^\s*function ([^ (]*)/;
        var NAME = 'name'; // 19.2.4.2 name

        NAME in FProto || _descriptors && dP$2(FProto, NAME, {
            configurable: true,
            get: function get() {
                try {
                    return ('' + this).match(nameRE)[1];
                } catch (e) {
                    return '';
                }
            }
        });

        var HAS_INSTANCE = _wks('hasInstance');

        var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V)

        if (!(HAS_INSTANCE in FunctionProto)) _objectDp.f(FunctionProto, HAS_INSTANCE, {
            value: function value(O) {
                if (typeof this != 'function' || !_isObject(O)) return false;
                if (!_isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

                while (O = _objectGpo(O)) {
                    if (this.prototype === O) return true;
                }

                return false;
            }
        });

        var _stringWs = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";

        var space = '[' + _stringWs + ']';
        var non = "\u200B\x85";
        var ltrim = RegExp('^' + space + space + '*');
        var rtrim = RegExp(space + space + '*$');

        var exporter = function exporter(KEY, exec, ALIAS) {
            var exp = {};
            var FORCE = _fails(function () {
                return !!_stringWs[KEY]() || non[KEY]() != non;
            });
            var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];
            if (ALIAS) exp[ALIAS] = fn;
            _export(_export.P + _export.F * FORCE, 'String', exp);
        }; // 1 -> String#trimLeft
        // 2 -> String#trimRight
        // 3 -> String#trim


        var trim = exporter.trim = function (string, TYPE) {
            string = String(_defined(string));
            if (TYPE & 1) string = string.replace(ltrim, '');
            if (TYPE & 2) string = string.replace(rtrim, '');
            return string;
        };

        var _stringTrim = exporter;

        var $parseInt = _global.parseInt;

        var $trim = _stringTrim.trim;



        var hex = /^[-+]?0[xX]/;
        var _parseInt = $parseInt(_stringWs + '08') !== 8 || $parseInt(_stringWs + '0x16') !== 22 ? function parseInt(str, radix) {
            var string = $trim(String(str), 3);
            return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
        } : $parseInt;

        // 18.2.5 parseInt(string, radix)


        _export(_export.G + _export.F * (parseInt != _parseInt), {
            parseInt: _parseInt
        });

        var $parseFloat = _global.parseFloat;

        var $trim$1 = _stringTrim.trim;

        var _parseFloat = 1 / $parseFloat(_stringWs + '-0') !== -Infinity ? function parseFloat(str) {
            var string = $trim$1(String(str), 3);
            var result = $parseFloat(string);
            return result === 0 && string.charAt(0) == '-' ? -0 : result;
        } : $parseFloat;

        // 18.2.4 parseFloat(string)


        _export(_export.G + _export.F * (parseFloat != _parseFloat), {
            parseFloat: _parseFloat
        });

        var setPrototypeOf = _setProto.set;

        var _inheritIfRequired = function (that, target, C) {
            var S = target.constructor;
            var P;

            if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && _isObject(P) && setPrototypeOf) {
                setPrototypeOf(that, P);
            }

            return that;
        };

        var gOPN$2 = _objectGopn.f;

        var gOPD$2 = _objectGopd.f;

        var dP$3 = _objectDp.f;

        var $trim$2 = _stringTrim.trim;

        var NUMBER = 'Number';
        var $Number = _global[NUMBER];
        var Base = $Number;
        var proto = $Number.prototype; // Opera ~12 has broken Object#toString

        var BROKEN_COF = _cof(_objectCreate(proto)) == NUMBER;
        var TRIM = 'trim' in String.prototype; // 7.1.3 ToNumber(argument)

        var toNumber = function toNumber(argument) {
            var it = _toPrimitive(argument, false);

            if (typeof it == 'string' && it.length > 2) {
                it = TRIM ? it.trim() : $trim$2(it, 3);
                var first = it.charCodeAt(0);
                var third, radix, maxCode;

                if (first === 43 || first === 45) {
                    third = it.charCodeAt(2);
                    if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
                } else if (first === 48) {
                    switch (it.charCodeAt(1)) {
                        case 66:
                        case 98:
                            radix = 2;
                            maxCode = 49;
                            break;
                        // fast equal /^0b[01]+$/i

                        case 79:
                        case 111:
                            radix = 8;
                            maxCode = 55;
                            break;
                        // fast equal /^0o[0-7]+$/i

                        default:
                            return +it;
                    }

                    for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
                        code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol
                        // but ToNumber should return NaN if a string contains unavailable symbols

                        if (code < 48 || code > maxCode) return NaN;
                    }

                    return parseInt(digits, radix);
                }
            }

            return +it;
        };

        if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
            $Number = function Number(value) {
                var it = arguments.length < 1 ? 0 : value;
                var that = this;
                return that instanceof $Number // check on 1..constructor(foo) case
                && (BROKEN_COF ? _fails(function () {
                    proto.valueOf.call(that);
                }) : _cof(that) != NUMBER) ? _inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
            };

            for (var keys = _descriptors ? gOPN$2(Base) : ( // ES3:
                'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES6 (in case, if modules with ES6 Number statics required before):
                'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j$1 = 0, key; keys.length > j$1; j$1++) {
                if (_has(Base, key = keys[j$1]) && !_has($Number, key)) {
                    dP$3($Number, key, gOPD$2(Base, key));
                }
            }

            $Number.prototype = proto;
            proto.constructor = $Number;

            _redefine(_global, NUMBER, $Number);
        }

        var _aNumberValue = function (it, msg) {
            if (typeof it != 'number' && _cof(it) != 'Number') throw TypeError(msg);
            return +it;
        };

        var _stringRepeat = function repeat(count) {
            var str = String(_defined(this));
            var res = '';
            var n = _toInteger(count);
            if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");

            for (; n > 0; (n >>>= 1) && (str += str)) {
                if (n & 1) res += str;
            }

            return res;
        };

        var $toFixed = 1.0.toFixed;
        var floor$1 = Math.floor;
        var data = [0, 0, 0, 0, 0, 0];
        var ERROR = 'Number.toFixed: incorrect invocation!';
        var ZERO = '0';

        var multiply = function multiply(n, c) {
            var i = -1;
            var c2 = c;

            while (++i < 6) {
                c2 += n * data[i];
                data[i] = c2 % 1e7;
                c2 = floor$1(c2 / 1e7);
            }
        };

        var divide = function divide(n) {
            var i = 6;
            var c = 0;

            while (--i >= 0) {
                c += data[i];
                data[i] = floor$1(c / n);
                c = c % n * 1e7;
            }
        };

        var numToString = function numToString() {
            var i = 6;
            var s = '';

            while (--i >= 0) {
                if (s !== '' || i === 0 || data[i] !== 0) {
                    var t = String(data[i]);
                    s = s === '' ? t : s + _stringRepeat.call(ZERO, 7 - t.length) + t;
                }
            }

            return s;
        };

        var pow = function pow(x, n, acc) {
            return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
        };

        var log = function log(x) {
            var n = 0;
            var x2 = x;

            while (x2 >= 4096) {
                n += 12;
                x2 /= 4096;
            }

            while (x2 >= 2) {
                n += 1;
                x2 /= 2;
            }

            return n;
        };

        _export(_export.P + _export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !_fails(function () {
            // V8 ~ Android 4.3-
            $toFixed.call({});
        })), 'Number', {
            toFixed: function toFixed(fractionDigits) {
                var x = _aNumberValue(this, ERROR);
                var f = _toInteger(fractionDigits);
                var s = '';
                var m = ZERO;
                var e, z, j, k;
                if (f < 0 || f > 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare

                if (x != x) return 'NaN';
                if (x <= -1e21 || x >= 1e21) return String(x);

                if (x < 0) {
                    s = '-';
                    x = -x;
                }

                if (x > 1e-21) {
                    e = log(x * pow(2, 69, 1)) - 69;
                    z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
                    z *= 0x10000000000000;
                    e = 52 - e;

                    if (e > 0) {
                        multiply(0, z);
                        j = f;

                        while (j >= 7) {
                            multiply(1e7, 0);
                            j -= 7;
                        }

                        multiply(pow(10, j, 1), 0);
                        j = e - 1;

                        while (j >= 23) {
                            divide(1 << 23);
                            j -= 23;
                        }

                        divide(1 << j);
                        multiply(1, 1);
                        divide(2);
                        m = numToString();
                    } else {
                        multiply(0, z);
                        multiply(1 << -e, 0);
                        m = numToString() + _stringRepeat.call(ZERO, f);
                    }
                }

                if (f > 0) {
                    k = m.length;
                    m = s + (k <= f ? '0.' + _stringRepeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
                } else {
                    m = s + m;
                }

                return m;
            }
        });

        var $toPrecision = 1.0.toPrecision;
        _export(_export.P + _export.F * (_fails(function () {
            // IE7-
            return $toPrecision.call(1, undefined) !== '1';
        }) || !_fails(function () {
            // V8 ~ Android 4.3-
            $toPrecision.call({});
        })), 'Number', {
            toPrecision: function toPrecision(precision) {
                var that = _aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
                return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
            }
        });

        // 20.1.2.1 Number.EPSILON


        _export(_export.S, 'Number', {
            EPSILON: Math.pow(2, -52)
        });

        // 20.1.2.2 Number.isFinite(number)


        var _isFinite = _global.isFinite;

        _export(_export.S, 'Number', {
            isFinite: function isFinite(it) {
                return typeof it == 'number' && _isFinite(it);
            }
        });

        // 20.1.2.3 Number.isInteger(number)


        var floor$2 = Math.floor;

        var _isInteger = function isInteger(it) {
            return !_isObject(it) && isFinite(it) && floor$2(it) === it;
        };

        // 20.1.2.3 Number.isInteger(number)


        _export(_export.S, 'Number', {
            isInteger: _isInteger
        });

        // 20.1.2.4 Number.isNaN(number)


        _export(_export.S, 'Number', {
            isNaN: function isNaN(number) {
                // eslint-disable-next-line no-self-compare
                return number != number;
            }
        });

        // 20.1.2.5 Number.isSafeInteger(number)




        var abs = Math.abs;
        _export(_export.S, 'Number', {
            isSafeInteger: function isSafeInteger(number) {
                return _isInteger(number) && abs(number) <= 0x1fffffffffffff;
            }
        });

        // 20.1.2.6 Number.MAX_SAFE_INTEGER


        _export(_export.S, 'Number', {
            MAX_SAFE_INTEGER: 0x1fffffffffffff
        });

        // 20.1.2.10 Number.MIN_SAFE_INTEGER


        _export(_export.S, 'Number', {
            MIN_SAFE_INTEGER: -0x1fffffffffffff
        });

        // 20.1.2.12 Number.parseFloat(string)


        _export(_export.S + _export.F * (Number.parseFloat != _parseFloat), 'Number', {
            parseFloat: _parseFloat
        });

        // 20.1.2.13 Number.parseInt(string, radix)


        _export(_export.S + _export.F * (Number.parseInt != _parseInt), 'Number', {
            parseInt: _parseInt
        });

        // 20.2.2.20 Math.log1p(x)
        var _mathLog1p = Math.log1p || function log1p(x) {
            return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
        };

        // 20.2.2.3 Math.acosh(x)




        var sqrt = Math.sqrt;
        var $acosh = Math.acosh;
        _export(_export.S + _export.F * !($acosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
            && Math.floor($acosh(Number.MAX_VALUE)) == 710 // Tor Browser bug: Math.acosh(Infinity) -> NaN
            && $acosh(Infinity) == Infinity), 'Math', {
            acosh: function acosh(x) {
                return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : _mathLog1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
            }
        });

        // 20.2.2.5 Math.asinh(x)


        var $asinh = Math.asinh;

        function asinh(x) {
            return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
        } // Tor Browser bug: Math.asinh(0) -> -0


        _export(_export.S + _export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {
            asinh: asinh
        });

        // 20.2.2.7 Math.atanh(x)


        var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -> 0

        _export(_export.S + _export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
            atanh: function atanh(x) {
                return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
            }
        });

        // 20.2.2.28 Math.sign(x)
        var _mathSign = Math.sign || function sign(x) {
            // eslint-disable-next-line no-self-compare
            return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
        };

        // 20.2.2.9 Math.cbrt(x)




        _export(_export.S, 'Math', {
            cbrt: function cbrt(x) {
                return _mathSign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
            }
        });

        // 20.2.2.11 Math.clz32(x)


        _export(_export.S, 'Math', {
            clz32: function clz32(x) {
                return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
            }
        });

        // 20.2.2.12 Math.cosh(x)


        var exp = Math.exp;
        _export(_export.S, 'Math', {
            cosh: function cosh(x) {
                return (exp(x = +x) + exp(-x)) / 2;
            }
        });

        // 20.2.2.14 Math.expm1(x)
        var $expm1 = Math.expm1;
        var _mathExpm1 = !$expm1 // Old FF bug
        || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug
        || $expm1(-2e-17) != -2e-17 ? function expm1(x) {
            return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
        } : $expm1;

        // 20.2.2.14 Math.expm1(x)




        _export(_export.S + _export.F * (_mathExpm1 != Math.expm1), 'Math', {
            expm1: _mathExpm1
        });

        // 20.2.2.16 Math.fround(x)


        var pow$1 = Math.pow;
        var EPSILON = pow$1(2, -52);
        var EPSILON32 = pow$1(2, -23);
        var MAX32 = pow$1(2, 127) * (2 - EPSILON32);
        var MIN32 = pow$1(2, -126);

        var roundTiesToEven = function roundTiesToEven(n) {
            return n + 1 / EPSILON - 1 / EPSILON;
        };

        var _mathFround = Math.fround || function fround(x) {
            var $abs = Math.abs(x);
            var $sign = _mathSign(x);
            var a, result;
            if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
            a = (1 + EPSILON32 / EPSILON) * $abs;
            result = a - (a - $abs); // eslint-disable-next-line no-self-compare

            if (result > MAX32 || result != result) return $sign * Infinity;
            return $sign * result;
        };

        // 20.2.2.16 Math.fround(x)


        _export(_export.S, 'Math', {
            fround: _mathFround
        });

        // 20.2.2.17 Math.hypot([value1[, value2[, ... ]]])


        var abs$1 = Math.abs;
        _export(_export.S, 'Math', {
            hypot: function hypot(value1, value2) {
                // eslint-disable-line no-unused-vars
                var sum = 0;
                var i = 0;
                var aLen = arguments.length;
                var larg = 0;
                var arg, div;

                while (i < aLen) {
                    arg = abs$1(arguments[i++]);

                    if (larg < arg) {
                        div = larg / arg;
                        sum = sum * div * div + 1;
                        larg = arg;
                    } else if (arg > 0) {
                        div = arg / larg;
                        sum += div * div;
                    } else sum += arg;
                }

                return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
            }
        });

        // 20.2.2.18 Math.imul(x, y)


        var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity

        _export(_export.S + _export.F * _fails(function () {
            return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
        }), 'Math', {
            imul: function imul(x, y) {
                var UINT16 = 0xffff;
                var xn = +x;
                var yn = +y;
                var xl = UINT16 & xn;
                var yl = UINT16 & yn;
                return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
            }
        });

        // 20.2.2.21 Math.log10(x)


        _export(_export.S, 'Math', {
            log10: function log10(x) {
                return Math.log(x) * Math.LOG10E;
            }
        });

        // 20.2.2.20 Math.log1p(x)


        _export(_export.S, 'Math', {
            log1p: _mathLog1p
        });

        // 20.2.2.22 Math.log2(x)


        _export(_export.S, 'Math', {
            log2: function log2(x) {
                return Math.log(x) / Math.LN2;
            }
        });

        // 20.2.2.28 Math.sign(x)


        _export(_export.S, 'Math', {
            sign: _mathSign
        });

        // 20.2.2.30 Math.sinh(x)




        var exp$1 = Math.exp; // V8 near Chromium 38 has a problem with very small numbers

        _export(_export.S + _export.F * _fails(function () {
            return !Math.sinh(-2e-17) != -2e-17;
        }), 'Math', {
            sinh: function sinh(x) {
                return Math.abs(x = +x) < 1 ? (_mathExpm1(x) - _mathExpm1(-x)) / 2 : (exp$1(x - 1) - exp$1(-x - 1)) * (Math.E / 2);
            }
        });

        // 20.2.2.33 Math.tanh(x)




        var exp$2 = Math.exp;
        _export(_export.S, 'Math', {
            tanh: function tanh(x) {
                var a = _mathExpm1(x = +x);
                var b = _mathExpm1(-x);
                return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp$2(x) + exp$2(-x));
            }
        });

        // 20.2.2.34 Math.trunc(x)


        _export(_export.S, 'Math', {
            trunc: function trunc(it) {
                return (it > 0 ? Math.floor : Math.ceil)(it);
            }
        });

        var fromCharCode = String.fromCharCode;
        var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem

        _export(_export.S + _export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
            // 21.1.2.2 String.fromCodePoint(...codePoints)
            fromCodePoint: function fromCodePoint(x) {
                // eslint-disable-line no-unused-vars
                var res = [];
                var aLen = arguments.length;
                var i = 0;
                var code;

                while (aLen > i) {
                    code = +arguments[i++];
                    if (_toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
                    res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
                }

                return res.join('');
            }
        });

        _export(_export.S, 'String', {
            // 21.1.2.4 String.raw(callSite, ...substitutions)
            raw: function raw(callSite) {
                var tpl = _toIobject(callSite.raw);
                var len = _toLength(tpl.length);
                var aLen = arguments.length;
                var res = [];
                var i = 0;

                while (len > i) {
                    res.push(String(tpl[i++]));
                    if (i < aLen) res.push(String(arguments[i]));
                }

                return res.join('');
            }
        });

        _stringTrim('trim', function ($trim) {
            return function trim() {
                return $trim(this, 3);
            };
        });

        // true  -> String#at
        // false -> String#codePointAt


        var _stringAt = function (TO_STRING) {
            return function (that, pos) {
                var s = String(_defined(that));
                var i = _toInteger(pos);
                var l = s.length;
                var a, b;
                if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
                a = s.charCodeAt(i);
                return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
            };
        };

        var _iterators = {};

        var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

        _hide(IteratorPrototype, _wks('iterator'), function () {
            return this;
        });

        var _iterCreate = function (Constructor, NAME, next) {
            Constructor.prototype = _objectCreate(IteratorPrototype, {
                next: _propertyDesc(1, next)
            });
            _setToStringTag(Constructor, NAME + ' Iterator');
        };

        var ITERATOR = _wks('iterator');

        var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

        var FF_ITERATOR = '@@iterator';
        var KEYS = 'keys';
        var VALUES = 'values';

        var returnThis = function returnThis() {
            return this;
        };

        var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
            _iterCreate(Constructor, NAME, next);

            var getMethod = function getMethod(kind) {
                if (!BUGGY && kind in proto) return proto[kind];

                switch (kind) {
                    case KEYS:
                        return function keys() {
                            return new Constructor(this, kind);
                        };

                    case VALUES:
                        return function values() {
                            return new Constructor(this, kind);
                        };
                }

                return function entries() {
                    return new Constructor(this, kind);
                };
            };

            var TAG = NAME + ' Iterator';
            var DEF_VALUES = DEFAULT == VALUES;
            var VALUES_BUG = false;
            var proto = Base.prototype;
            var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
            var $default = $native || getMethod(DEFAULT);
            var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
            var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
            var methods, key, IteratorPrototype; // Fix native

            if ($anyNative) {
                IteratorPrototype = _objectGpo($anyNative.call(new Base()));

                if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
                    // Set @@toStringTag to native iterators
                    _setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

                    if (typeof IteratorPrototype[ITERATOR] != 'function') _hide(IteratorPrototype, ITERATOR, returnThis);
                }
            } // fix Array#{values, @@iterator}.name in V8 / FF


            if (DEF_VALUES && $native && $native.name !== VALUES) {
                VALUES_BUG = true;

                $default = function values() {
                    return $native.call(this);
                };
            } // Define iterator


            if (BUGGY || VALUES_BUG || !proto[ITERATOR]) {
                _hide(proto, ITERATOR, $default);
            } // Plug for library


            _iterators[NAME] = $default;
            _iterators[TAG] = returnThis;

            if (DEFAULT) {
                methods = {
                    values: DEF_VALUES ? $default : getMethod(VALUES),
                    keys: IS_SET ? $default : getMethod(KEYS),
                    entries: $entries
                };
                if (FORCED) for (key in methods) {
                    if (!(key in proto)) _redefine(proto, key, methods[key]);
                } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
            }

            return methods;
        };

        var $at = _stringAt(true); // 21.1.3.27 String.prototype[@@iterator]()


        _iterDefine(String, 'String', function (iterated) {
            this._t = String(iterated); // target

            this._i = 0; // next index
            // 21.1.5.2.1 %StringIteratorPrototype%.next()
        }, function () {
            var O = this._t;
            var index = this._i;
            var point;
            if (index >= O.length) return {
                value: undefined,
                done: true
            };
            point = $at(O, index);
            this._i += point.length;
            return {
                value: point,
                done: false
            };
        });

        var $at$1 = _stringAt(false);

        _export(_export.P, 'String', {
            // 21.1.3.3 String.prototype.codePointAt(pos)
            codePointAt: function codePointAt(pos) {
                return $at$1(this, pos);
            }
        });

        // 7.2.8 IsRegExp(argument)




        var MATCH = _wks('match');

        var _isRegexp = function (it) {
            var isRegExp;
            return _isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : _cof(it) == 'RegExp');
        };

        // helper for String#{startsWith, endsWith, includes}




        var _stringContext = function (that, searchString, NAME) {
            if (_isRegexp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
            return String(_defined(that));
        };

        var MATCH$1 = _wks('match');

        var _failsIsRegexp = function (KEY) {
            var re = /./;

            try {
                '/./'[KEY](re);
            } catch (e) {
                try {
                    re[MATCH$1] = false;
                    return !'/./'[KEY](re);
                } catch (f) {
                    /* empty */
                }
            }

            return true;
        };

        var ENDS_WITH = 'endsWith';
        var $endsWith = ''[ENDS_WITH];
        _export(_export.P + _export.F * _failsIsRegexp(ENDS_WITH), 'String', {
            endsWith: function endsWith(searchString
                                        /* , endPosition = @length */
            ) {
                var that = _stringContext(this, searchString, ENDS_WITH);
                var endPosition = arguments.length > 1 ? arguments[1] : undefined;
                var len = _toLength(that.length);
                var end = endPosition === undefined ? len : Math.min(_toLength(endPosition), len);
                var search = String(searchString);
                return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
            }
        });

        var INCLUDES = 'includes';
        _export(_export.P + _export.F * _failsIsRegexp(INCLUDES), 'String', {
            includes: function includes(searchString
                                        /* , position = 0 */
            ) {
                return !!~_stringContext(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
            }
        });

        _export(_export.P, 'String', {
            // 21.1.3.13 String.prototype.repeat(count)
            repeat: _stringRepeat
        });

        var STARTS_WITH = 'startsWith';
        var $startsWith = ''[STARTS_WITH];
        _export(_export.P + _export.F * _failsIsRegexp(STARTS_WITH), 'String', {
            startsWith: function startsWith(searchString
                                            /* , position = 0 */
            ) {
                var that = _stringContext(this, searchString, STARTS_WITH);
                var index = _toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
                var search = String(searchString);
                return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
            }
        });

        var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value)

        var createHTML = function createHTML(string, tag, attribute, value) {
            var S = String(_defined(string));
            var p1 = '<' + tag;
            if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
            return p1 + '>' + S + '</' + tag + '>';
        };

        var _stringHtml = function (NAME, exec) {
            var O = {};
            O[NAME] = exec(createHTML);
            _export(_export.P + _export.F * _fails(function () {
                var test = ''[NAME]('"');
                return test !== test.toLowerCase() || test.split('"').length > 3;
            }), 'String', O);
        };

        _stringHtml('anchor', function (createHTML) {
            return function anchor(name) {
                return createHTML(this, 'a', 'name', name);
            };
        });

        _stringHtml('big', function (createHTML) {
            return function big() {
                return createHTML(this, 'big', '', '');
            };
        });

        _stringHtml('blink', function (createHTML) {
            return function blink() {
                return createHTML(this, 'blink', '', '');
            };
        });

        _stringHtml('bold', function (createHTML) {
            return function bold() {
                return createHTML(this, 'b', '', '');
            };
        });

        _stringHtml('fixed', function (createHTML) {
            return function fixed() {
                return createHTML(this, 'tt', '', '');
            };
        });

        _stringHtml('fontcolor', function (createHTML) {
            return function fontcolor(color) {
                return createHTML(this, 'font', 'color', color);
            };
        });

        _stringHtml('fontsize', function (createHTML) {
            return function fontsize(size) {
                return createHTML(this, 'font', 'size', size);
            };
        });

        _stringHtml('italics', function (createHTML) {
            return function italics() {
                return createHTML(this, 'i', '', '');
            };
        });

        _stringHtml('link', function (createHTML) {
            return function link(url) {
                return createHTML(this, 'a', 'href', url);
            };
        });

        _stringHtml('small', function (createHTML) {
            return function small() {
                return createHTML(this, 'small', '', '');
            };
        });

        _stringHtml('strike', function (createHTML) {
            return function strike() {
                return createHTML(this, 'strike', '', '');
            };
        });

        _stringHtml('sub', function (createHTML) {
            return function sub() {
                return createHTML(this, 'sub', '', '');
            };
        });

        _stringHtml('sup', function (createHTML) {
            return function sup() {
                return createHTML(this, 'sup', '', '');
            };
        });

        // 20.3.3.1 / 15.9.4.4 Date.now()


        _export(_export.S, 'Date', {
            now: function now() {
                return new Date().getTime();
            }
        });

        _export(_export.P + _export.F * _fails(function () {
            return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
                toISOString: function toISOString() {
                    return 1;
                }
            }) !== 1;
        }), 'Date', {
            // eslint-disable-next-line no-unused-vars
            toJSON: function toJSON(key) {
                var O = _toObject(this);
                var pv = _toPrimitive(O);
                return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
            }
        });

        var getTime = Date.prototype.getTime;
        var $toISOString = Date.prototype.toISOString;

        var lz = function lz(num) {
            return num > 9 ? num : '0' + num;
        }; // PhantomJS / old WebKit has a broken implementations


        var _dateToIsoString = _fails(function () {
            return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
        }) || !_fails(function () {
            $toISOString.call(new Date(NaN));
        }) ? function toISOString() {
            if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
            var d = this;
            var y = d.getUTCFullYear();
            var m = d.getUTCMilliseconds();
            var s = y < 0 ? '-' : y > 9999 ? '+' : '';
            return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
        } : $toISOString;

        // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()


        // PhantomJS / old WebKit has a broken implementations


        _export(_export.P + _export.F * (Date.prototype.toISOString !== _dateToIsoString), 'Date', {
            toISOString: _dateToIsoString
        });

        var DateProto = Date.prototype;
        var INVALID_DATE = 'Invalid Date';
        var TO_STRING = 'toString';
        var $toString = DateProto[TO_STRING];
        var getTime$1 = DateProto.getTime;

        if (new Date(NaN) + '' != INVALID_DATE) {
            _redefine(DateProto, TO_STRING, function toString() {
                var value = getTime$1.call(this); // eslint-disable-next-line no-self-compare

                return value === value ? $toString.call(this) : INVALID_DATE;
            });
        }

        var NUMBER$1 = 'number';

        var _dateToPrimitive = function (hint) {
            if (hint !== 'string' && hint !== NUMBER$1 && hint !== 'default') throw TypeError('Incorrect hint');
            return _toPrimitive(_anObject(this), hint != NUMBER$1);
        };

        var TO_PRIMITIVE$1 = _wks('toPrimitive');

        var proto$1 = Date.prototype;
        if (!(TO_PRIMITIVE$1 in proto$1)) _hide(proto$1, TO_PRIMITIVE$1, _dateToPrimitive);

        // 22.1.2.2 / 15.4.3.2 Array.isArray(arg)


        _export(_export.S, 'Array', {
            isArray: _isArray
        });

        // call something on iterator step with safe closing on error


        var _iterCall = function (iterator, fn, value, entries) {
            try {
                return entries ? fn(_anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
            } catch (e) {
                var ret = iterator['return'];
                if (ret !== undefined) _anObject(ret.call(iterator));
                throw e;
            }
        };

        // check on default Array iterator


        var ITERATOR$1 = _wks('iterator');

        var ArrayProto = Array.prototype;

        var _isArrayIter = function (it) {
            return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);
        };

        var _createProperty = function (object, index, value) {
            if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));else object[index] = value;
        };

        var ITERATOR$2 = _wks('iterator');



        var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
            if (it != undefined) return it[ITERATOR$2] || it['@@iterator'] || _iterators[_classof(it)];
        };

        var ITERATOR$3 = _wks('iterator');

        var SAFE_CLOSING = false;

        try {
            var riter = [7][ITERATOR$3]();

            riter['return'] = function () {
                SAFE_CLOSING = true;
            }; // eslint-disable-next-line no-throw-literal
        } catch (e) {
            /* empty */
        }

        var _iterDetect = function (exec, skipClosing) {
            if (!skipClosing && !SAFE_CLOSING) return false;
            var safe = false;

            try {
                var arr = [7];
                var iter = arr[ITERATOR$3]();

                iter.next = function () {
                    return {
                        done: safe = true
                    };
                };

                arr[ITERATOR$3] = function () {
                    return iter;
                };

                exec(arr);
            } catch (e) {
                /* empty */
            }

            return safe;
        };

        _export(_export.S + _export.F * !_iterDetect(function (iter) {
        }), 'Array', {
            // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
            from: function from(arrayLike
                                /* , mapfn = undefined, thisArg = undefined */
            ) {
                var O = _toObject(arrayLike);
                var C = typeof this == 'function' ? this : Array;
                var aLen = arguments.length;
                var mapfn = aLen > 1 ? arguments[1] : undefined;
                var mapping = mapfn !== undefined;
                var index = 0;
                var iterFn = core_getIteratorMethod(O);
                var length, result, step, iterator;
                if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

                if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
                    for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
                        _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
                    }
                } else {
                    length = _toLength(O.length);

                    for (result = new C(length); length > index; index++) {
                        _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
                    }
                }

                result.length = index;
                return result;
            }
        });

        // WebKit Array.of isn't generic


        _export(_export.S + _export.F * _fails(function () {
            function F() {
                /* empty */
            }

            return !(Array.of.call(F) instanceof F);
        }), 'Array', {
            // 22.1.2.3 Array.of( ...items)
            of: function of()
                /* ...args */
            {
                var index = 0;
                var aLen = arguments.length;
                var result = new (typeof this == 'function' ? this : Array)(aLen);

                while (aLen > index) {
                    _createProperty(result, index, arguments[index++]);
                }

                result.length = aLen;
                return result;
            }
        });

        var _strictMethod = function (method, arg) {
            return !!method && _fails(function () {
                // eslint-disable-next-line no-useless-call
                arg ? method.call(null, function () {
                    /* empty */
                }, 1) : method.call(null);
            });
        };

        var arrayJoin = [].join; // fallback for not array-like strings

        _export(_export.P + _export.F * (_iobject != Object || !_strictMethod(arrayJoin)), 'Array', {
            join: function join(separator) {
                return arrayJoin.call(_toIobject(this), separator === undefined ? ',' : separator);
            }
        });

        var arraySlice$1 = [].slice; // fallback for not array-like ES3 strings and DOM objects

        _export(_export.P + _export.F * _fails(function () {
            if (_html) arraySlice$1.call(_html);
        }), 'Array', {
            slice: function slice(begin, end) {
                var len = _toLength(this.length);
                var klass = _cof(this);
                end = end === undefined ? len : end;
                if (klass == 'Array') return arraySlice$1.call(this, begin, end);
                var start = _toAbsoluteIndex(begin, len);
                var upTo = _toAbsoluteIndex(end, len);
                var size = _toLength(upTo - start);
                var cloned = new Array(size);
                var i = 0;

                for (; i < size; i++) {
                    cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
                }

                return cloned;
            }
        });

        var $sort = [].sort;
        var test$1 = [1, 2, 3];
        _export(_export.P + _export.F * (_fails(function () {
            // IE8-
            test$1.sort(undefined);
        }) || !_fails(function () {
            // V8 bug
            test$1.sort(null); // Old WebKit
        }) || !_strictMethod($sort)), 'Array', {
            // 22.1.3.25 Array.prototype.sort(comparefn)
            sort: function sort(comparefn) {
                return comparefn === undefined ? $sort.call(_toObject(this)) : $sort.call(_toObject(this), _aFunction(comparefn));
            }
        });

        var SPECIES = _wks('species');

        var _arraySpeciesConstructor = function (original) {
            var C;

            if (_isArray(original)) {
                C = original.constructor; // cross-realm fallback

                if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;

                if (_isObject(C)) {
                    C = C[SPECIES];
                    if (C === null) C = undefined;
                }
            }

            return C === undefined ? Array : C;
        };

        // 9.4.2.3 ArraySpeciesCreate(originalArray, length)


        var _arraySpeciesCreate = function (original, length) {
            return new (_arraySpeciesConstructor(original))(length);
        };

        // 0 -> Array#forEach
        // 1 -> Array#map
        // 2 -> Array#filter
        // 3 -> Array#some
        // 4 -> Array#every
        // 5 -> Array#find
        // 6 -> Array#findIndex










        var _arrayMethods = function (TYPE, $create) {
            var IS_MAP = TYPE == 1;
            var IS_FILTER = TYPE == 2;
            var IS_SOME = TYPE == 3;
            var IS_EVERY = TYPE == 4;
            var IS_FIND_INDEX = TYPE == 6;
            var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
            var create = $create || _arraySpeciesCreate;
            return function ($this, callbackfn, that) {
                var O = _toObject($this);
                var self = _iobject(O);
                var f = _ctx(callbackfn, that, 3);
                var length = _toLength(self.length);
                var index = 0;
                var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
                var val, res;

                for (; length > index; index++) {
                    if (NO_HOLES || index in self) {
                        val = self[index];
                        res = f(val, index, O);

                        if (TYPE) {
                            if (IS_MAP) result[index] = res; // map
                            else if (res) switch (TYPE) {
                                case 3:
                                    return true;
                                // some

                                case 5:
                                    return val;
                                // find

                                case 6:
                                    return index;
                                // findIndex

                                case 2:
                                    result.push(val);
                                // filter
                            } else if (IS_EVERY) return false; // every
                        }
                    }
                }

                return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
            };
        };

        var $forEach = _arrayMethods(0);

        var STRICT = _strictMethod([].forEach, true);

        _export(_export.P + _export.F * !STRICT, 'Array', {
            // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
            forEach: function forEach(callbackfn
                                      /* , thisArg */
            ) {
                return $forEach(this, callbackfn, arguments[1]);
            }
        });

        var $map = _arrayMethods(1);

        _export(_export.P + _export.F * !_strictMethod([].map, true), 'Array', {
            // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
            map: function map(callbackfn
                              /* , thisArg */
            ) {
                return $map(this, callbackfn, arguments[1]);
            }
        });

        var $filter = _arrayMethods(2);

        _export(_export.P + _export.F * !_strictMethod([].filter, true), 'Array', {
            // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
            filter: function filter(callbackfn
                                    /* , thisArg */
            ) {
                return $filter(this, callbackfn, arguments[1]);
            }
        });

        var $some = _arrayMethods(3);

        _export(_export.P + _export.F * !_strictMethod([].some, true), 'Array', {
            // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
            some: function some(callbackfn
                                /* , thisArg */
            ) {
                return $some(this, callbackfn, arguments[1]);
            }
        });

        var $every = _arrayMethods(4);

        _export(_export.P + _export.F * !_strictMethod([].every, true), 'Array', {
            // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
            every: function every(callbackfn
                                  /* , thisArg */
            ) {
                return $every(this, callbackfn, arguments[1]);
            }
        });

        var _arrayReduce = function (that, callbackfn, aLen, memo, isRight) {
            _aFunction(callbackfn);
            var O = _toObject(that);
            var self = _iobject(O);
            var length = _toLength(O.length);
            var index = isRight ? length - 1 : 0;
            var i = isRight ? -1 : 1;
            if (aLen < 2) for (;;) {
                if (index in self) {
                    memo = self[index];
                    index += i;
                    break;
                }

                index += i;

                if (isRight ? index < 0 : length <= index) {
                    throw TypeError('Reduce of empty array with no initial value');
                }
            }

            for (; isRight ? index >= 0 : length > index; index += i) {
                if (index in self) {
                    memo = callbackfn(memo, self[index], index, O);
                }
            }

            return memo;
        };

        _export(_export.P + _export.F * !_strictMethod([].reduce, true), 'Array', {
            // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
            reduce: function reduce(callbackfn
                                    /* , initialValue */
            ) {
                return _arrayReduce(this, callbackfn, arguments.length, arguments[1], false);
            }
        });

        _export(_export.P + _export.F * !_strictMethod([].reduceRight, true), 'Array', {
            // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
            reduceRight: function reduceRight(callbackfn
                                              /* , initialValue */
            ) {
                return _arrayReduce(this, callbackfn, arguments.length, arguments[1], true);
            }
        });

        var $indexOf = _arrayIncludes(false);

        var $native = [].indexOf;
        var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
        _export(_export.P + _export.F * (NEGATIVE_ZERO || !_strictMethod($native)), 'Array', {
            // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
            indexOf: function indexOf(searchElement
                                      /* , fromIndex = 0 */
            ) {
                return NEGATIVE_ZERO // convert -0 to +0
                    ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
            }
        });

        var $native$1 = [].lastIndexOf;
        var NEGATIVE_ZERO$1 = !!$native$1 && 1 / [1].lastIndexOf(1, -0) < 0;
        _export(_export.P + _export.F * (NEGATIVE_ZERO$1 || !_strictMethod($native$1)), 'Array', {
            // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
            lastIndexOf: function lastIndexOf(searchElement
                                              /* , fromIndex = @[*-1] */
            ) {
                // convert -0 to +0
                if (NEGATIVE_ZERO$1) return $native$1.apply(this, arguments) || 0;
                var O = _toIobject(this);
                var length = _toLength(O.length);
                var index = length - 1;
                if (arguments.length > 1) index = Math.min(index, _toInteger(arguments[1]));
                if (index < 0) index = length + index;

                for (; index >= 0; index--) {
                    if (index in O) if (O[index] === searchElement) return index || 0;
                }

                return -1;
            }
        });

        var _arrayCopyWithin = [].copyWithin || function copyWithin(target
                                                                    /* = 0 */
            , start
                                                                    /* = 0, end = @length */
        ) {
            var O = _toObject(this);
            var len = _toLength(O.length);
            var to = _toAbsoluteIndex(target, len);
            var from = _toAbsoluteIndex(start, len);
            var end = arguments.length > 2 ? arguments[2] : undefined;
            var count = Math.min((end === undefined ? len : _toAbsoluteIndex(end, len)) - from, len - to);
            var inc = 1;

            if (from < to && to < from + count) {
                inc = -1;
                from += count - 1;
                to += count - 1;
            }

            while (count-- > 0) {
                if (from in O) O[to] = O[from];else delete O[to];
                to += inc;
                from += inc;
            }

            return O;
        };

        // 22.1.3.31 Array.prototype[@@unscopables]
        var UNSCOPABLES = _wks('unscopables');

        var ArrayProto$1 = Array.prototype;
        if (ArrayProto$1[UNSCOPABLES] == undefined) _hide(ArrayProto$1, UNSCOPABLES, {});

        var _addToUnscopables = function (key) {
            ArrayProto$1[UNSCOPABLES][key] = true;
        };

        // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)


        _export(_export.P, 'Array', {
            copyWithin: _arrayCopyWithin
        });

        _addToUnscopables('copyWithin');

        var _arrayFill = function fill(value
                                       /* , start = 0, end = @length */
        ) {
            var O = _toObject(this);
            var length = _toLength(O.length);
            var aLen = arguments.length;
            var index = _toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
            var end = aLen > 2 ? arguments[2] : undefined;
            var endPos = end === undefined ? length : _toAbsoluteIndex(end, length);

            while (endPos > index) {
                O[index++] = value;
            }

            return O;
        };

        // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


        _export(_export.P, 'Array', {
            fill: _arrayFill
        });

        _addToUnscopables('fill');

        var $find = _arrayMethods(5);

        var KEY = 'find';
        var forced = true; // Shouldn't skip holes

        if (KEY in []) Array(1)[KEY](function () {
            forced = false;
        });
        _export(_export.P + _export.F * forced, 'Array', {
            find: function find(callbackfn
                                /* , that = undefined */
            ) {
                return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
            }
        });

        _addToUnscopables(KEY);

        var $find$1 = _arrayMethods(6);

        var KEY$1 = 'findIndex';
        var forced$1 = true; // Shouldn't skip holes

        if (KEY$1 in []) Array(1)[KEY$1](function () {
            forced$1 = false;
        });
        _export(_export.P + _export.F * forced$1, 'Array', {
            findIndex: function findIndex(callbackfn
                                          /* , that = undefined */
            ) {
                return $find$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
            }
        });

        _addToUnscopables(KEY$1);

        var SPECIES$1 = _wks('species');

        var _setSpecies = function (KEY) {
            var C = _global[KEY];
            if (_descriptors && C && !C[SPECIES$1]) _objectDp.f(C, SPECIES$1, {
                configurable: true,
                get: function get() {
                    return this;
                }
            });
        };

        _setSpecies('Array');

        var _iterStep = function (done, value) {
            return {
                value: value,
                done: !!done
            };
        };

        // 22.1.3.4 Array.prototype.entries()
        // 22.1.3.13 Array.prototype.keys()
        // 22.1.3.29 Array.prototype.values()
        // 22.1.3.30 Array.prototype[@@iterator]()


        var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
            this._t = _toIobject(iterated); // target

            this._i = 0; // next index

            this._k = kind; // kind
            // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
        }, function () {
            var O = this._t;
            var kind = this._k;
            var index = this._i++;

            if (!O || index >= O.length) {
                this._t = undefined;
                return _iterStep(1);
            }

            if (kind == 'keys') return _iterStep(0, index);
            if (kind == 'values') return _iterStep(0, O[index]);
            return _iterStep(0, [index, O[index]]);
        }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

        _iterators.Arguments = _iterators.Array;
        _addToUnscopables('keys');
        _addToUnscopables('values');
        _addToUnscopables('entries');

        var _flags = function () {
            var that = _anObject(this);
            var result = '';
            if (that.global) result += 'g';
            if (that.ignoreCase) result += 'i';
            if (that.multiline) result += 'm';
            if (that.unicode) result += 'u';
            if (that.sticky) result += 'y';
            return result;
        };

        var dP$4 = _objectDp.f;

        var gOPN$3 = _objectGopn.f;





        var $RegExp = _global.RegExp;
        var Base$1 = $RegExp;
        var proto$2 = $RegExp.prototype;
        var re1 = /a/g;
        var re2 = /a/g; // "new" creates a new object, old webkit buggy here

        var CORRECT_NEW = new $RegExp(re1) !== re1;

        if (_descriptors && (!CORRECT_NEW || _fails(function () {
            re2[_wks('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

            return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
        }))) {
            $RegExp = function RegExp(p, f) {
                var tiRE = this instanceof $RegExp;
                var piRE = _isRegexp(p);
                var fiU = f === undefined;
                return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : _inheritIfRequired(CORRECT_NEW ? new Base$1(piRE && !fiU ? p.source : p, f) : Base$1((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? _flags.call(p) : f), tiRE ? this : proto$2, $RegExp);
            };

            var proxy = function proxy(key) {
                key in $RegExp || dP$4($RegExp, key, {
                    configurable: true,
                    get: function get() {
                        return Base$1[key];
                    },
                    set: function set(it) {
                        Base$1[key] = it;
                    }
                });
            };

            for (var keys$1 = gOPN$3(Base$1), i = 0; keys$1.length > i;) {
                proxy(keys$1[i++]);
            }

            proto$2.constructor = $RegExp;
            $RegExp.prototype = proto$2;

            _redefine(_global, 'RegExp', $RegExp);
        }

        _setSpecies('RegExp');

        var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
        // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
        // which loads this file before patching the method.

        var nativeReplace = String.prototype.replace;
        var patchedExec = nativeExec;
        var LAST_INDEX = 'lastIndex';

        var UPDATES_LAST_INDEX_WRONG = function () {
            var re1 = /a/,
                re2 = /b*/g;
            nativeExec.call(re1, 'a');
            nativeExec.call(re2, 'a');
            return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
        }(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


        var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
        var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

        if (PATCH) {
            patchedExec = function exec(str) {
                var re = this;
                var lastIndex, reCopy, match, i;

                if (NPCG_INCLUDED) {
                    reCopy = new RegExp('^' + re.source + '$(?!\\s)', _flags.call(re));
                }

                if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
                match = nativeExec.call(re, str);

                if (UPDATES_LAST_INDEX_WRONG && match) {
                    re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
                }

                if (NPCG_INCLUDED && match && match.length > 1) {
                    // Fix browsers whose `exec` methods don't consistently return `undefined`
                    // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
                    // eslint-disable-next-line no-loop-func
                    nativeReplace.call(match[0], reCopy, function () {
                        for (i = 1; i < arguments.length - 2; i++) {
                            if (arguments[i] === undefined) match[i] = undefined;
                        }
                    });
                }

                return match;
            };
        }

        var _regexpExec = patchedExec;

        _export({
            target: 'RegExp',
            proto: true,
            forced: _regexpExec !== /./.exec
        }, {
            exec: _regexpExec
        });

        // 21.2.5.3 get RegExp.prototype.flags()
        if (_descriptors && /./g.flags != 'g') _objectDp.f(RegExp.prototype, 'flags', {
            configurable: true,
            get: _flags
        });

        var TO_STRING$1 = 'toString';
        var $toString$1 = /./[TO_STRING$1];

        var define = function define(fn) {
            _redefine(RegExp.prototype, TO_STRING$1, fn, true);
        }; // 21.2.5.14 RegExp.prototype.toString()


        if (_fails(function () {
            return $toString$1.call({
                source: 'a',
                flags: 'b'
            }) != '/a/b';
        })) {
            define(function toString() {
                var R = _anObject(this);
                return '/'.concat(R.source, 'index.html', 'flags' in R ? R.flags : !_descriptors && R instanceof RegExp ? _flags.call(R) : undefined);
            }); // FF44- RegExp#toString has a wrong name
        } else if ($toString$1.name != TO_STRING$1) {
            define(function toString() {
                return $toString$1.call(this);
            });
        }

        var at = _stringAt(true); // `AdvanceStringIndex` abstract operation
        // https://tc39.github.io/ecma262/#sec-advancestringindex


        var _advanceStringIndex = function (S, index, unicode) {
            return index + (unicode ? at(S, index).length : 1);
        };

        var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation
        // https://tc39.github.io/ecma262/#sec-regexpexec

        var _regexpExecAbstract = function (R, S) {
            var exec = R.exec;

            if (typeof exec === 'function') {
                var result = exec.call(R, S);

                if (babelHelpers.typeof(result) !== 'object') {
                    throw new TypeError('RegExp exec method returned something other than an Object or null');
                }

                return result;
            }

            if (_classof(R) !== 'RegExp') {
                throw new TypeError('RegExp#exec called on incompatible receiver');
            }

            return builtinExec.call(R, S);
        };

        var SPECIES$2 = _wks('species');
        var REPLACE_SUPPORTS_NAMED_GROUPS = !_fails(function () {
            // #replace needs built-in support for named groups.
            // #match works fine because it just return the exec results, even if it has
            // a "grops" property.
            var re = /./;

            re.exec = function () {
                var result = [];
                result.groups = {
                    a: '7'
                };
                return result;
            };

            return ''.replace(re, '$<a>') !== '7';
        });

        var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {
            // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
            var re = /(?:)/;
            var originalExec = re.exec;

            re.exec = function () {
                return originalExec.apply(this, arguments);
            };

            var result = 'ab'.split(re);
            return result.length === 2 && result[0] === 'a' && result[1] === 'b';
        }();

        var _fixReWks = function (KEY, length, exec) {
            var SYMBOL = _wks(KEY);
            var DELEGATES_TO_SYMBOL = !_fails(function () {
                // String methods call symbol-named RegEp methods
                var O = {};

                O[SYMBOL] = function () {
                    return 7;
                };

                return ''[KEY](O) != 7;
            });
            var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !_fails(function () {
                // Symbol-named RegExp methods call .exec
                var execCalled = false;
                var re = /a/;

                re.exec = function () {
                    execCalled = true;
                    return null;
                };

                if (KEY === 'split') {
                    // RegExp[@@split] doesn't call the regex's exec method, but first creates
                    // a new one. We need to return the patched regex when creating the new one.
                    re.constructor = {};

                    re.constructor[SPECIES$2] = function () {
                        return re;
                    };
                }

                re[SYMBOL]('');
                return !execCalled;
            }) : undefined;

            if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
                var nativeRegExpMethod = /./[SYMBOL];
                var fns = exec(_defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
                    if (regexp.exec === _regexpExec) {
                        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                            // The native String method already delegates to @@method (this
                            // polyfilled function), leasing to infinite recursion.
                            // We avoid it by directly calling the native @@method method.
                            return {
                                done: true,
                                value: nativeRegExpMethod.call(regexp, str, arg2)
                            };
                        }

                        return {
                            done: true,
                            value: nativeMethod.call(str, regexp, arg2)
                        };
                    }

                    return {
                        done: false
                    };
                });
                var strfn = fns[0];
                var rxfn = fns[1];
                _redefine(String.prototype, KEY, strfn);
                _hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
                    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
                    ? function (string, arg) {
                        return rxfn.call(string, this, arg);
                    } // 21.2.5.6 RegExp.prototype[@@match](string)
                    // 21.2.5.9 RegExp.prototype[@@search](string)
                    : function (string) {
                        return rxfn.call(string, this);
                    });
            }
        };

        // @@match logic


        _fixReWks('match', 1, function (defined, MATCH, $match, maybeCallNative) {
            return [// `String.prototype.match` method
                // https://tc39.github.io/ecma262/#sec-string.prototype.match
                function match(regexp) {
                    var O = defined(this);
                    var fn = regexp == undefined ? undefined : regexp[MATCH];
                    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
                }, // `RegExp.prototype[@@match]` method
                // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
                function (regexp) {
                    var res = maybeCallNative($match, regexp, this);
                    if (res.done) return res.value;
                    var rx = _anObject(regexp);
                    var S = String(this);
                    if (!rx.global) return _regexpExecAbstract(rx, S);
                    var fullUnicode = rx.unicode;
                    rx.lastIndex = 0;
                    var A = [];
                    var n = 0;
                    var result;

                    while ((result = _regexpExecAbstract(rx, S)) !== null) {
                        var matchStr = String(result[0]);
                        A[n] = matchStr;
                        if (matchStr === '') rx.lastIndex = _advanceStringIndex(S, _toLength(rx.lastIndex), fullUnicode);
                        n++;
                    }

                    return n === 0 ? null : A;
                }];
        });

        var max$1 = Math.max;
        var min$2 = Math.min;
        var floor$3 = Math.floor;
        var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
        var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

        var maybeToString = function maybeToString(it) {
            return it === undefined ? it : String(it);
        }; // @@replace logic


        _fixReWks('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
            return [// `String.prototype.replace` method
                // https://tc39.github.io/ecma262/#sec-string.prototype.replace
                function replace(searchValue, replaceValue) {
                    var O = defined(this);
                    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
                    return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
                }, // `RegExp.prototype[@@replace]` method
                // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
                function (regexp, replaceValue) {
                    var res = maybeCallNative($replace, regexp, this, replaceValue);
                    if (res.done) return res.value;
                    var rx = _anObject(regexp);
                    var S = String(this);
                    var functionalReplace = typeof replaceValue === 'function';
                    if (!functionalReplace) replaceValue = String(replaceValue);
                    var global = rx.global;

                    if (global) {
                        var fullUnicode = rx.unicode;
                        rx.lastIndex = 0;
                    }

                    var results = [];

                    while (true) {
                        var result = _regexpExecAbstract(rx, S);
                        if (result === null) break;
                        results.push(result);
                        if (!global) break;
                        var matchStr = String(result[0]);
                        if (matchStr === '') rx.lastIndex = _advanceStringIndex(S, _toLength(rx.lastIndex), fullUnicode);
                    }

                    var accumulatedResult = '';
                    var nextSourcePosition = 0;

                    for (var i = 0; i < results.length; i++) {
                        result = results[i];
                        var matched = String(result[0]);
                        var position = max$1(min$2(_toInteger(result.index), S.length), 0);
                        var captures = []; // NOTE: This is equivalent to
                        //   captures = result.slice(1).map(maybeToString)
                        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
                        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
                        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

                        for (var j = 1; j < result.length; j++) {
                            captures.push(maybeToString(result[j]));
                        }

                        var namedCaptures = result.groups;

                        if (functionalReplace) {
                            var replacerArgs = [matched].concat(captures, position, S);
                            if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
                            var replacement = String(replaceValue.apply(undefined, replacerArgs));
                        } else {
                            replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
                        }

                        if (position >= nextSourcePosition) {
                            accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
                            nextSourcePosition = position + matched.length;
                        }
                    }

                    return accumulatedResult + S.slice(nextSourcePosition);
                }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

            function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
                var tailPos = position + matched.length;
                var m = captures.length;
                var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

                if (namedCaptures !== undefined) {
                    namedCaptures = _toObject(namedCaptures);
                    symbols = SUBSTITUTION_SYMBOLS;
                }

                return $replace.call(replacement, symbols, function (match, ch) {
                    var capture;

                    switch (ch.charAt(0)) {
                        case '$':
                            return '$';

                        case '&':
                            return matched;

                        case '`':
                            return str.slice(0, position);

                        case "'":
                            return str.slice(tailPos);

                        case '<':
                            capture = namedCaptures[ch.slice(1, -1)];
                            break;

                        default:
                            // \d\d?
                            var n = +ch;
                            if (n === 0) return match;

                            if (n > m) {
                                var f = floor$3(n / 10);
                                if (f === 0) return match;
                                if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                                return match;
                            }

                            capture = captures[n - 1];
                    }

                    return capture === undefined ? '' : capture;
                });
            }
        });

        // @@search logic


        _fixReWks('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
            return [// `String.prototype.search` method
                // https://tc39.github.io/ecma262/#sec-string.prototype.search
                function search(regexp) {
                    var O = defined(this);
                    var fn = regexp == undefined ? undefined : regexp[SEARCH];
                    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
                }, // `RegExp.prototype[@@search]` method
                // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
                function (regexp) {
                    var res = maybeCallNative($search, regexp, this);
                    if (res.done) return res.value;
                    var rx = _anObject(regexp);
                    var S = String(this);
                    var previousLastIndex = rx.lastIndex;
                    if (!_sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
                    var result = _regexpExecAbstract(rx, S);
                    if (!_sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
                    return result === null ? -1 : result.index;
                }];
        });

        // 7.3.20 SpeciesConstructor(O, defaultConstructor)




        var SPECIES$3 = _wks('species');

        var _speciesConstructor = function (O, D) {
            var C = _anObject(O).constructor;
            var S;
            return C === undefined || (S = _anObject(C)[SPECIES$3]) == undefined ? D : _aFunction(S);
        };

        var $min = Math.min;
        var $push = [].push;
        var $SPLIT = 'split';
        var LENGTH = 'length';
        var LAST_INDEX$1 = 'lastIndex';
        var MAX_UINT32 = 0xffffffff; // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

        var SUPPORTS_Y = !_fails(function () {
        }); // @@split logic

        _fixReWks('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
            var internalSplit;

            if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
                // based on es5-shim implementation, need to rework it
                internalSplit = function internalSplit(separator, limit) {
                    var string = String(this);
                    if (separator === undefined && limit === 0) return []; // If `separator` is not a regex, use native split

                    if (!_isRegexp(separator)) return $split.call(string, separator, limit);
                    var output = [];
                    var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
                    var lastLastIndex = 0;
                    var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0; // Make `global` and avoid `lastIndex` issues by working with a copy

                    var separatorCopy = new RegExp(separator.source, flags + 'g');
                    var match, lastIndex, lastLength;

                    while (match = _regexpExec.call(separatorCopy, string)) {
                        lastIndex = separatorCopy[LAST_INDEX$1];

                        if (lastIndex > lastLastIndex) {
                            output.push(string.slice(lastLastIndex, match.index));
                            if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
                            lastLength = match[0][LENGTH];
                            lastLastIndex = lastIndex;
                            if (output[LENGTH] >= splitLimit) break;
                        }

                        if (separatorCopy[LAST_INDEX$1] === match.index) separatorCopy[LAST_INDEX$1]++; // Avoid an infinite loop
                    }

                    if (lastLastIndex === string[LENGTH]) {
                        if (lastLength || !separatorCopy.test('')) output.push('');
                    } else output.push(string.slice(lastLastIndex));

                    return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
                }; // Chakra, V8

            } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
                internalSplit = function internalSplit(separator, limit) {
                    return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
                };
            } else {
                internalSplit = $split;
            }

            return [// `String.prototype.split` method
                // https://tc39.github.io/ecma262/#sec-string.prototype.split
                function split(separator, limit) {
                    var O = defined(this);
                    var splitter = separator == undefined ? undefined : separator[SPLIT];
                    return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
                }, // `RegExp.prototype[@@split]` method
                // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
                //
                // NOTE: This cannot be properly polyfilled in engines that don't support
                // the 'y' flag.
                function (regexp, limit) {
                    var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
                    if (res.done) return res.value;
                    var rx = _anObject(regexp);
                    var S = String(this);
                    var C = _speciesConstructor(rx, RegExp);
                    var unicodeMatching = rx.unicode;
                    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
                    // simulate the 'y' flag.

                    var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
                    var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
                    if (lim === 0) return [];
                    if (S.length === 0) return _regexpExecAbstract(splitter, S) === null ? [S] : [];
                    var p = 0;
                    var q = 0;
                    var A = [];

                    while (q < S.length) {
                        splitter.lastIndex = SUPPORTS_Y ? q : 0;
                        var z = _regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
                        var e;

                        if (z === null || (e = $min(_toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
                            q = _advanceStringIndex(S, q, unicodeMatching);
                        } else {
                            A.push(S.slice(p, q));
                            if (A.length === lim) return A;

                            for (var i = 1; i <= z.length - 1; i++) {
                                A.push(z[i]);
                                if (A.length === lim) return A;
                            }

                            q = p = e;
                        }
                    }

                    A.push(S.slice(p));
                    return A;
                }];
        });

        var _anInstance = function (it, Constructor, name, forbiddenField) {
            if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
                throw TypeError(name + ': incorrect invocation!');
            }

            return it;
        };

        var _forOf = createCommonjsModule(function (module) {
            var BREAK = {};
            var RETURN = {};

            var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
                var iterFn = ITERATOR ? function () {
                    return iterable;
                } : core_getIteratorMethod(iterable);
                var f = _ctx(fn, that, entries ? 2 : 1);
                var index = 0;
                var length, step, iterator, result;
                if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator

                if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
                    result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
                    if (result === BREAK || result === RETURN) return result;
                } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
                    result = _iterCall(iterator, f, step.value, entries);
                    if (result === BREAK || result === RETURN) return result;
                }
            };

            exports.BREAK = BREAK;
            exports.RETURN = RETURN;
        });

        var process = _global.process;
        var setTask = _global.setImmediate;
        var clearTask = _global.clearImmediate;
        var MessageChannel = _global.MessageChannel;
        var Dispatch = _global.Dispatch;
        var counter = 0;
        var queue = {};
        var ONREADYSTATECHANGE = 'onreadystatechange';
        var defer, channel, port;

        var run = function run() {
            var id = +this; // eslint-disable-next-line no-prototype-builtins

            if (queue.hasOwnProperty(id)) {
                var fn = queue[id];
                delete queue[id];
                fn();
            }
        };

        var listener = function listener(event) {
            run.call(event.data);
        }; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


        if (!setTask || !clearTask) {
            setTask = function setImmediate(fn) {
                var args = [];
                var i = 1;

                while (arguments.length > i) {
                    args.push(arguments[i++]);
                }

                queue[++counter] = function () {
                    // eslint-disable-next-line no-new-func
                    _invoke(typeof fn == 'function' ? fn : Function(fn), args);
                };

                defer(counter);
                return counter;
            };

            clearTask = function clearImmediate(id) {
                delete queue[id];
            }; // Node.js 0.8-


            if (_cof(process) == 'process') {
                defer = function defer(id) {
                    process.nextTick(_ctx(run, id, 1));
                }; // Sphere (JS game engine) Dispatch API

            } else if (Dispatch && Dispatch.now) {
                defer = function defer(id) {
                    Dispatch.now(_ctx(run, id, 1));
                }; // Browsers with MessageChannel, includes WebWorkers

            } else if (MessageChannel) {
                channel = new MessageChannel();
                port = channel.port2;
                channel.port1.onmessage = listener;
                defer = _ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
                // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
            } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
                defer = function defer(id) {
                    _global.postMessage(id + '', '*');
                };

                _global.addEventListener('message', listener, false); // IE8-
            } else if (ONREADYSTATECHANGE in _domCreate('script')) {
                defer = function defer(id) {
                    _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
                        _html.removeChild(this);
                        run.call(id);
                    };
                }; // Rest old browsers

            } else {
                defer = function defer(id) {
                    setTimeout(_ctx(run, id, 1), 0);
                };
            }
        }

        var _task = {
            set: setTask,
            clear: clearTask
        };

        var macrotask = _task.set;

        var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
        var process$1 = _global.process;
        var Promise = _global.Promise;
        var isNode = _cof(process$1) == 'process';

        var _microtask = function () {
            var head, last, notify;

            var flush = function flush() {
                var parent, fn;
                if (isNode && (parent = process$1.domain)) parent.exit();

                while (head) {
                    fn = head.fn;
                    head = head.next;

                    try {
                        fn();
                    } catch (e) {
                        if (head) notify();else last = undefined;
                        throw e;
                    }
                }

                last = undefined;
                if (parent) parent.enter();
            }; // Node.js


            if (isNode) {
                notify = function notify() {
                    process$1.nextTick(flush);
                }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339

            } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {
                var toggle = true;
                var node = document.createTextNode('');
                new Observer(flush).observe(node, {
                    characterData: true
                }); // eslint-disable-line no-new

                notify = function notify() {
                    node.data = toggle = !toggle;
                }; // environments with maybe non-completely correct, but existent Promise

            } else if (Promise && Promise.resolve) {
                // Promise.resolve without an argument throws an error in LG WebOS 2
                var promise = Promise.resolve(undefined);

                notify = function notify() {
                    promise.then(flush);
                }; // for other environments - macrotask based on:
                // - setImmediate
                // - MessageChannel
                // - window.postMessag
                // - onreadystatechange
                // - setTimeout

            } else {
                notify = function notify() {
                    // strange IE + webpack dev server bug - use .call(global)
                    macrotask.call(_global, flush);
                };
            }

            return function (fn) {
                var task = {
                    fn: fn,
                    next: undefined
                };
                if (last) last.next = task;

                if (!head) {
                    head = task;
                    notify();
                }

                last = task;
            };
        };

        function PromiseCapability(C) {
            var resolve, reject;
            this.promise = new C(function ($$resolve, $$reject) {
                if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
                resolve = $$resolve;
                reject = $$reject;
            });
            this.resolve = _aFunction(resolve);
            this.reject = _aFunction(reject);
        }

        var f$7 = function (C) {
            return new PromiseCapability(C);
        };

        var _newPromiseCapability = {
            f: f$7
        };

        var _perform = function (exec) {
            try {
                return {
                    e: false,
                    v: exec()
                };
            } catch (e) {
                return {
                    e: true,
                    v: e
                };
            }
        };

        var navigator = _global.navigator;
        var _userAgent = navigator && navigator.userAgent || '';

        var _promiseResolve = function (C, x) {
            _anObject(C);
            if (_isObject(x) && x.constructor === C) return x;
            var promiseCapability = _newPromiseCapability.f(C);
            var resolve = promiseCapability.resolve;
            resolve(x);
            return promiseCapability.promise;
        };

        var _redefineAll = function (target, src, safe) {
            for (var key in src) {
                _redefine(target, key, src[key], safe);
            }

            return target;
        };

        var task = _task.set;

        var microtask = _microtask();









        var PROMISE = 'Promise';
        var TypeError$1 = _global.TypeError;
        var process$2 = _global.process;
        var versions = process$2 && process$2.versions;
        var v8 = versions && versions.v8 || '';
        var $Promise = _global[PROMISE];
        var isNode$1 = _classof(process$2) == 'process';

        var empty = function empty() {
            /* empty */
        };

        var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
        var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;
        var USE_NATIVE$1 = !!function () {
            try {
                // correct subclassing with @@species support
                var promise = $Promise.resolve(1);

                var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
                    exec(empty, empty);
                }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test


                return (isNode$1 || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
                    // we can't detect it synchronously, so just check versions
                    && v8.indexOf('6.6') !== 0 && _userAgent.indexOf('Chrome/66') === -1;
            } catch (e) {
                /* empty */
            }
        }(); // helpers

        var isThenable = function isThenable(it) {
            var then;
            return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
        };

        var notify = function notify(promise, isReject) {
            if (promise._n) return;
            promise._n = true;
            var chain = promise._c;
            microtask(function () {
                var value = promise._v;
                var ok = promise._s == 1;
                var i = 0;

                var run = function run(reaction) {
                    var handler = ok ? reaction.ok : reaction.fail;
                    var resolve = reaction.resolve;
                    var reject = reaction.reject;
                    var domain = reaction.domain;
                    var result, then, exited;

                    try {
                        if (handler) {
                            if (!ok) {
                                if (promise._h == 2) onHandleUnhandled(promise);
                                promise._h = 1;
                            }

                            if (handler === true) result = value;else {
                                if (domain) domain.enter();
                                result = handler(value); // may throw

                                if (domain) {
                                    domain.exit();
                                    exited = true;
                                }
                            }

                            if (result === reaction.promise) {
                                reject(TypeError$1('Promise-chain cycle'));
                            } else if (then = isThenable(result)) {
                                then.call(result, resolve, reject);
                            } else resolve(result);
                        } else reject(value);
                    } catch (e) {
                        if (domain && !exited) domain.exit();
                        reject(e);
                    }
                };

                while (chain.length > i) {
                    run(chain[i++]);
                } // variable length - can't use forEach


                promise._c = [];
                promise._n = false;
                if (isReject && !promise._h) onUnhandled(promise);
            });
        };

        var onUnhandled = function onUnhandled(promise) {
            task.call(_global, function () {
                var value = promise._v;
                var unhandled = isUnhandled(promise);
                var result, handler, console;

                if (unhandled) {
                    result = _perform(function () {
                        if (isNode$1) {
                            process$2.emit('unhandledRejection', value, promise);
                        } else if (handler = _global.onunhandledrejection) {
                            handler({
                                promise: promise,
                                reason: value
                            });
                        } else if ((console = _global.console) && console.error) {
                            console.error('Unhandled promise rejection', value);
                        }
                    }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

                    promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
                }

                promise._a = undefined;
                if (unhandled && result.e) throw result.v;
            });
        };

        var isUnhandled = function isUnhandled(promise) {
            return promise._h !== 1 && (promise._a || promise._c).length === 0;
        };

        var onHandleUnhandled = function onHandleUnhandled(promise) {
            task.call(_global, function () {
                var handler;

                if (isNode$1) {
                    process$2.emit('rejectionHandled', promise);
                } else if (handler = _global.onrejectionhandled) {
                    handler({
                        promise: promise,
                        reason: promise._v
                    });
                }
            });
        };

        var $reject = function $reject(value) {
            var promise = this;
            if (promise._d) return;
            promise._d = true;
            promise = promise._w || promise; // unwrap

            promise._v = value;
            promise._s = 2;
            if (!promise._a) promise._a = promise._c.slice();
            notify(promise, true);
        };

        var $resolve = function $resolve(value) {
            var promise = this;
            var then;
            if (promise._d) return;
            promise._d = true;
            promise = promise._w || promise; // unwrap

            try {
                if (promise === value) throw TypeError$1("Promise can't be resolved itself");

                if (then = isThenable(value)) {
                    microtask(function () {
                        var wrapper = {
                            _w: promise,
                            _d: false
                        }; // wrap

                        try {
                            then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
                        } catch (e) {
                            $reject.call(wrapper, e);
                        }
                    });
                } else {
                    promise._v = value;
                    promise._s = 1;
                    notify(promise, false);
                }
            } catch (e) {
                $reject.call({
                    _w: promise,
                    _d: false
                }, e); // wrap
            }
        }; // constructor polyfill


        if (!USE_NATIVE$1) {
            // 25.4.3.1 Promise(executor)
            $Promise = function Promise(executor) {
                _anInstance(this, $Promise, PROMISE, '_h');
                _aFunction(executor);
                Internal.call(this);

                try {
                    executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
                } catch (err) {
                    $reject.call(this, err);
                }
            }; // eslint-disable-next-line no-unused-vars


            Internal = function Promise(executor) {
                this._c = []; // <- awaiting reactions

                this._a = undefined; // <- checked in isUnhandled reactions

                this._s = 0; // <- state

                this._d = false; // <- done

                this._v = undefined; // <- value

                this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled

                this._n = false; // <- notify
            };

            Internal.prototype = _redefineAll($Promise.prototype, {
                // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
                then: function then(onFulfilled, onRejected) {
                    var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
                    reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
                    reaction.fail = typeof onRejected == 'function' && onRejected;
                    reaction.domain = isNode$1 ? process$2.domain : undefined;

                    this._c.push(reaction);

                    if (this._a) this._a.push(reaction);
                    if (this._s) notify(this, false);
                    return reaction.promise;
                },
                // 25.4.5.1 Promise.prototype.catch(onRejected)
                'catch': function _catch(onRejected) {
                    return this.then(undefined, onRejected);
                }
            });

            OwnPromiseCapability = function OwnPromiseCapability() {
                var promise = new Internal();
                this.promise = promise;
                this.resolve = _ctx($resolve, promise, 1);
                this.reject = _ctx($reject, promise, 1);
            };

            _newPromiseCapability.f = newPromiseCapability = function newPromiseCapability(C) {
                return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
            };
        }

        _export(_export.G + _export.W + _export.F * !USE_NATIVE$1, {
            Promise: $Promise
        });

        _setToStringTag($Promise, PROMISE);

        _setSpecies(PROMISE);

        Wrapper = _core[PROMISE]; // statics

        _export(_export.S + _export.F * !USE_NATIVE$1, PROMISE, {
            // 25.4.4.5 Promise.reject(r)
            reject: function reject(r) {
                var capability = newPromiseCapability(this);
                var $$reject = capability.reject;
                $$reject(r);
                return capability.promise;
            }
        });
        _export(_export.S + _export.F * (_library || !USE_NATIVE$1), PROMISE, {
            // 25.4.4.6 Promise.resolve(x)
            resolve: function resolve(x) {
                return _promiseResolve(_library && this === Wrapper ? $Promise : this, x);
            }
        });
        _export(_export.S + _export.F * !(USE_NATIVE$1 && _iterDetect(function (iter) {
            $Promise.all(iter)['catch'](empty);
        })), PROMISE, {
            // 25.4.4.1 Promise.all(iterable)
            all: function all(iterable) {
                var C = this;
                var capability = newPromiseCapability(C);
                var resolve = capability.resolve;
                var reject = capability.reject;
                var result = _perform(function () {
                    var values = [];
                    var index = 0;
                    var remaining = 1;
                    _forOf(iterable, false, function (promise) {
                        var $index = index++;
                        var alreadyCalled = false;
                        values.push(undefined);
                        remaining++;
                        C.resolve(promise).then(function (value) {
                            if (alreadyCalled) return;
                            alreadyCalled = true;
                            values[$index] = value;
                            --remaining || resolve(values);
                        }, reject);
                    });
                    --remaining || resolve(values);
                });
                if (result.e) reject(result.v);
                return capability.promise;
            },
            // 25.4.4.4 Promise.race(iterable)
            race: function race(iterable) {
                var C = this;
                var capability = newPromiseCapability(C);
                var reject = capability.reject;
                var result = _perform(function () {
                    _forOf(iterable, false, function (promise) {
                        C.resolve(promise).then(capability.resolve, reject);
                    });
                });
                if (result.e) reject(result.v);
                return capability.promise;
            }
        });

        var _validateCollection = function (it, TYPE) {
            if (!_isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
            return it;
        };

        var dP$5 = _objectDp.f;



















        var fastKey = _meta.fastKey;



        var SIZE = _descriptors ? '_s' : 'size';

        var getEntry = function getEntry(that, key) {
            // fast case
            var index = fastKey(key);
            var entry;
            if (index !== 'F') return that._i[index]; // frozen object case

            for (entry = that._f; entry; entry = entry.n) {
                if (entry.k == key) return entry;
            }
        };

        var _collectionStrong = {
            getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
                var C = wrapper(function (that, iterable) {
                    _anInstance(that, C, NAME, '_i');
                    that._t = NAME; // collection type

                    that._i = _objectCreate(null); // index

                    that._f = undefined; // first entry

                    that._l = undefined; // last entry

                    that[SIZE] = 0; // size

                    if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
                });
                _redefineAll(C.prototype, {
                    // 23.1.3.1 Map.prototype.clear()
                    // 23.2.3.2 Set.prototype.clear()
                    clear: function clear() {
                        for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
                            entry.r = true;
                            if (entry.p) entry.p = entry.p.n = undefined;
                            delete data[entry.i];
                        }

                        that._f = that._l = undefined;
                        that[SIZE] = 0;
                    },
                    // 23.1.3.3 Map.prototype.delete(key)
                    // 23.2.3.4 Set.prototype.delete(value)
                    'delete': function _delete(key) {
                        var that = _validateCollection(this, NAME);
                        var entry = getEntry(that, key);

                        if (entry) {
                            var next = entry.n;
                            var prev = entry.p;
                            delete that._i[entry.i];
                            entry.r = true;
                            if (prev) prev.n = next;
                            if (next) next.p = prev;
                            if (that._f == entry) that._f = next;
                            if (that._l == entry) that._l = prev;
                            that[SIZE]--;
                        }

                        return !!entry;
                    },
                    // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
                    // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
                    forEach: function forEach(callbackfn
                                              /* , that = undefined */
                    ) {
                        _validateCollection(this, NAME);
                        var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
                        var entry;

                        while (entry = entry ? entry.n : this._f) {
                            f(entry.v, entry.k, this); // revert to the last existing entry

                            while (entry && entry.r) {
                                entry = entry.p;
                            }
                        }
                    },
                    // 23.1.3.7 Map.prototype.has(key)
                    // 23.2.3.7 Set.prototype.has(value)
                    has: function has(key) {
                        return !!getEntry(_validateCollection(this, NAME), key);
                    }
                });
                if (_descriptors) dP$5(C.prototype, 'size', {
                    get: function get() {
                        return _validateCollection(this, NAME)[SIZE];
                    }
                });
                return C;
            },
            def: function def(that, key, value) {
                var entry = getEntry(that, key);
                var prev, index; // change existing entry

                if (entry) {
                    entry.v = value; // create new entry
                } else {
                    that._l = entry = {
                        i: index = fastKey(key, true),
                        // <- index
                        k: key,
                        // <- key
                        v: value,
                        // <- value
                        p: prev = that._l,
                        // <- previous entry
                        n: undefined,
                        // <- next entry
                        r: false // <- removed

                    };
                    if (!that._f) that._f = entry;
                    if (prev) prev.n = entry;
                    that[SIZE]++; // add to index

                    if (index !== 'F') that._i[index] = entry;
                }

                return that;
            },
            getEntry: getEntry,
            setStrong: function setStrong(C, NAME, IS_MAP) {
                // add .keys, .values, .entries, [@@iterator]
                // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
                _iterDefine(C, NAME, function (iterated, kind) {
                    this._t = _validateCollection(iterated, NAME); // target

                    this._k = kind; // kind

                    this._l = undefined; // previous
                }, function () {
                    var that = this;
                    var kind = that._k;
                    var entry = that._l; // revert to the last existing entry

                    while (entry && entry.r) {
                        entry = entry.p;
                    } // get next entry


                    if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
                        // or finish the iteration
                        that._t = undefined;
                        return _iterStep(1);
                    } // return step by kind


                    if (kind == 'keys') return _iterStep(0, entry.k);
                    if (kind == 'values') return _iterStep(0, entry.v);
                    return _iterStep(0, [entry.k, entry.v]);
                }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

                _setSpecies(NAME);
            }
        };

        var _collection = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
            var Base = _global[NAME];
            var C = Base;
            var ADDER = IS_MAP ? 'set' : 'add';
            var proto = C && C.prototype;
            var O = {};

            var fixMethod = function fixMethod(KEY) {
                var fn = proto[KEY];
                _redefine(proto, KEY, KEY == 'delete' ? function (a) {
                    return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
                } : KEY == 'has' ? function has(a) {
                    return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
                } : KEY == 'get' ? function get(a) {
                    return IS_WEAK && !_isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
                } : KEY == 'add' ? function add(a) {
                    fn.call(this, a === 0 ? 0 : a);
                    return this;
                } : function set(a, b) {
                    fn.call(this, a === 0 ? 0 : a, b);
                    return this;
                });
            };

            if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {
                new C().entries().next();
            }))) {
                // create collection constructor
                C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
                _redefineAll(C.prototype, methods);
                _meta.NEED = true;
            } else {
                var instance = new C(); // early implementations not supports chaining

                var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false

                var THROWS_ON_PRIMITIVES = _fails(function () {
                    instance.has(1);
                }); // most early implementations doesn't supports iterables, most modern - not close it correctly

                var ACCEPT_ITERABLES = _iterDetect(function (iter) {
                    new C(iter);
                }); // eslint-disable-line no-new
                // for early implementations -0 and +0 not the same

                var BUGGY_ZERO = !IS_WEAK && _fails(function () {
                    // V8 ~ Chromium 42- fails only with 5+ elements
                    var $instance = new C();
                    var index = 5;

                    while (index--) {
                        $instance[ADDER](index, index);
                    }

                    return !$instance.has(-0);
                });

                if (!ACCEPT_ITERABLES) {
                    C = wrapper(function (target, iterable) {
                        _anInstance(target, C, NAME);
                        var that = _inheritIfRequired(new Base(), target, C);
                        if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
                        return that;
                    });
                    C.prototype = proto;
                    proto.constructor = C;
                }

                if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
                    fixMethod('delete');
                    fixMethod('has');
                    IS_MAP && fixMethod('get');
                }

                if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

                if (IS_WEAK && proto.clear) delete proto.clear;
            }

            _setToStringTag(C, NAME);
            O[NAME] = C;
            _export(_export.G + _export.W + _export.F * (C != Base), O);
            if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
            return C;
        };

        var MAP = 'Map'; // 23.1 Map Objects

        var es6_map = _collection(MAP, function (get) {
            return function Map() {
                return get(this, arguments.length > 0 ? arguments[0] : undefined);
            };
        }, {
            // 23.1.3.6 Map.prototype.get(key)
            get: function get(key) {
                var entry = _collectionStrong.getEntry(_validateCollection(this, MAP), key);
                return entry && entry.v;
            },
            // 23.1.3.9 Map.prototype.set(key, value)
            set: function set(key, value) {
                return _collectionStrong.def(_validateCollection(this, MAP), key === 0 ? 0 : key, value);
            }
        }, _collectionStrong, true);

        var SET = 'Set'; // 23.2 Set Objects

        var es6_set = _collection(SET, function (get) {
            return function Set() {
                return get(this, arguments.length > 0 ? arguments[0] : undefined);
            };
        }, {
            // 23.2.3.1 Set.prototype.add(value)
            add: function add(value) {
                return _collectionStrong.def(_validateCollection(this, SET), value = value === 0 ? 0 : value, value);
            }
        }, _collectionStrong);

        var getWeak = _meta.getWeak;















        var arrayFind = _arrayMethods(5);
        var arrayFindIndex = _arrayMethods(6);
        var id$1 = 0; // fallback for uncaught frozen keys

        var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
            return that._l || (that._l = new UncaughtFrozenStore());
        };

        var UncaughtFrozenStore = function UncaughtFrozenStore() {
            this.a = [];
        };

        var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
            return arrayFind(store.a, function (it) {
                return it[0] === key;
            });
        };

        UncaughtFrozenStore.prototype = {
            get: function get(key) {
                var entry = findUncaughtFrozen(this, key);
                if (entry) return entry[1];
            },
            has: function has(key) {
                return !!findUncaughtFrozen(this, key);
            },
            set: function set(key, value) {
                var entry = findUncaughtFrozen(this, key);
                if (entry) entry[1] = value;else this.a.push([key, value]);
            },
            'delete': function _delete(key) {
                var index = arrayFindIndex(this.a, function (it) {
                    return it[0] === key;
                });
                if (~index) this.a.splice(index, 1);
                return !!~index;
            }
        };
        var _collectionWeak = {
            getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
                var C = wrapper(function (that, iterable) {
                    _anInstance(that, C, NAME, '_i');
                    that._t = NAME; // collection type

                    that._i = id$1++; // collection id

                    that._l = undefined; // leak store for uncaught frozen objects

                    if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
                });
                _redefineAll(C.prototype, {
                    // 23.3.3.2 WeakMap.prototype.delete(key)
                    // 23.4.3.3 WeakSet.prototype.delete(value)
                    'delete': function _delete(key) {
                        if (!_isObject(key)) return false;
                        var data = getWeak(key);
                        if (data === true) return uncaughtFrozenStore(_validateCollection(this, NAME))['delete'](key);
                        return data && _has(data, this._i) && delete data[this._i];
                    },
                    // 23.3.3.4 WeakMap.prototype.has(key)
                    // 23.4.3.4 WeakSet.prototype.has(value)
                    has: function has(key) {
                        if (!_isObject(key)) return false;
                        var data = getWeak(key);
                        if (data === true) return uncaughtFrozenStore(_validateCollection(this, NAME)).has(key);
                        return data && _has(data, this._i);
                    }
                });
                return C;
            },
            def: function def(that, key, value) {
                var data = getWeak(_anObject(key), true);
                if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
                return that;
            },
            ufstore: uncaughtFrozenStore
        };

        var es6_weakMap = createCommonjsModule(function (module) {

            var each = _arrayMethods(0);















            var WEAK_MAP = 'WeakMap';
            var getWeak = _meta.getWeak;
            var isExtensible = Object.isExtensible;
            var uncaughtFrozenStore = _collectionWeak.ufstore;
            var tmp = {};
            var InternalMap;

            var wrapper = function wrapper(get) {
                return function WeakMap() {
                    return get(this, arguments.length > 0 ? arguments[0] : undefined);
                };
            };

            var methods = {
                // 23.3.3.3 WeakMap.prototype.get(key)
                get: function get(key) {
                    if (_isObject(key)) {
                        var data = getWeak(key);
                        if (data === true) return uncaughtFrozenStore(_validateCollection(this, WEAK_MAP)).get(key);
                        return data ? data[this._i] : undefined;
                    }
                },
                // 23.3.3.5 WeakMap.prototype.set(key, value)
                set: function set(key, value) {
                    return _collectionWeak.def(_validateCollection(this, WEAK_MAP), key, value);
                }
            }; // 23.3 WeakMap Objects

            var $WeakMap = module.exports = _collection(WEAK_MAP, wrapper, methods, _collectionWeak, true, true); // IE11 WeakMap frozen keys fix


            if (_fails(function () {
                return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;
            })) {
                InternalMap = _collectionWeak.getConstructor(wrapper, WEAK_MAP);
                _objectAssign(InternalMap.prototype, methods);
                _meta.NEED = true;
                each(['delete', 'has', 'get', 'set'], function (key) {
                    var proto = $WeakMap.prototype;
                    var method = proto[key];
                    _redefine(proto, key, function (a, b) {
                        // store frozen objects on internal weakmap shim
                        if (_isObject(a) && !isExtensible(a)) {
                            if (!this._f) this._f = new InternalMap();

                            var result = this._f[key](a, b);

                            return key == 'set' ? this : result; // store all the rest on native weakmap
                        }

                        return method.call(this, a, b);
                    });
                });
            }
        });

        var WEAK_SET = 'WeakSet'; // 23.4 WeakSet Objects

        _collection(WEAK_SET, function (get) {
            return function WeakSet() {
                return get(this, arguments.length > 0 ? arguments[0] : undefined);
            };
        }, {
            // 23.4.3.1 WeakSet.prototype.add(value)
            add: function add(value) {
                return _collectionWeak.def(_validateCollection(this, WEAK_SET), value, true);
            }
        }, _collectionWeak, false, true);

        var TYPED = _uid('typed_array');
        var VIEW = _uid('view');
        var ABV = !!(_global.ArrayBuffer && _global.DataView);
        var CONSTR = ABV;
        var i$1 = 0;
        var l = 9;
        var Typed;
        var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

        while (i$1 < l) {
            if (Typed = _global[TypedArrayConstructors[i$1++]]) {
                _hide(Typed.prototype, TYPED, true);
                _hide(Typed.prototype, VIEW, true);
            } else CONSTR = false;
        }

        var _typed = {
            ABV: ABV,
            CONSTR: CONSTR,
            TYPED: TYPED,
            VIEW: VIEW
        };

        // https://tc39.github.io/ecma262/#sec-toindex




        var _toIndex = function (it) {
            if (it === undefined) return 0;
            var number = _toInteger(it);
            var length = _toLength(number);
            if (number !== length) throw RangeError('Wrong length!');
            return length;
        };

        var _typedBuffer = createCommonjsModule(function (module, exports) {























            var gOPN = _objectGopn.f;

            var dP = _objectDp.f;





            var ARRAY_BUFFER = 'ArrayBuffer';
            var DATA_VIEW = 'DataView';
            var PROTOTYPE = 'prototype';
            var WRONG_LENGTH = 'Wrong length!';
            var WRONG_INDEX = 'Wrong index!';
            var $ArrayBuffer = _global[ARRAY_BUFFER];
            var $DataView = _global[DATA_VIEW];
            var Math = _global.Math;
            var RangeError = _global.RangeError; // eslint-disable-next-line no-shadow-restricted-names

            var Infinity = _global.Infinity;
            var BaseBuffer = $ArrayBuffer;
            var abs = Math.abs;
            var pow = Math.pow;
            var floor = Math.floor;
            var log = Math.log;
            var LN2 = Math.LN2;
            var BUFFER = 'buffer';
            var BYTE_LENGTH = 'byteLength';
            var BYTE_OFFSET = 'byteOffset';
            var $BUFFER = _descriptors ? '_b' : BUFFER;
            var $LENGTH = _descriptors ? '_l' : BYTE_LENGTH;
            var $OFFSET = _descriptors ? '_o' : BYTE_OFFSET; // IEEE754 conversions based on https://github.com/feross/ieee754

            function packIEEE754(value, mLen, nBytes) {
                var buffer = new Array(nBytes);
                var eLen = nBytes * 8 - mLen - 1;
                var eMax = (1 << eLen) - 1;
                var eBias = eMax >> 1;
                var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
                var i = 0;
                var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
                var e, m, c;
                value = abs(value); // eslint-disable-next-line no-self-compare

                if (value != value || value === Infinity) {
                    // eslint-disable-next-line no-self-compare
                    m = value != value ? 1 : 0;
                    e = eMax;
                } else {
                    e = floor(log(value) / LN2);

                    if (value * (c = pow(2, -e)) < 1) {
                        e--;
                        c *= 2;
                    }

                    if (e + eBias >= 1) {
                        value += rt / c;
                    } else {
                        value += rt * pow(2, 1 - eBias);
                    }

                    if (value * c >= 2) {
                        e++;
                        c /= 2;
                    }

                    if (e + eBias >= eMax) {
                        m = 0;
                        e = eMax;
                    } else if (e + eBias >= 1) {
                        m = (value * c - 1) * pow(2, mLen);
                        e = e + eBias;
                    } else {
                        m = value * pow(2, eBias - 1) * pow(2, mLen);
                        e = 0;
                    }
                }

                for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8) {
                }

                e = e << mLen | m;
                eLen += mLen;

                for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8) {
                }

                buffer[--i] |= s * 128;
                return buffer;
            }

            function unpackIEEE754(buffer, mLen, nBytes) {
                var eLen = nBytes * 8 - mLen - 1;
                var eMax = (1 << eLen) - 1;
                var eBias = eMax >> 1;
                var nBits = eLen - 7;
                var i = nBytes - 1;
                var s = buffer[i--];
                var e = s & 127;
                var m;
                s >>= 7;

                for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8) {
                }

                m = e & (1 << -nBits) - 1;
                e >>= -nBits;
                nBits += mLen;

                for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8) {
                }

                if (e === 0) {
                    e = 1 - eBias;
                } else if (e === eMax) {
                    return m ? NaN : s ? -Infinity : Infinity;
                } else {
                    m = m + pow(2, mLen);
                    e = e - eBias;
                }

                return (s ? -1 : 1) * m * pow(2, e - mLen);
            }

            function unpackI32(bytes) {
                return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
            }

            function packI8(it) {
                return [it & 0xff];
            }

            function packI16(it) {
                return [it & 0xff, it >> 8 & 0xff];
            }

            function packI32(it) {
                return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
            }

            function packF64(it) {
                return packIEEE754(it, 52, 8);
            }

            function packF32(it) {
                return packIEEE754(it, 23, 4);
            }

            function addGetter(C, key, internal) {
                dP(C[PROTOTYPE], key, {
                    get: function get() {
                        return this[internal];
                    }
                });
            }

            function get(view, bytes, index, isLittleEndian) {
                var numIndex = +index;
                var intIndex = _toIndex(numIndex);
                if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
                var store = view[$BUFFER]._b;
                var start = intIndex + view[$OFFSET];
                var pack = store.slice(start, start + bytes);
                return isLittleEndian ? pack : pack.reverse();
            }

            function set(view, bytes, index, conversion, value, isLittleEndian) {
                var numIndex = +index;
                var intIndex = _toIndex(numIndex);
                if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
                var store = view[$BUFFER]._b;
                var start = intIndex + view[$OFFSET];
                var pack = conversion(+value);

                for (var i = 0; i < bytes; i++) {
                    store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
                }
            }

            if (!_typed.ABV) {
                $ArrayBuffer = function ArrayBuffer(length) {
                    _anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
                    var byteLength = _toIndex(length);
                    this._b = _arrayFill.call(new Array(byteLength), 0);
                    this[$LENGTH] = byteLength;
                };

                $DataView = function DataView(buffer, byteOffset, byteLength) {
                    _anInstance(this, $DataView, DATA_VIEW);
                    _anInstance(buffer, $ArrayBuffer, DATA_VIEW);
                    var bufferLength = buffer[$LENGTH];
                    var offset = _toInteger(byteOffset);
                    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
                    byteLength = byteLength === undefined ? bufferLength - offset : _toLength(byteLength);
                    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
                    this[$BUFFER] = buffer;
                    this[$OFFSET] = offset;
                    this[$LENGTH] = byteLength;
                };

                if (_descriptors) {
                    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
                    addGetter($DataView, BUFFER, '_b');
                    addGetter($DataView, BYTE_LENGTH, '_l');
                    addGetter($DataView, BYTE_OFFSET, '_o');
                }

                _redefineAll($DataView[PROTOTYPE], {
                    getInt8: function getInt8(byteOffset) {
                        return get(this, 1, byteOffset)[0] << 24 >> 24;
                    },
                    getUint8: function getUint8(byteOffset) {
                        return get(this, 1, byteOffset)[0];
                    },
                    getInt16: function getInt16(byteOffset
                                                /* , littleEndian */
                    ) {
                        var bytes = get(this, 2, byteOffset, arguments[1]);
                        return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
                    },
                    getUint16: function getUint16(byteOffset
                                                  /* , littleEndian */
                    ) {
                        var bytes = get(this, 2, byteOffset, arguments[1]);
                        return bytes[1] << 8 | bytes[0];
                    },
                    getInt32: function getInt32(byteOffset
                                                /* , littleEndian */
                    ) {
                        return unpackI32(get(this, 4, byteOffset, arguments[1]));
                    },
                    getUint32: function getUint32(byteOffset
                                                  /* , littleEndian */
                    ) {
                        return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
                    },
                    getFloat32: function getFloat32(byteOffset
                                                    /* , littleEndian */
                    ) {
                        return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
                    },
                    getFloat64: function getFloat64(byteOffset
                                                    /* , littleEndian */
                    ) {
                        return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
                    },
                    setInt8: function setInt8(byteOffset, value) {
                        set(this, 1, byteOffset, packI8, value);
                    },
                    setUint8: function setUint8(byteOffset, value) {
                        set(this, 1, byteOffset, packI8, value);
                    },
                    setInt16: function setInt16(byteOffset, value
                                                /* , littleEndian */
                    ) {
                        set(this, 2, byteOffset, packI16, value, arguments[2]);
                    },
                    setUint16: function setUint16(byteOffset, value
                                                  /* , littleEndian */
                    ) {
                        set(this, 2, byteOffset, packI16, value, arguments[2]);
                    },
                    setInt32: function setInt32(byteOffset, value
                                                /* , littleEndian */
                    ) {
                        set(this, 4, byteOffset, packI32, value, arguments[2]);
                    },
                    setUint32: function setUint32(byteOffset, value
                                                  /* , littleEndian */
                    ) {
                        set(this, 4, byteOffset, packI32, value, arguments[2]);
                    },
                    setFloat32: function setFloat32(byteOffset, value
                                                    /* , littleEndian */
                    ) {
                        set(this, 4, byteOffset, packF32, value, arguments[2]);
                    },
                    setFloat64: function setFloat64(byteOffset, value
                                                    /* , littleEndian */
                    ) {
                        set(this, 8, byteOffset, packF64, value, arguments[2]);
                    }
                });
            } else {
                if (!_fails(function () {
                    $ArrayBuffer(1);
                }) || !_fails(function () {
                    new $ArrayBuffer(-1); // eslint-disable-line no-new
                }) || _fails(function () {
                    new $ArrayBuffer(); // eslint-disable-line no-new

                    new $ArrayBuffer(1.5); // eslint-disable-line no-new

                    new $ArrayBuffer(NaN); // eslint-disable-line no-new

                    return $ArrayBuffer.name != ARRAY_BUFFER;
                })) {
                    $ArrayBuffer = function ArrayBuffer(length) {
                        _anInstance(this, $ArrayBuffer);
                        return new BaseBuffer(_toIndex(length));
                    };

                    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];

                    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
                        if (!((key = keys[j++]) in $ArrayBuffer)) _hide($ArrayBuffer, key, BaseBuffer[key]);
                    }

                    ArrayBufferProto.constructor = $ArrayBuffer;
                } // iOS Safari 7.x bug


                var view = new $DataView(new $ArrayBuffer(2));
                var $setInt8 = $DataView[PROTOTYPE].setInt8;
                view.setInt8(0, 2147483648);
                view.setInt8(1, 2147483649);
                if (view.getInt8(0) || !view.getInt8(1)) _redefineAll($DataView[PROTOTYPE], {
                    setInt8: function setInt8(byteOffset, value) {
                        $setInt8.call(this, byteOffset, value << 24 >> 24);
                    },
                    setUint8: function setUint8(byteOffset, value) {
                        $setInt8.call(this, byteOffset, value << 24 >> 24);
                    }
                }, true);
            }

            _setToStringTag($ArrayBuffer, ARRAY_BUFFER);
            _setToStringTag($DataView, DATA_VIEW);
            _hide($DataView[PROTOTYPE], _typed.VIEW, true);
            exports[ARRAY_BUFFER] = $ArrayBuffer;
            exports[DATA_VIEW] = $DataView;
        });

        var ArrayBuffer = _global.ArrayBuffer;



        var $ArrayBuffer = _typedBuffer.ArrayBuffer;
        var $DataView = _typedBuffer.DataView;
        var $isView = _typed.ABV && ArrayBuffer.isView;
        var $slice = $ArrayBuffer.prototype.slice;
        var VIEW$1 = _typed.VIEW;
        var ARRAY_BUFFER = 'ArrayBuffer';
        _export(_export.G + _export.W + _export.F * (ArrayBuffer !== $ArrayBuffer), {
            ArrayBuffer: $ArrayBuffer
        });
        _export(_export.S + _export.F * !_typed.CONSTR, ARRAY_BUFFER, {
            // 24.1.3.1 ArrayBuffer.isView(arg)
            isView: function isView(it) {
                return $isView && $isView(it) || _isObject(it) && VIEW$1 in it;
            }
        });
        _export(_export.P + _export.U + _export.F * _fails(function () {
            return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
        }), ARRAY_BUFFER, {
            // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
            slice: function slice(start, end) {
                if ($slice !== undefined && end === undefined) return $slice.call(_anObject(this), start); // FF fix

                var len = _anObject(this).byteLength;
                var first = _toAbsoluteIndex(start, len);
                var fin = _toAbsoluteIndex(end === undefined ? len : end, len);
                var result = new (_speciesConstructor(this, $ArrayBuffer))(_toLength(fin - first));
                var viewS = new $DataView(this);
                var viewT = new $DataView(result);
                var index = 0;

                while (first < fin) {
                    viewT.setUint8(index++, viewS.getUint8(first++));
                }

                return result;
            }
        });

        _setSpecies(ARRAY_BUFFER);

        _export(_export.G + _export.W + _export.F * !_typed.ABV, {
            DataView: _typedBuffer.DataView
        });

        var _typedArray = createCommonjsModule(function (module) {

            if (_descriptors) {

                var global = _global;

                var fails = _fails;

                var $export = _export;

                var $typed = _typed;

                var $buffer = _typedBuffer;

                var ctx = _ctx;

                var anInstance = _anInstance;

                var propertyDesc = _propertyDesc;

                var hide = _hide;

                var redefineAll = _redefineAll;

                var toInteger = _toInteger;

                var toLength = _toLength;

                var toIndex = _toIndex;

                var toAbsoluteIndex = _toAbsoluteIndex;

                var toPrimitive = _toPrimitive;

                var has = _has;

                var classof = _classof;

                var isObject = _isObject;

                var toObject = _toObject;

                var isArrayIter = _isArrayIter;

                var create = _objectCreate;

                var getPrototypeOf = _objectGpo;

                var gOPN = _objectGopn.f;

                var getIterFn = core_getIteratorMethod;

                var uid = _uid;

                var wks = _wks;

                var createArrayMethod = _arrayMethods;

                var createArrayIncludes = _arrayIncludes;

                var speciesConstructor = _speciesConstructor;

                var ArrayIterators = es6_array_iterator;

                var Iterators = _iterators;

                var $iterDetect = _iterDetect;

                var setSpecies = _setSpecies;

                var arrayFill = _arrayFill;

                var arrayCopyWithin = _arrayCopyWithin;

                var $DP = _objectDp;

                var $GOPD = _objectGopd;

                var dP = $DP.f;
                var gOPD = $GOPD.f;
                var RangeError = global.RangeError;
                var TypeError = global.TypeError;
                var Uint8Array = global.Uint8Array;
                var ARRAY_BUFFER = 'ArrayBuffer';
                var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
                var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
                var PROTOTYPE = 'prototype';
                var ArrayProto = Array[PROTOTYPE];
                var $ArrayBuffer = $buffer.ArrayBuffer;
                var $DataView = $buffer.DataView;
                var arrayForEach = createArrayMethod(0);
                var arrayFilter = createArrayMethod(2);
                var arraySome = createArrayMethod(3);
                var arrayEvery = createArrayMethod(4);
                var arrayFind = createArrayMethod(5);
                var arrayFindIndex = createArrayMethod(6);
                var arrayIncludes = createArrayIncludes(true);
                var arrayIndexOf = createArrayIncludes(false);
                var arrayValues = ArrayIterators.values;
                var arrayKeys = ArrayIterators.keys;
                var arrayEntries = ArrayIterators.entries;
                var arrayLastIndexOf = ArrayProto.lastIndexOf;
                var arrayReduce = ArrayProto.reduce;
                var arrayReduceRight = ArrayProto.reduceRight;
                var arrayJoin = ArrayProto.join;
                var arraySort = ArrayProto.sort;
                var arraySlice = ArrayProto.slice;
                var arrayToString = ArrayProto.toString;
                var arrayToLocaleString = ArrayProto.toLocaleString;
                var ITERATOR = wks('iterator');
                var TAG = wks('toStringTag');
                var TYPED_CONSTRUCTOR = uid('typed_constructor');
                var DEF_CONSTRUCTOR = uid('def_constructor');
                var ALL_CONSTRUCTORS = $typed.CONSTR;
                var TYPED_ARRAY = $typed.TYPED;
                var VIEW = $typed.VIEW;
                var WRONG_LENGTH = 'Wrong length!';
                var $map = createArrayMethod(1, function (O, length) {
                    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
                });
                var LITTLE_ENDIAN = fails(function () {
                    // eslint-disable-next-line no-undef
                    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
                });
                var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
                    new Uint8Array(1).set({});
                });

                var toOffset = function toOffset(it, BYTES) {
                    var offset = toInteger(it);
                    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
                    return offset;
                };

                var validate = function validate(it) {
                    if (isObject(it) && TYPED_ARRAY in it) return it;
                    throw TypeError(it + ' is not a typed array!');
                };

                var allocate = function allocate(C, length) {
                    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
                        throw TypeError('It is not a typed array constructor!');
                    }

                    return new C(length);
                };

                var speciesFromList = function speciesFromList(O, list) {
                    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
                };

                var fromList = function fromList(C, list) {
                    var index = 0;
                    var length = list.length;
                    var result = allocate(C, length);

                    while (length > index) {
                        result[index] = list[index++];
                    }

                    return result;
                };

                var addGetter = function addGetter(it, key, internal) {
                    dP(it, key, {
                        get: function get() {
                            return this._d[internal];
                        }
                    });
                };

                var $from = function from(source
                                          /* , mapfn, thisArg */
                ) {
                    var O = toObject(source);
                    var aLen = arguments.length;
                    var mapfn = aLen > 1 ? arguments[1] : undefined;
                    var mapping = mapfn !== undefined;
                    var iterFn = getIterFn(O);
                    var i, length, values, result, step, iterator;

                    if (iterFn != undefined && !isArrayIter(iterFn)) {
                        for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
                            values.push(step.value);
                        }

                        O = values;
                    }

                    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);

                    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
                        result[i] = mapping ? mapfn(O[i], i) : O[i];
                    }

                    return result;
                };

                var $of = function of()
                    /* ...items */
                {
                    var index = 0;
                    var length = arguments.length;
                    var result = allocate(this, length);

                    while (length > index) {
                        result[index] = arguments[index++];
                    }

                    return result;
                }; // iOS Safari 6.x fails here


                var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
                    arrayToLocaleString.call(new Uint8Array(1));
                });

                var $toLocaleString = function toLocaleString() {
                    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
                };

                var proto = {
                    copyWithin: function copyWithin(target, start
                                                    /* , end */
                    ) {
                        return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
                    },
                    every: function every(callbackfn
                                          /* , thisArg */
                    ) {
                        return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
                    },
                    fill: function fill(value
                                        /* , start, end */
                    ) {
                        // eslint-disable-line no-unused-vars
                        return arrayFill.apply(validate(this), arguments);
                    },
                    filter: function filter(callbackfn
                                            /* , thisArg */
                    ) {
                        return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
                    },
                    find: function find(predicate
                                        /* , thisArg */
                    ) {
                        return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
                    },
                    findIndex: function findIndex(predicate
                                                  /* , thisArg */
                    ) {
                        return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
                    },
                    forEach: function forEach(callbackfn
                                              /* , thisArg */
                    ) {
                        arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
                    },
                    indexOf: function indexOf(searchElement
                                              /* , fromIndex */
                    ) {
                        return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
                    },
                    includes: function includes(searchElement
                                                /* , fromIndex */
                    ) {
                        return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
                    },
                    join: function join(separator) {
                        // eslint-disable-line no-unused-vars
                        return arrayJoin.apply(validate(this), arguments);
                    },
                    lastIndexOf: function lastIndexOf(searchElement
                                                      /* , fromIndex */
                    ) {
                        // eslint-disable-line no-unused-vars
                        return arrayLastIndexOf.apply(validate(this), arguments);
                    },
                    map: function map(mapfn
                                      /* , thisArg */
                    ) {
                        return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
                    },
                    reduce: function reduce(callbackfn
                                            /* , initialValue */
                    ) {
                        // eslint-disable-line no-unused-vars
                        return arrayReduce.apply(validate(this), arguments);
                    },
                    reduceRight: function reduceRight(callbackfn
                                                      /* , initialValue */
                    ) {
                        // eslint-disable-line no-unused-vars
                        return arrayReduceRight.apply(validate(this), arguments);
                    },
                    reverse: function reverse() {
                        var that = this;
                        var length = validate(that).length;
                        var middle = Math.floor(length / 2);
                        var index = 0;
                        var value;

                        while (index < middle) {
                            value = that[index];
                            that[index++] = that[--length];
                            that[length] = value;
                        }

                        return that;
                    },
                    some: function some(callbackfn
                                        /* , thisArg */
                    ) {
                        return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
                    },
                    sort: function sort(comparefn) {
                        return arraySort.call(validate(this), comparefn);
                    },
                    subarray: function subarray(begin, end) {
                        var O = validate(this);
                        var length = O.length;
                        var $begin = toAbsoluteIndex(begin, length);
                        return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
                    }
                };

                var $slice = function slice(start, end) {
                    return speciesFromList(this, arraySlice.call(validate(this), start, end));
                };

                var $set = function set(arrayLike
                                        /* , offset */
                ) {
                    validate(this);
                    var offset = toOffset(arguments[1], 1);
                    var length = this.length;
                    var src = toObject(arrayLike);
                    var len = toLength(src.length);
                    var index = 0;
                    if (len + offset > length) throw RangeError(WRONG_LENGTH);

                    while (index < len) {
                        this[offset + index] = src[index++];
                    }
                };

                var $iterators = {
                    entries: function entries() {
                        return arrayEntries.call(validate(this));
                    },
                    keys: function keys() {
                        return arrayKeys.call(validate(this));
                    },
                    values: function values() {
                        return arrayValues.call(validate(this));
                    }
                };

                var isTAIndex = function isTAIndex(target, key) {
                    return isObject(target) && target[TYPED_ARRAY] && babelHelpers.typeof(key) != 'symbol' && key in target && String(+key) == String(key);
                };

                var $getDesc = function getOwnPropertyDescriptor(target, key) {
                    return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
                };

                var $setDesc = function defineProperty(target, key, desc) {
                    if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors
                        && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
                        target[key] = desc.value;
                        return target;
                    }

                    return dP(target, key, desc);
                };

                if (!ALL_CONSTRUCTORS) {
                    $GOPD.f = $getDesc;
                    $DP.f = $setDesc;
                }

                $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
                    getOwnPropertyDescriptor: $getDesc,
                    defineProperty: $setDesc
                });

                if (fails(function () {
                    arrayToString.call({});
                })) {
                    arrayToString = arrayToLocaleString = function toString() {
                        return arrayJoin.call(this);
                    };
                }

                var $TypedArrayPrototype$ = redefineAll({}, proto);
                redefineAll($TypedArrayPrototype$, $iterators);
                hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
                redefineAll($TypedArrayPrototype$, {
                    slice: $slice,
                    set: $set,
                    constructor: function constructor() {
                        /* noop */
                    },
                    toString: arrayToString,
                    toLocaleString: $toLocaleString
                });
                addGetter($TypedArrayPrototype$, 'buffer', 'b');
                addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
                addGetter($TypedArrayPrototype$, 'byteLength', 'l');
                addGetter($TypedArrayPrototype$, 'length', 'e');
                dP($TypedArrayPrototype$, TAG, {
                    get: function get() {
                        return this[TYPED_ARRAY];
                    }
                }); // eslint-disable-next-line max-statements

                module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
                    CLAMPED = !!CLAMPED;
                    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
                    var GETTER = 'get' + KEY;
                    var SETTER = 'set' + KEY;
                    var TypedArray = global[NAME];
                    var Base = TypedArray || {};
                    var TAC = TypedArray && getPrototypeOf(TypedArray);
                    var FORCED = !TypedArray || !$typed.ABV;
                    var O = {};
                    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];

                    var getter = function getter(that, index) {
                        var data = that._d;
                        return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
                    };

                    var setter = function setter(that, index, value) {
                        var data = that._d;
                        if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
                        data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
                    };

                    var addElement = function addElement(that, index) {
                        dP(that, index, {
                            get: function get() {
                                return getter(this, index);
                            },
                            set: function set(value) {
                                return setter(this, index, value);
                            },
                            enumerable: true
                        });
                    };

                    if (FORCED) {
                        TypedArray = wrapper(function (that, data, $offset, $length) {
                            anInstance(that, TypedArray, NAME, '_d');
                            var index = 0;
                            var offset = 0;
                            var buffer, byteLength, length, klass;

                            if (!isObject(data)) {
                                length = toIndex(data);
                                byteLength = length * BYTES;
                                buffer = new $ArrayBuffer(byteLength);
                            } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
                                buffer = data;
                                offset = toOffset($offset, BYTES);
                                var $len = data.byteLength;

                                if ($length === undefined) {
                                    if ($len % BYTES) throw RangeError(WRONG_LENGTH);
                                    byteLength = $len - offset;
                                    if (byteLength < 0) throw RangeError(WRONG_LENGTH);
                                } else {
                                    byteLength = toLength($length) * BYTES;
                                    if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
                                }

                                length = byteLength / BYTES;
                            } else if (TYPED_ARRAY in data) {
                                return fromList(TypedArray, data);
                            } else {
                                return $from.call(TypedArray, data);
                            }

                            hide(that, '_d', {
                                b: buffer,
                                o: offset,
                                l: byteLength,
                                e: length,
                                v: new $DataView(buffer)
                            });

                            while (index < length) {
                                addElement(that, index++);
                            }
                        });
                        TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
                        hide(TypedArrayPrototype, 'constructor', TypedArray);
                    } else if (!fails(function () {
                        TypedArray(1);
                    }) || !fails(function () {
                        new TypedArray(-1); // eslint-disable-line no-new
                    }) || !$iterDetect(function (iter) {
                        new TypedArray(); // eslint-disable-line no-new

                        new TypedArray(null); // eslint-disable-line no-new

                        new TypedArray(1.5); // eslint-disable-line no-new

                        new TypedArray(iter); // eslint-disable-line no-new
                    }, true)) {
                        TypedArray = wrapper(function (that, data, $offset, $length) {
                            anInstance(that, TypedArray, NAME);
                            var klass; // `ws` module bug, temporarily remove validation length for Uint8Array
                            // https://github.com/websockets/ws/pull/645

                            if (!isObject(data)) return new Base(toIndex(data));

                            if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
                                return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
                            }

                            if (TYPED_ARRAY in data) return fromList(TypedArray, data);
                            return $from.call(TypedArray, data);
                        });
                        arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
                            if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
                        });
                        TypedArray[PROTOTYPE] = TypedArrayPrototype;
                        TypedArrayPrototype.constructor = TypedArray;
                    }

                    var $nativeIterator = TypedArrayPrototype[ITERATOR];
                    var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
                    var $iterator = $iterators.values;
                    hide(TypedArray, TYPED_CONSTRUCTOR, true);
                    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
                    hide(TypedArrayPrototype, VIEW, true);
                    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

                    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
                        dP(TypedArrayPrototype, TAG, {
                            get: function get() {
                                return NAME;
                            }
                        });
                    }

                    O[NAME] = TypedArray;
                    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
                    $export($export.S, NAME, {
                        BYTES_PER_ELEMENT: BYTES
                    });
                    $export($export.S + $export.F * fails(function () {
                        Base.of.call(TypedArray, 1);
                    }), NAME, {
                        from: $from,
                        of: $of
                    });
                    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
                    $export($export.P, NAME, proto);
                    setSpecies(NAME);
                    $export($export.P + $export.F * FORCED_SET, NAME, {
                        set: $set
                    });
                    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
                    if (TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
                    $export($export.P + $export.F * fails(function () {
                        new TypedArray(1).slice();
                    }), NAME, {
                        slice: $slice
                    });
                    $export($export.P + $export.F * (fails(function () {
                        return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
                    }) || !fails(function () {
                        TypedArrayPrototype.toLocaleString.call([1, 2]);
                    })), NAME, {
                        toLocaleString: $toLocaleString
                    });
                    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
                    if (!CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
                };
            } else module.exports = function () {
                /* empty */
            };
        });

        _typedArray('Int8', 1, function (init) {
            return function Int8Array(data, byteOffset, length) {
                return init(this, data, byteOffset, length);
            };
        });

        _typedArray('Uint8', 1, function (init) {
            return function Uint8Array(data, byteOffset, length) {
                return init(this, data, byteOffset, length);
            };
        });

        _typedArray('Uint8', 1, function (init) {
            return function Uint8ClampedArray(data, byteOffset, length) {
                return init(this, data, byteOffset, length);
            };
        }, true);

        _typedArray('Int16', 2, function (init) {
            return function Int16Array(data, byteOffset, length) {
                return init(this, data, byteOffset, length);
            };
        });

        _typedArray('Uint16', 2, function (init) {
            return function Uint16Array(data, byteOffset, length) {
                return init(this, data, byteOffset, length);
            };
        });

        _typedArray('Int32', 4, function (init) {
            return function Int32Array(data, byteOffset, length) {
                return init(this, data, byteOffset, length);
            };
        });

        _typedArray('Uint32', 4, function (init) {
            return function Uint32Array(data, byteOffset, length) {
                return init(this, data, byteOffset, length);
            };
        });

        _typedArray('Float32', 4, function (init) {
            return function Float32Array(data, byteOffset, length) {
                return init(this, data, byteOffset, length);
            };
        });

        _typedArray('Float64', 8, function (init) {
            return function Float64Array(data, byteOffset, length) {
                return init(this, data, byteOffset, length);
            };
        });

        // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)






        var rApply = (_global.Reflect || {}).apply;
        var fApply = Function.apply; // MS Edge argumentsList argument is optional

        _export(_export.S + _export.F * !_fails(function () {
            rApply(function () {
                /* empty */
            });
        }), 'Reflect', {
            apply: function apply(target, thisArgument, argumentsList) {
                var T = _aFunction(target);
                var L = _anObject(argumentsList);
                return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
            }
        });

        // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])














        var rConstruct = (_global.Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional
        // FF Nightly sets third argument as `new.target`, but does not create `this` from it

        var NEW_TARGET_BUG = _fails(function () {
            function F() {
                /* empty */
            }

            return !(rConstruct(function () {
                /* empty */
            }, [], F) instanceof F);
        });
        var ARGS_BUG = !_fails(function () {
            rConstruct(function () {
                /* empty */
            });
        });
        _export(_export.S + _export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
            construct: function construct(Target, args
                                          /* , newTarget */
            ) {
                _aFunction(Target);
                _anObject(args);
                var newTarget = arguments.length < 3 ? Target : _aFunction(arguments[2]);
                if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);

                if (Target == newTarget) {
                    // w/o altered newTarget, optimization for 0-4 arguments
                    switch (args.length) {
                        case 0:
                            return new Target();

                        case 1:
                            return new Target(args[0]);

                        case 2:
                            return new Target(args[0], args[1]);

                        case 3:
                            return new Target(args[0], args[1], args[2]);

                        case 4:
                            return new Target(args[0], args[1], args[2], args[3]);
                    } // w/o altered newTarget, lot of arguments case


                    var $args = [null];
                    $args.push.apply($args, args);
                    return new (_bind.apply(Target, $args))();
                } // with altered newTarget, not support built-in constructors


                var proto = newTarget.prototype;
                var instance = _objectCreate(_isObject(proto) ? proto : Object.prototype);
                var result = Function.apply.call(Target, instance, args);
                return _isObject(result) ? result : instance;
            }
        });

        // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)






        // MS Edge has broken Reflect.defineProperty - throwing instead of returning false


        _export(_export.S + _export.F * _fails(function () {
            // eslint-disable-next-line no-undef
            Reflect.defineProperty(_objectDp.f({}, 1, {
                value: 1
            }), 1, {
                value: 2
            });
        }), 'Reflect', {
            defineProperty: function defineProperty(target, propertyKey, attributes) {
                _anObject(target);
                propertyKey = _toPrimitive(propertyKey, true);
                _anObject(attributes);

                try {
                    _objectDp.f(target, propertyKey, attributes);
                    return true;
                } catch (e) {
                    return false;
                }
            }
        });

        // 26.1.4 Reflect.deleteProperty(target, propertyKey)


        var gOPD$3 = _objectGopd.f;



        _export(_export.S, 'Reflect', {
            deleteProperty: function deleteProperty(target, propertyKey) {
                var desc = gOPD$3(_anObject(target), propertyKey);
                return desc && !desc.configurable ? false : delete target[propertyKey];
            }
        });

        var Enumerate = function Enumerate(iterated) {
            this._t = _anObject(iterated); // target

            this._i = 0; // next index

            var keys = this._k = []; // keys

            var key;

            for (key in iterated) {
                keys.push(key);
            }
        };

        _iterCreate(Enumerate, 'Object', function () {
            var that = this;
            var keys = that._k;
            var key;

            do {
                if (that._i >= keys.length) return {
                    value: undefined,
                    done: true
                };
            } while (!((key = keys[that._i++]) in that._t));

            return {
                value: key,
                done: false
            };
        });

        _export(_export.S, 'Reflect', {
            enumerate: function enumerate(target) {
                return new Enumerate(target);
            }
        });

        // 26.1.6 Reflect.get(target, propertyKey [, receiver])












        function get(target, propertyKey
                     /* , receiver */
        ) {
            var receiver = arguments.length < 3 ? target : arguments[2];
            var desc, proto;
            if (_anObject(target) === receiver) return target[propertyKey];
            if (desc = _objectGopd.f(target, propertyKey)) return _has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
            if (_isObject(proto = _objectGpo(target))) return get(proto, propertyKey, receiver);
        }

        _export(_export.S, 'Reflect', {
            get: get
        });

        // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)






        _export(_export.S, 'Reflect', {
            getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
                return _objectGopd.f(_anObject(target), propertyKey);
            }
        });

        // 26.1.8 Reflect.getPrototypeOf(target)






        _export(_export.S, 'Reflect', {
            getPrototypeOf: function getPrototypeOf(target) {
                return _objectGpo(_anObject(target));
            }
        });

        // 26.1.9 Reflect.has(target, propertyKey)


        _export(_export.S, 'Reflect', {
            has: function has(target, propertyKey) {
                return propertyKey in target;
            }
        });

        // 26.1.10 Reflect.isExtensible(target)




        var $isExtensible = Object.isExtensible;
        _export(_export.S, 'Reflect', {
            isExtensible: function isExtensible(target) {
                _anObject(target);
                return $isExtensible ? $isExtensible(target) : true;
            }
        });

        // all object keys, includes non-enumerable and symbols






        var Reflect$1 = _global.Reflect;

        var _ownKeys = Reflect$1 && Reflect$1.ownKeys || function ownKeys(it) {
            var keys = _objectGopn.f(_anObject(it));
            var getSymbols = _objectGops.f;
            return getSymbols ? keys.concat(getSymbols(it)) : keys;
        };

        // 26.1.11 Reflect.ownKeys(target)


        _export(_export.S, 'Reflect', {
            ownKeys: _ownKeys
        });

        // 26.1.12 Reflect.preventExtensions(target)




        var $preventExtensions = Object.preventExtensions;
        _export(_export.S, 'Reflect', {
            preventExtensions: function preventExtensions(target) {
                _anObject(target);

                try {
                    if ($preventExtensions) $preventExtensions(target);
                    return true;
                } catch (e) {
                    return false;
                }
            }
        });

        // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
















        function set(target, propertyKey, V
                     /* , receiver */
        ) {
            var receiver = arguments.length < 4 ? target : arguments[3];
            var ownDesc = _objectGopd.f(_anObject(target), propertyKey);
            var existingDescriptor, proto;

            if (!ownDesc) {
                if (_isObject(proto = _objectGpo(target))) {
                    return set(proto, propertyKey, V, receiver);
                }

                ownDesc = _propertyDesc(0);
            }

            if (_has(ownDesc, 'value')) {
                if (ownDesc.writable === false || !_isObject(receiver)) return false;

                if (existingDescriptor = _objectGopd.f(receiver, propertyKey)) {
                    if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
                    existingDescriptor.value = V;
                    _objectDp.f(receiver, propertyKey, existingDescriptor);
                } else _objectDp.f(receiver, propertyKey, _propertyDesc(0, V));

                return true;
            }

            return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
        }

        _export(_export.S, 'Reflect', {
            set: set
        });

        // 26.1.14 Reflect.setPrototypeOf(target, proto)




        if (_setProto) _export(_export.S, 'Reflect', {
            setPrototypeOf: function setPrototypeOf(target, proto) {
                _setProto.check(target, proto);

                try {
                    _setProto.set(target, proto);
                    return true;
                } catch (e) {
                    return false;
                }
            }
        });

        var $includes = _arrayIncludes(true);

        _export(_export.P, 'Array', {
            includes: function includes(el
                                        /* , fromIndex = 0 */
            ) {
                return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
            }
        });

        _addToUnscopables('includes');

        var IS_CONCAT_SPREADABLE = _wks('isConcatSpreadable');

        function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
            var targetIndex = start;
            var sourceIndex = 0;
            var mapFn = mapper ? _ctx(mapper, thisArg, 3) : false;
            var element, spreadable;

            while (sourceIndex < sourceLen) {
                if (sourceIndex in source) {
                    element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
                    spreadable = false;

                    if (_isObject(element)) {
                        spreadable = element[IS_CONCAT_SPREADABLE];
                        spreadable = spreadable !== undefined ? !!spreadable : _isArray(element);
                    }

                    if (spreadable && depth > 0) {
                        targetIndex = flattenIntoArray(target, original, element, _toLength(element.length), targetIndex, depth - 1) - 1;
                    } else {
                        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
                        target[targetIndex] = element;
                    }

                    targetIndex++;
                }

                sourceIndex++;
            }

            return targetIndex;
        }

        var _flattenIntoArray = flattenIntoArray;

        _export(_export.P, 'Array', {
            flatMap: function flatMap(callbackfn
                                      /* , thisArg */
            ) {
                var O = _toObject(this);
                var sourceLen, A;
                _aFunction(callbackfn);
                sourceLen = _toLength(O.length);
                A = _arraySpeciesCreate(O, 0);
                _flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
                return A;
            }
        });

        _addToUnscopables('flatMap');

        _export(_export.P, 'Array', {
            flatten: function flatten()
                /* depthArg = 1 */
            {
                var depthArg = arguments[0];
                var O = _toObject(this);
                var sourceLen = _toLength(O.length);
                var A = _arraySpeciesCreate(O, 0);
                _flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : _toInteger(depthArg));
                return A;
            }
        });

        _addToUnscopables('flatten');

        var $at$2 = _stringAt(true);

        _export(_export.P, 'String', {
            at: function at(pos) {
                return $at$2(this, pos);
            }
        });

        // https://github.com/tc39/proposal-string-pad-start-end






        var _stringPad = function (that, maxLength, fillString, left) {
            var S = String(_defined(that));
            var stringLength = S.length;
            var fillStr = fillString === undefined ? ' ' : String(fillString);
            var intMaxLength = _toLength(maxLength);
            if (intMaxLength <= stringLength || fillStr == '') return S;
            var fillLen = intMaxLength - stringLength;
            var stringFiller = _stringRepeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
            if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
            return left ? stringFiller + S : S + stringFiller;
        };

        // https://github.com/zloirock/core-js/issues/280


        _export(_export.P + _export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(_userAgent), 'String', {
            padStart: function padStart(maxLength
                                        /* , fillString = ' ' */
            ) {
                return _stringPad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
            }
        });

        // https://github.com/zloirock/core-js/issues/280


        _export(_export.P + _export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(_userAgent), 'String', {
            padEnd: function padEnd(maxLength
                                    /* , fillString = ' ' */
            ) {
                return _stringPad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
            }
        });

        _stringTrim('trimLeft', function ($trim) {
            return function trimLeft() {
                return $trim(this, 1);
            };
        }, 'trimStart');

        _stringTrim('trimRight', function ($trim) {
            return function trimRight() {
                return $trim(this, 2);
            };
        }, 'trimEnd');

        var RegExpProto = RegExp.prototype;

        var $RegExpStringIterator = function $RegExpStringIterator(regexp, string) {
            this._r = regexp;
            this._s = string;
        };

        _iterCreate($RegExpStringIterator, 'RegExp String', function next() {
            var match = this._r.exec(this._s);

            return {
                value: match,
                done: match === null
            };
        });

        _export(_export.P, 'String', {
            matchAll: function matchAll(regexp) {
                _defined(this);
                if (!_isRegexp(regexp)) throw TypeError(regexp + ' is not a regexp!');
                var S = String(this);
                var flags = 'flags' in RegExpProto ? String(regexp.flags) : _flags.call(regexp);
                var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
                rx.lastIndex = _toLength(regexp.lastIndex);
                return new $RegExpStringIterator(rx, S);
            }
        });

        _wksDefine('asyncIterator');

        _wksDefine('observable');

        // https://github.com/tc39/proposal-object-getownpropertydescriptors










        _export(_export.S, 'Object', {
            getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
                var O = _toIobject(object);
                var getDesc = _objectGopd.f;
                var keys = _ownKeys(O);
                var result = {};
                var i = 0;
                var key, desc;

                while (keys.length > i) {
                    desc = getDesc(O, key = keys[i++]);
                    if (desc !== undefined) _createProperty(result, key, desc);
                }

                return result;
            }
        });

        var isEnum$1 = _objectPie.f;

        var _objectToArray = function (isEntries) {
            return function (it) {
                var O = _toIobject(it);
                var keys = _objectKeys(O);
                var length = keys.length;
                var i = 0;
                var result = [];
                var key;

                while (length > i) {
                    if (isEnum$1.call(O, key = keys[i++])) {
                        result.push(isEntries ? [key, O[key]] : O[key]);
                    }
                }

                return result;
            };
        };

        // https://github.com/tc39/proposal-object-values-entries


        var $values = _objectToArray(false);

        _export(_export.S, 'Object', {
            values: function values(it) {
                return $values(it);
            }
        });

        // https://github.com/tc39/proposal-object-values-entries


        var $entries = _objectToArray(true);

        _export(_export.S, 'Object', {
            entries: function entries(it) {
                return $entries(it);
            }
        });

        var _objectForcedPam = !_fails(function () {
            var K = Math.random(); // In FF throws only define methods
            // eslint-disable-next-line no-undef, no-useless-call

            __defineSetter__.call(null, K, function () {
                /* empty */
            });

            delete _global[K];
        });

        // B.2.2.2 Object.prototype.__defineGetter__(P, getter)


        _descriptors && _export(_export.P + _objectForcedPam, 'Object', {
            __defineGetter__: function __defineGetter__(P, getter) {
                _objectDp.f(_toObject(this), P, {
                    get: _aFunction(getter),
                    enumerable: true,
                    configurable: true
                });
            }
        });

        // B.2.2.3 Object.prototype.__defineSetter__(P, setter)


        _descriptors && _export(_export.P + _objectForcedPam, 'Object', {
            __defineSetter__: function __defineSetter__(P, setter) {
                _objectDp.f(_toObject(this), P, {
                    set: _aFunction(setter),
                    enumerable: true,
                    configurable: true
                });
            }
        });

        var getOwnPropertyDescriptor = _objectGopd.f; // B.2.2.4 Object.prototype.__lookupGetter__(P)


        _descriptors && _export(_export.P + _objectForcedPam, 'Object', {
            __lookupGetter__: function __lookupGetter__(P) {
                var O = _toObject(this);
                var K = _toPrimitive(P, true);
                var D;

                do {
                    if (D = getOwnPropertyDescriptor(O, K)) return D.get;
                } while (O = _objectGpo(O));
            }
        });

        var getOwnPropertyDescriptor$1 = _objectGopd.f; // B.2.2.5 Object.prototype.__lookupSetter__(P)


        _descriptors && _export(_export.P + _objectForcedPam, 'Object', {
            __lookupSetter__: function __lookupSetter__(P) {
                var O = _toObject(this);
                var K = _toPrimitive(P, true);
                var D;

                do {
                    if (D = getOwnPropertyDescriptor$1(O, K)) return D.set;
                } while (O = _objectGpo(O));
            }
        });

        var _arrayFromIterable = function (iter, ITERATOR) {
            var result = [];
            _forOf(iter, false, result.push, result, ITERATOR);
            return result;
        };

        // https://github.com/DavidBruant/Map-Set.prototype.toJSON




        var _collectionToJson = function (NAME) {
            return function toJSON() {
                if (_classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
                return _arrayFromIterable(this);
            };
        };

        // https://github.com/DavidBruant/Map-Set.prototype.toJSON


        _export(_export.P + _export.R, 'Map', {
            toJSON: _collectionToJson('Map')
        });

        // https://github.com/DavidBruant/Map-Set.prototype.toJSON


        _export(_export.P + _export.R, 'Set', {
            toJSON: _collectionToJson('Set')
        });

        var _setCollectionOf = function (COLLECTION) {
            _export(_export.S, COLLECTION, {
                of: function of() {
                    var length = arguments.length;
                    var A = new Array(length);

                    while (length--) {
                        A[length] = arguments[length];
                    }

                    return new this(A);
                }
            });
        };

        // https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
        _setCollectionOf('Map');

        // https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
        _setCollectionOf('Set');

        // https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
        _setCollectionOf('WeakMap');

        // https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
        _setCollectionOf('WeakSet');

        var _setCollectionFrom = function (COLLECTION) {
            _export(_export.S, COLLECTION, {
                from: function from(source
                                    /* , mapFn, thisArg */
                ) {
                    var mapFn = arguments[1];
                    var mapping, A, n, cb;
                    _aFunction(this);
                    mapping = mapFn !== undefined;
                    if (mapping) _aFunction(mapFn);
                    if (source == undefined) return new this();
                    A = [];

                    if (mapping) {
                        n = 0;
                        cb = _ctx(mapFn, arguments[2], 2);
                        _forOf(source, false, function (nextItem) {
                            A.push(cb(nextItem, n++));
                        });
                    } else {
                        _forOf(source, false, A.push, A);
                    }

                    return new this(A);
                }
            });
        };

        // https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
        _setCollectionFrom('Map');

        // https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
        _setCollectionFrom('Set');

        // https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
        _setCollectionFrom('WeakMap');

        // https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
        _setCollectionFrom('WeakSet');

        // https://github.com/tc39/proposal-global


        _export(_export.G, {
            global: _global
        });

        // https://github.com/tc39/proposal-global


        _export(_export.S, 'System', {
            global: _global
        });

        // https://github.com/ljharb/proposal-is-error




        _export(_export.S, 'Error', {
            isError: function isError(it) {
                return _cof(it) === 'Error';
            }
        });

        // https://rwaldron.github.io/proposal-math-extensions/


        _export(_export.S, 'Math', {
            clamp: function clamp(x, lower, upper) {
                return Math.min(upper, Math.max(lower, x));
            }
        });

        // https://rwaldron.github.io/proposal-math-extensions/


        _export(_export.S, 'Math', {
            DEG_PER_RAD: Math.PI / 180
        });

        // https://rwaldron.github.io/proposal-math-extensions/


        var RAD_PER_DEG = 180 / Math.PI;
        _export(_export.S, 'Math', {
            degrees: function degrees(radians) {
                return radians * RAD_PER_DEG;
            }
        });

        // https://rwaldron.github.io/proposal-math-extensions/
        var _mathScale = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
            if (arguments.length === 0 // eslint-disable-next-line no-self-compare
                || x != x // eslint-disable-next-line no-self-compare
                || inLow != inLow // eslint-disable-next-line no-self-compare
                || inHigh != inHigh // eslint-disable-next-line no-self-compare
                || outLow != outLow // eslint-disable-next-line no-self-compare
                || outHigh != outHigh) return NaN;
            if (x === Infinity || x === -Infinity) return x;
            return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
        };

        // https://rwaldron.github.io/proposal-math-extensions/






        _export(_export.S, 'Math', {
            fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
                return _mathFround(_mathScale(x, inLow, inHigh, outLow, outHigh));
            }
        });

        // https://gist.github.com/BrendanEich/4294d5c212a6d2254703


        _export(_export.S, 'Math', {
            iaddh: function iaddh(x0, x1, y0, y1) {
                var $x0 = x0 >>> 0;
                var $x1 = x1 >>> 0;
                var $y0 = y0 >>> 0;
                return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
            }
        });

        // https://gist.github.com/BrendanEich/4294d5c212a6d2254703


        _export(_export.S, 'Math', {
            isubh: function isubh(x0, x1, y0, y1) {
                var $x0 = x0 >>> 0;
                var $x1 = x1 >>> 0;
                var $y0 = y0 >>> 0;
                return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
            }
        });

        // https://gist.github.com/BrendanEich/4294d5c212a6d2254703


        _export(_export.S, 'Math', {
            imulh: function imulh(u, v) {
                var UINT16 = 0xffff;
                var $u = +u;
                var $v = +v;
                var u0 = $u & UINT16;
                var v0 = $v & UINT16;
                var u1 = $u >> 16;
                var v1 = $v >> 16;
                var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
                return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
            }
        });

        // https://rwaldron.github.io/proposal-math-extensions/


        _export(_export.S, 'Math', {
            RAD_PER_DEG: 180 / Math.PI
        });

        // https://rwaldron.github.io/proposal-math-extensions/


        var DEG_PER_RAD = Math.PI / 180;
        _export(_export.S, 'Math', {
            radians: function radians(degrees) {
                return degrees * DEG_PER_RAD;
            }
        });

        // https://rwaldron.github.io/proposal-math-extensions/


        _export(_export.S, 'Math', {
            scale: _mathScale
        });

        // https://gist.github.com/BrendanEich/4294d5c212a6d2254703


        _export(_export.S, 'Math', {
            umulh: function umulh(u, v) {
                var UINT16 = 0xffff;
                var $u = +u;
                var $v = +v;
                var u0 = $u & UINT16;
                var v0 = $v & UINT16;
                var u1 = $u >>> 16;
                var v1 = $v >>> 16;
                var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
                return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
            }
        });

        // http://jfbastien.github.io/papers/Math.signbit.html


        _export(_export.S, 'Math', {
            signbit: function signbit(x) {
                // eslint-disable-next-line no-self-compare
                return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
            }
        });

        _export(_export.S, 'Promise', {
            'try': function _try(callbackfn) {
                var promiseCapability = _newPromiseCapability.f(this);
                var result = _perform(callbackfn);
                (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
                return promiseCapability.promise;
            }
        });

        var shared$1 = _shared('metadata');

        var store = shared$1.store || (shared$1.store = new (es6_weakMap)());

        var getOrCreateMetadataMap = function getOrCreateMetadataMap(target, targetKey, create) {
            var targetMetadata = store.get(target);

            if (!targetMetadata) {
                if (!create) return undefined;
                store.set(target, targetMetadata = new es6_map());
            }

            var keyMetadata = targetMetadata.get(targetKey);

            if (!keyMetadata) {
                if (!create) return undefined;
                targetMetadata.set(targetKey, keyMetadata = new es6_map());
            }

            return keyMetadata;
        };

        var ordinaryHasOwnMetadata = function ordinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = getOrCreateMetadataMap(O, P, false);
            return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
        };

        var ordinaryGetOwnMetadata = function ordinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = getOrCreateMetadataMap(O, P, false);
            return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
        };

        var ordinaryDefineOwnMetadata = function ordinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
        };

        var ordinaryOwnMetadataKeys = function ordinaryOwnMetadataKeys(target, targetKey) {
            var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
            var keys = [];
            if (metadataMap) metadataMap.forEach(function (_, key) {
                keys.push(key);
            });
            return keys;
        };

        var toMetaKey = function toMetaKey(it) {
            return it === undefined || babelHelpers.typeof(it) == 'symbol' ? it : String(it);
        };

        var exp$3 = function exp(O) {
            _export(_export.S, 'Reflect', O);
        };

        var _metadata = {
            store: store,
            map: getOrCreateMetadataMap,
            has: ordinaryHasOwnMetadata,
            get: ordinaryGetOwnMetadata,
            set: ordinaryDefineOwnMetadata,
            keys: ordinaryOwnMetadataKeys,
            key: toMetaKey,
            exp: exp$3
        };

        var toMetaKey$1 = _metadata.key;
        var ordinaryDefineOwnMetadata$1 = _metadata.set;
        _metadata.exp({
            defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
                ordinaryDefineOwnMetadata$1(metadataKey, metadataValue, _anObject(target), toMetaKey$1(targetKey));
            }
        });

        var toMetaKey$2 = _metadata.key;
        var getOrCreateMetadataMap$1 = _metadata.map;
        var store$1 = _metadata.store;
        _metadata.exp({
            deleteMetadata: function deleteMetadata(metadataKey, target
                                                    /* , targetKey */
            ) {
                var targetKey = arguments.length < 3 ? undefined : toMetaKey$2(arguments[2]);
                var metadataMap = getOrCreateMetadataMap$1(_anObject(target), targetKey, false);
                if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
                if (metadataMap.size) return true;
                var targetMetadata = store$1.get(target);
                targetMetadata['delete'](targetKey);
                return !!targetMetadata.size || store$1['delete'](target);
            }
        });

        var ordinaryHasOwnMetadata$1 = _metadata.has;
        var ordinaryGetOwnMetadata$1 = _metadata.get;
        var toMetaKey$3 = _metadata.key;

        var ordinaryGetMetadata = function ordinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = ordinaryHasOwnMetadata$1(MetadataKey, O, P);
            if (hasOwn) return ordinaryGetOwnMetadata$1(MetadataKey, O, P);
            var parent = _objectGpo(O);
            return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
        };

        _metadata.exp({
            getMetadata: function getMetadata(metadataKey, target
                                              /* , targetKey */
            ) {
                return ordinaryGetMetadata(metadataKey, _anObject(target), arguments.length < 3 ? undefined : toMetaKey$3(arguments[2]));
            }
        });

        var ordinaryOwnMetadataKeys$1 = _metadata.keys;
        var toMetaKey$4 = _metadata.key;

        var ordinaryMetadataKeys = function ordinaryMetadataKeys(O, P) {
            var oKeys = ordinaryOwnMetadataKeys$1(O, P);
            var parent = _objectGpo(O);
            if (parent === null) return oKeys;
            var pKeys = ordinaryMetadataKeys(parent, P);
            return pKeys.length ? oKeys.length ? _arrayFromIterable(new es6_set(oKeys.concat(pKeys))) : pKeys : oKeys;
        };

        _metadata.exp({
            getMetadataKeys: function getMetadataKeys(target
                                                      /* , targetKey */
            ) {
                return ordinaryMetadataKeys(_anObject(target), arguments.length < 2 ? undefined : toMetaKey$4(arguments[1]));
            }
        });

        var ordinaryGetOwnMetadata$2 = _metadata.get;
        var toMetaKey$5 = _metadata.key;
        _metadata.exp({
            getOwnMetadata: function getOwnMetadata(metadataKey, target
                                                    /* , targetKey */
            ) {
                return ordinaryGetOwnMetadata$2(metadataKey, _anObject(target), arguments.length < 3 ? undefined : toMetaKey$5(arguments[2]));
            }
        });

        var ordinaryOwnMetadataKeys$2 = _metadata.keys;
        var toMetaKey$6 = _metadata.key;
        _metadata.exp({
            getOwnMetadataKeys: function getOwnMetadataKeys(target
                                                            /* , targetKey */
            ) {
                return ordinaryOwnMetadataKeys$2(_anObject(target), arguments.length < 2 ? undefined : toMetaKey$6(arguments[1]));
            }
        });

        var ordinaryHasOwnMetadata$2 = _metadata.has;
        var toMetaKey$7 = _metadata.key;

        var ordinaryHasMetadata = function ordinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = ordinaryHasOwnMetadata$2(MetadataKey, O, P);
            if (hasOwn) return true;
            var parent = _objectGpo(O);
            return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
        };

        _metadata.exp({
            hasMetadata: function hasMetadata(metadataKey, target
                                              /* , targetKey */
            ) {
                return ordinaryHasMetadata(metadataKey, _anObject(target), arguments.length < 3 ? undefined : toMetaKey$7(arguments[2]));
            }
        });

        var ordinaryHasOwnMetadata$3 = _metadata.has;
        var toMetaKey$8 = _metadata.key;
        _metadata.exp({
            hasOwnMetadata: function hasOwnMetadata(metadataKey, target
                                                    /* , targetKey */
            ) {
                return ordinaryHasOwnMetadata$3(metadataKey, _anObject(target), arguments.length < 3 ? undefined : toMetaKey$8(arguments[2]));
            }
        });

        var toMetaKey$9 = _metadata.key;
        var ordinaryDefineOwnMetadata$2 = _metadata.set;
        _metadata.exp({
            metadata: function metadata(metadataKey, metadataValue) {
                return function decorator(target, targetKey) {
                    ordinaryDefineOwnMetadata$2(metadataKey, metadataValue, (targetKey !== undefined ? _anObject : _aFunction)(target), toMetaKey$9(targetKey));
                };
            }
        });

        // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask


        var microtask$1 = _microtask();

        var process$3 = _global.process;

        var isNode$2 = _cof(process$3) == 'process';
        _export(_export.G, {
            asap: function asap(fn) {
                var domain = isNode$2 && process$3.domain;
                microtask$1(domain ? domain.bind(fn) : fn);
            }
        });

        var microtask$2 = _microtask();

        var OBSERVABLE = _wks('observable');













        var RETURN = _forOf.RETURN;

        var getMethod = function getMethod(fn) {
            return fn == null ? undefined : _aFunction(fn);
        };

        var cleanupSubscription = function cleanupSubscription(subscription) {
            var cleanup = subscription._c;

            if (cleanup) {
                subscription._c = undefined;
                cleanup();
            }
        };

        var subscriptionClosed = function subscriptionClosed(subscription) {
            return subscription._o === undefined;
        };

        var closeSubscription = function closeSubscription(subscription) {
            if (!subscriptionClosed(subscription)) {
                subscription._o = undefined;
                cleanupSubscription(subscription);
            }
        };

        var Subscription = function Subscription(observer, subscriber) {
            _anObject(observer);
            this._c = undefined;
            this._o = observer;
            observer = new SubscriptionObserver(this);

            try {
                var cleanup = subscriber(observer);
                var subscription = cleanup;

                if (cleanup != null) {
                    if (typeof cleanup.unsubscribe === 'function') cleanup = function cleanup() {
                        subscription.unsubscribe();
                    };else _aFunction(cleanup);
                    this._c = cleanup;
                }
            } catch (e) {
                observer.error(e);
                return;
            }

            if (subscriptionClosed(this)) cleanupSubscription(this);
        };

        Subscription.prototype = _redefineAll({}, {
            unsubscribe: function unsubscribe() {
                closeSubscription(this);
            }
        });

        var SubscriptionObserver = function SubscriptionObserver(subscription) {
            this._s = subscription;
        };

        SubscriptionObserver.prototype = _redefineAll({}, {
            next: function next(value) {
                var subscription = this._s;

                if (!subscriptionClosed(subscription)) {
                    var observer = subscription._o;

                    try {
                        var m = getMethod(observer.next);
                        if (m) return m.call(observer, value);
                    } catch (e) {
                        try {
                            closeSubscription(subscription);
                        } finally {
                            throw e;
                        }
                    }
                }
            },
            error: function error(value) {
                var subscription = this._s;
                if (subscriptionClosed(subscription)) throw value;
                var observer = subscription._o;
                subscription._o = undefined;

                try {
                    var m = getMethod(observer.error);
                    if (!m) throw value;
                    value = m.call(observer, value);
                } catch (e) {
                    try {
                        cleanupSubscription(subscription);
                    } finally {
                        throw e;
                    }
                }

                cleanupSubscription(subscription);
                return value;
            },
            complete: function complete(value) {
                var subscription = this._s;

                if (!subscriptionClosed(subscription)) {
                    var observer = subscription._o;
                    subscription._o = undefined;

                    try {
                        var m = getMethod(observer.complete);
                        value = m ? m.call(observer, value) : undefined;
                    } catch (e) {
                        try {
                            cleanupSubscription(subscription);
                        } finally {
                            throw e;
                        }
                    }

                    cleanupSubscription(subscription);
                    return value;
                }
            }
        });

        var $Observable = function Observable(subscriber) {
            _anInstance(this, $Observable, 'Observable', '_f')._f = _aFunction(subscriber);
        };

        _redefineAll($Observable.prototype, {
            subscribe: function subscribe(observer) {
                return new Subscription(observer, this._f);
            },
            forEach: function forEach(fn) {
                var that = this;
                return new (_core.Promise || _global.Promise)(function (resolve, reject) {
                    _aFunction(fn);
                    var subscription = that.subscribe({
                        next: function next(value) {
                            try {
                                return fn(value);
                            } catch (e) {
                                reject(e);
                                subscription.unsubscribe();
                            }
                        },
                        error: reject,
                        complete: resolve
                    });
                });
            }
        });
        _redefineAll($Observable, {
            from: function from(x) {
                var C = typeof this === 'function' ? this : $Observable;
                var method = getMethod(_anObject(x)[OBSERVABLE]);

                if (method) {
                    var observable = _anObject(method.call(x));
                    return observable.constructor === C ? observable : new C(function (observer) {
                        return observable.subscribe(observer);
                    });
                }

                return new C(function (observer) {
                    var done = false;
                    microtask$2(function () {
                        if (!done) {
                            try {
                                if (_forOf(x, false, function (it) {
                                    observer.next(it);
                                    if (done) return RETURN;
                                }) === RETURN) return;
                            } catch (e) {
                                if (done) throw e;
                                observer.error(e);
                                return;
                            }

                            observer.complete();
                        }
                    });
                    return function () {
                        done = true;
                    };
                });
            },
            of: function of() {
                for (var i = 0, l = arguments.length, items = new Array(l); i < l;) {
                    items[i] = arguments[i++];
                }

                return new (typeof this === 'function' ? this : $Observable)(function (observer) {
                    var done = false;
                    microtask$2(function () {
                        if (!done) {
                            for (var j = 0; j < items.length; ++j) {
                                observer.next(items[j]);
                                if (done) return;
                            }

                            observer.complete();
                        }
                    });
                    return function () {
                        done = true;
                    };
                });
            }
        });
        _hide($Observable.prototype, OBSERVABLE, function () {
            return this;
        });
        _export(_export.G, {
            Observable: $Observable
        });

        _setSpecies('Observable');

        // ie9- setTimeout & setInterval additional parameters fix






        var slice = [].slice;
        var MSIE = /MSIE .\./.test(_userAgent); // <- dirty ie9- check

        var wrap$1 = function wrap(set) {
            return function (fn, time
                             /* , ...args */
            ) {
                var boundArgs = arguments.length > 2;
                var args = boundArgs ? slice.call(arguments, 2) : false;
                return set(boundArgs ? function () {
                    // eslint-disable-next-line no-new-func
                    (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
                } : fn, time);
            };
        };

        _export(_export.G + _export.B + _export.F * MSIE, {
            setTimeout: wrap$1(_global.setTimeout),
            setInterval: wrap$1(_global.setInterval)
        });

        _export(_export.G + _export.B, {
            setImmediate: _task.set,
            clearImmediate: _task.clear
        });

        var ITERATOR$4 = _wks('iterator');
        var TO_STRING_TAG = _wks('toStringTag');
        var ArrayValues = _iterators.Array;
        var DOMIterables = {
            CSSRuleList: true,
            // TODO: Not spec compliant, should be false.
            CSSStyleDeclaration: false,
            CSSValueList: false,
            ClientRectList: false,
            DOMRectList: false,
            DOMStringList: false,
            DOMTokenList: true,
            DataTransferItemList: false,
            FileList: false,
            HTMLAllCollection: false,
            HTMLCollection: false,
            HTMLFormElement: false,
            HTMLSelectElement: false,
            MediaList: true,
            // TODO: Not spec compliant, should be false.
            MimeTypeArray: false,
            NamedNodeMap: false,
            NodeList: true,
            PaintRequestList: false,
            Plugin: false,
            PluginArray: false,
            SVGLengthList: false,
            SVGNumberList: false,
            SVGPathSegList: false,
            SVGPointList: false,
            SVGStringList: false,
            SVGTransformList: false,
            SourceBufferList: false,
            StyleSheetList: true,
            // TODO: Not spec compliant, should be false.
            TextTrackCueList: false,
            TextTrackList: false,
            TouchList: false
        };

        for (var collections = _objectKeys(DOMIterables), i$2 = 0; i$2 < collections.length; i$2++) {
            var NAME$1 = collections[i$2];
            var explicit = DOMIterables[NAME$1];
            var Collection = _global[NAME$1];
            var proto$3 = Collection && Collection.prototype;
            var key$1;

            if (proto$3) {
                if (!proto$3[ITERATOR$4]) _hide(proto$3, ITERATOR$4, ArrayValues);
                if (!proto$3[TO_STRING_TAG]) _hide(proto$3, TO_STRING_TAG, NAME$1);
                _iterators[NAME$1] = ArrayValues;
                if (explicit) for (key$1 in es6_array_iterator) {
                    if (!proto$3[key$1]) _redefine(proto$3, key$1, es6_array_iterator[key$1], true);
                }
            }
        }

        if (window._main_core_polyfill) {
            console.warn('main.core.polyfill is loaded more than once on this page');
        }

        window._main_core_polyfill = true;

    }((this.window = this.window || {})));



    /**
     * Element.prototype.matches polyfill
     */
    ;(function(element) {
        'use strict';

        if (!element.matches && element.matchesSelector)
        {
            element.matches = element.matchesSelector;
        }

        if (!element.matches)
        {
            element.matches = function(selector) {
                var matches = document.querySelectorAll(selector);
                var self = this;

                return Array.prototype.some.call(matches, function(e) {
                    return e === self;
                });
            };
        }

    })(Element.prototype);

    ;(function() {
        'use strict';

        if (!Element.prototype.closest)
        {
            /**
             * Finds closest parent element by selector
             * @param {string} selector
             * @return {HTMLElement|Element|Node}
             */
            Object.defineProperty(Element.prototype, 'closest', {
                enumerable: false,
                value: function(selector) {
                    var node = this;

                    while (node)
                    {
                        if (node.matches(selector))
                        {
                            return node;
                        }

                        node = node.parentElement;
                    }

                    return null;
                },
            });
        }
    })();

    (function (exports) {
        'use strict';

        if (!window.DOMRect || typeof DOMRect.prototype.toJSON !== 'function' || typeof DOMRect.fromRect !== 'function') {
            window.DOMRect =
                /*#__PURE__*/
                function () {
                    function DOMRect(x, y, width, height) {
                        babelHelpers.classCallCheck(this, DOMRect);
                        this.x = x || 0;
                        this.y = y || 0;
                        this.width = width || 0;
                        this.height = height || 0;
                    }

                    babelHelpers.createClass(DOMRect, [{
                        key: "toJSON",
                        value: function toJSON() {
                            return {
                                top: this.top,
                                left: this.left,
                                right: this.right,
                                bottom: this.bottom,
                                width: this.width,
                                height: this.height,
                                x: this.x,
                                y: this.y
                            };
                        }
                    }, {
                        key: "top",
                        get: function get() {
                            return this.y;
                        }
                    }, {
                        key: "left",
                        get: function get() {
                            return this.x;
                        }
                    }, {
                        key: "right",
                        get: function get() {
                            return this.x + this.width;
                        }
                    }, {
                        key: "bottom",
                        get: function get() {
                            return this.y + this.height;
                        }
                    }], [{
                        key: "fromRect",
                        value: function fromRect(otherRect) {
                            return new DOMRect(otherRect.x, otherRect.y, otherRect.width, otherRect.height);
                        }
                    }]);
                    return DOMRect;
                }();
        }

    }((this.window = this.window || {})));




    (function (exports) {
        'use strict';

        var bxTmp = window.BX;

        window.BX = function (node) {
            if (window.BX.type.isNotEmptyString(node)) {
                return document.getElementById(node);
            }

            if (window.BX.type.isDomNode(node)) {
                return node;
            }

            if (window.BX.type.isFunction(node)) {
                return window.BX.ready(node);
            }

            return null;
        };

        if (bxTmp) {
            Object.keys(bxTmp).forEach(function (key) {
                window.BX[key] = bxTmp[key];
            });
        }

        exports = window.BX;

        /**
         * Gets object.toString result
         * @param value
         * @return {string}
         */
        function getTag(value) {
            return Object.prototype.toString.call(value);
        }

        var objectCtorString = Function.prototype.toString.call(Object);
        /**
         * @memberOf BX
         */

        var Type =
            /*#__PURE__*/
            function () {
                function Type() {
                    babelHelpers.classCallCheck(this, Type);
                }

                babelHelpers.createClass(Type, null, [{
                    key: "isString",

                    /**
                     * Checks that value is string
                     * @param value
                     * @return {boolean}
                     */
                    value: function isString(value) {
                        return typeof value === 'string';
                    }
                    /**
                     * Returns true if a value is not empty string
                     * @param value
                     * @returns {boolean}
                     */

                }, {
                    key: "isStringFilled",
                    value: function isStringFilled(value) {
                        return this.isString(value) && value !== '';
                    }
                    /**
                     * Checks that value is function
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isFunction",
                    value: function isFunction(value) {
                        return typeof value === 'function';
                    }
                    /**
                     * Checks that value is object
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isObject",
                    value: function isObject(value) {
                        return !!value && (babelHelpers.typeof(value) === 'object' || typeof value === 'function');
                    }
                    /**
                     * Checks that value is object like
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isObjectLike",
                    value: function isObjectLike(value) {
                        return !!value && babelHelpers.typeof(value) === 'object';
                    }
                    /**
                     * Checks that value is plain object
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isPlainObject",
                    value: function isPlainObject(value) {
                        if (!Type.isObjectLike(value) || getTag(value) !== '[object Object]') {
                            return false;
                        }

                        var proto = Object.getPrototypeOf(value);

                        if (proto === null) {
                            return true;
                        }

                        var ctor = proto.hasOwnProperty('constructor') && proto.constructor;
                        return typeof ctor === 'function' && Function.prototype.toString.call(ctor) === objectCtorString;
                    }
                    /**
                     * Checks that value is boolean
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isBoolean",
                    value: function isBoolean(value) {
                        return value === true || value === false;
                    }
                    /**
                     * Checks that value is number
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isNumber",
                    value: function isNumber(value) {
                        return !Number.isNaN(value) && typeof value === 'number';
                    }
                    /**
                     * Checks that value is integer
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isInteger",
                    value: function isInteger(value) {
                        return Type.isNumber(value) && value % 1 === 0;
                    }
                    /**
                     * Checks that value is float
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isFloat",
                    value: function isFloat(value) {
                        return Type.isNumber(value) && !Type.isInteger(value);
                    }
                    /**
                     * Checks that value is nil
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isNil",
                    value: function isNil(value) {
                        return value === null || value === undefined;
                    }
                    /**
                     * Checks that value is array
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isArray",
                    value: function isArray(value) {
                        return !Type.isNil(value) && Array.isArray(value);
                    }
                    /**
                     * Returns true if a value is an array and it has at least one element
                     * @param value
                     * @returns {boolean}
                     */

                }, {
                    key: "isArrayFilled",
                    value: function isArrayFilled(value) {
                        return this.isArray(value) && value.length > 0;
                    }
                    /**
                     * Checks that value is array like
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isArrayLike",
                    value: function isArrayLike(value) {
                        return !Type.isNil(value) && !Type.isFunction(value) && value.length > -1 && value.length <= Number.MAX_SAFE_INTEGER;
                    }
                    /**
                     * Checks that value is Date
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isDate",
                    value: function isDate(value) {
                        return Type.isObjectLike(value) && getTag(value) === '[object Date]';
                    }
                    /**
                     * Checks that is DOM node
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isDomNode",
                    value: function isDomNode(value) {
                        return Type.isObjectLike(value) && !Type.isPlainObject(value) && 'nodeType' in value;
                    }
                    /**
                     * Checks that value is element node
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isElementNode",
                    value: function isElementNode(value) {
                        return Type.isDomNode(value) && value.nodeType === Node.ELEMENT_NODE;
                    }
                    /**
                     * Checks that value is text node
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isTextNode",
                    value: function isTextNode(value) {
                        return Type.isDomNode(value) && value.nodeType === Node.TEXT_NODE;
                    }
                    /**
                     * Checks that value is Map
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isMap",
                    value: function isMap(value) {
                        return Type.isObjectLike(value) && getTag(value) === '[object Map]';
                    }
                    /**
                     * Checks that value is Set
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isSet",
                    value: function isSet(value) {
                        return Type.isObjectLike(value) && getTag(value) === '[object Set]';
                    }
                    /**
                     * Checks that value is WeakMap
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isWeakMap",
                    value: function isWeakMap(value) {
                        return Type.isObjectLike(value) && getTag(value) === '[object WeakMap]';
                    }
                    /**
                     * Checks that value is WeakSet
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isWeakSet",
                    value: function isWeakSet(value) {
                        return Type.isObjectLike(value) && getTag(value) === '[object WeakSet]';
                    }
                    /**
                     * Checks that value is prototype
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isPrototype",
                    value: function isPrototype(value) {
                        return (typeof (value && value.constructor) === 'function' && value.constructor.prototype || Object.prototype) === value;
                    }
                    /**
                     * Checks that value is regexp
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isRegExp",
                    value: function isRegExp(value) {
                        return Type.isObjectLike(value) && getTag(value) === '[object RegExp]';
                    }
                    /**
                     * Checks that value is null
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isNull",
                    value: function isNull(value) {
                        return value === null;
                    }
                    /**
                     * Checks that value is undefined
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isUndefined",
                    value: function isUndefined(value) {
                        return typeof value === 'undefined';
                    }
                    /**
                     * Checks that value is ArrayBuffer
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isArrayBuffer",
                    value: function isArrayBuffer(value) {
                        return Type.isObjectLike(value) && getTag(value) === '[object ArrayBuffer]';
                    }
                    /**
                     * Checks that value is typed array
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isTypedArray",
                    value: function isTypedArray(value) {
                        var regExpTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)]$/;
                        return Type.isObjectLike(value) && regExpTypedTag.test(getTag(value));
                    }
                    /**
                     * Checks that value is Blob
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isBlob",
                    value: function isBlob(value) {
                        return Type.isObjectLike(value) && Type.isNumber(value.size) && Type.isString(value.type) && Type.isFunction(value.slice);
                    }
                    /**
                     * Checks that value is File
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isFile",
                    value: function isFile(value) {
                        return Type.isBlob(value) && Type.isObjectLike(value.lastModifiedDate) && Type.isNumber(value.lastModified) && Type.isString(value.name);
                    }
                    /**
                     * Checks that value is FormData
                     * @param value
                     * @return {boolean}
                     */

                }, {
                    key: "isFormData",
                    value: function isFormData(value) {
                        return value instanceof FormData;
                    }
                }]);
                return Type;
            }();

        /**
         * @memberOf BX
         */

        var Reflection =
            /*#__PURE__*/
            function () {
                function Reflection() {
                    babelHelpers.classCallCheck(this, Reflection);
                }

                babelHelpers.createClass(Reflection, null, [{
                    key: "getClass",

                    /**
                     * Gets link to function by function name
                     * @param className
                     * @return {?Function}
                     */
                    value: function getClass(className) {
                        if (Type.isString(className) && !!className) {
                            var classFn = null;
                            var currentNamespace = window;
                            var namespaces = className.split('.');

                            for (var i = 0; i < namespaces.length; i += 1) {
                                var namespace = namespaces[i];

                                if (!currentNamespace[namespace]) {
                                    return null;
                                }

                                currentNamespace = currentNamespace[namespace];
                                classFn = currentNamespace;
                            }

                            return classFn;
                        }

                        if (Type.isFunction(className)) {
                            return className;
                        }

                        return null;
                    }
                    /**
                     * Creates a namespace or returns a link to a previously created one
                     * @param {String} namespaceName
                     * @return {Object<string, any> | Function | null}
                     */

                }, {
                    key: "namespace",
                    value: function namespace(namespaceName) {
                        var parts = namespaceName.split('.');
                        var parent = window.BX;

                        if (parts[0] === 'BX') {
                            parts = parts.slice(1);
                        }

                        for (var i = 0; i < parts.length; i += 1) {
                            if (Type.isUndefined(parent[parts[i]])) {
                                parent[parts[i]] = {};
                            }

                            parent = parent[parts[i]];
                        }

                        return parent;
                    }
                }]);
                return Reflection;
            }();

        var reEscape = /[&<>'"]/g;
        var reUnescape = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34);/g;
        var escapeEntities = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            "'": '&#39;',
            '"': '&quot;'
        };
        var unescapeEntities = {
            '&amp;': '&',
            '&#38;': '&',
            '&lt;': '<',
            '&#60;': '<',
            '&gt;': '>',
            '&#62;': '>',
            '&apos;': "'",
            '&#39;': "'",
            '&quot;': '"',
            '&#34;': '"'
        };
        /**
         * @memberOf BX
         */

        var Text =
            /*#__PURE__*/
            function () {
                function Text() {
                    babelHelpers.classCallCheck(this, Text);
                }

                babelHelpers.createClass(Text, null, [{
                    key: "encode",

                    /**
                     * Encodes all unsafe entities
                     * @param {string} value
                     * @return {string}
                     */
                    value: function encode(value) {
                        if (Type.isString(value)) {
                            return value.replace(reEscape, function (item) {
                                return escapeEntities[item];
                            });
                        }

                        return value;
                    }
                    /**
                     * Decodes all encoded entities
                     * @param {string} value
                     * @return {string}
                     */

                }, {
                    key: "decode",
                    value: function decode(value) {
                        if (Type.isString(value)) {
                            return value.replace(reUnescape, function (item) {
                                return unescapeEntities[item];
                            });
                        }

                        return value;
                    }
                }, {
                    key: "getRandom",
                    value: function getRandom() {
                        var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
                        // eslint-disable-next-line
                        return babelHelpers.toConsumableArray(Array(length)).map(function () {
                            return (~~(Math.random() * 36)).toString(36);
                        }).join('');
                    }
                }, {
                    key: "toNumber",
                    value: function toNumber(value) {
                        var parsedValue = Number.parseFloat(value);

                        if (Type.isNumber(parsedValue)) {
                            return parsedValue;
                        }

                        return 0;
                    }
                }, {
                    key: "toInteger",
                    value: function toInteger(value) {
                        return Text.toNumber(Number.parseInt(value, 10));
                    }
                }, {
                    key: "toBoolean",
                    value: function toBoolean(value) {
                        var trueValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
                        var transformedValue = Type.isString(value) ? value.toLowerCase() : value;
                        return ['true', 'y', '1', 1, true].concat(babelHelpers.toConsumableArray(trueValues)).includes(transformedValue);
                    }
                }, {
                    key: "toCamelCase",
                    value: function toCamelCase(str) {
                        if (!Type.isStringFilled(str)) {
                            return str;
                        }

                        var regex = /[-_\s]+(.)?/g;

                        if (!regex.test(str)) {
                            return str.match(/^[A-Z]+$/) ? str.toLowerCase() : str[0].toLowerCase() + str.slice(1);
                        }

                        str = str.toLowerCase();
                        str = str.replace(regex, function (match, letter) {
                            return letter ? letter.toUpperCase() : '';
                        });
                        return str[0].toLowerCase() + str.substr(1);
                    }
                }, {
                    key: "toPascalCase",
                    value: function toPascalCase(str) {
                        if (!Type.isStringFilled(str)) {
                            return str;
                        }

                        return this.capitalize(this.toCamelCase(str));
                    }
                }, {
                    key: "toKebabCase",
                    value: function toKebabCase(str) {
                        if (!Type.isStringFilled(str)) {
                            return str;
                        }

                        var matches = str.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g);

                        if (!matches) {
                            return str;
                        }

                        return matches.map(function (x) {
                            return x.toLowerCase();
                        }).join('-');
                    }
                }, {
                    key: "capitalize",
                    value: function capitalize(str) {
                        if (!Type.isStringFilled(str)) {
                            return str;
                        }

                        return str[0].toUpperCase() + str.substr(1);
                    }
                }]);
                return Text;
            }();

        var aliases = {
            mousewheel: ['DOMMouseScroll'],
            bxchange: ['change', 'cut', 'paste', 'drop', 'keyup'],
            animationend: ['animationend', 'oAnimationEnd', 'webkitAnimationEnd', 'MSAnimationEnd'],
            transitionend: ['webkitTransitionEnd', 'otransitionend', 'oTransitionEnd', 'msTransitionEnd', 'transitionend'],
            fullscreenchange: ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'],
            fullscreenerror: ['fullscreenerror', 'webkitfullscreenerror', 'mozfullscreenerror', 'MSFullscreenError']
        };

        var Registry =
            /*#__PURE__*/
            function () {
                function Registry() {
                    babelHelpers.classCallCheck(this, Registry);
                    babelHelpers.defineProperty(this, "registry", new WeakMap());
                }

                babelHelpers.createClass(Registry, [{
                    key: "set",
                    value: function set(target, event, listener) {
                        var events = this.get(target);

                        if (!Type.isSet(events[event])) {
                            events[event] = new Set();
                        }

                        events[event].add(listener);
                        this.registry.set(target, events);
                    }
                }, {
                    key: "get",
                    value: function get(target) {
                        return this.registry.get(target) || {};
                    }
                }, {
                    key: "has",
                    value: function has(target, event, listener) {
                        if (event && listener) {
                            return this.registry.has(target) && this.registry.get(target)[event].has(listener);
                        }

                        return this.registry.has(target);
                    }
                }, {
                    key: "delete",
                    value: function _delete(target, event, listener) {
                        if (!Type.isDomNode(target)) {
                            return;
                        }

                        if (Type.isString(event) && Type.isFunction(listener)) {
                            var events = this.registry.get(target);

                            if (Type.isPlainObject(events) && Type.isSet(events[event])) {
                                events[event].delete(listener);
                            }

                            return;
                        }

                        if (Type.isString(event)) {
                            var _events = this.registry.get(target);

                            if (Type.isPlainObject(_events) && Type.isSet(_events[event])) {
                                _events[event] = new Set();
                            }

                            return;
                        }

                        this.registry.delete(target);
                    }
                }]);
                return Registry;
            }();
        var registry = new Registry();

        function isOptionSupported(name) {
            var isSupported = false;

            try {
                var options = Object.defineProperty({}, name, {
                    get: function get() {
                        isSupported = true;
                        return undefined;
                    }
                });
                window.addEventListener('test', null, options);
            } // eslint-disable-next-line
            catch (err) {}

            return isSupported;
        }

        function fetchSupportedListenerOptions(options) {
            if (!Type.isPlainObject(options)) {
                return options;
            }

            return Object.keys(options).reduce(function (acc, name) {
                if (isOptionSupported(name)) {
                    acc[name] = options[name];
                }

                return acc;
            }, {});
        }

        function bind(target, eventName, handler, options) {
            if (!Type.isObject(target) || !Type.isFunction(target.addEventListener)) {
                return;
            }

            var listenerOptions = fetchSupportedListenerOptions(options);

            if (eventName in aliases) {
                aliases[eventName].forEach(function (key) {
                    target.addEventListener(key, handler, listenerOptions);
                    registry.set(target, eventName, handler);
                });
                return;
            }

            target.addEventListener(eventName, handler, listenerOptions);
            registry.set(target, eventName, handler);
        }

        function unbind(target, eventName, handler, options) {
            if (!Type.isObject(target) || !Type.isFunction(target.removeEventListener)) {
                return;
            }

            var listenerOptions = fetchSupportedListenerOptions(options);

            if (eventName in aliases) {
                aliases[eventName].forEach(function (key) {
                    target.removeEventListener(key, handler, listenerOptions);
                    registry.delete(target, key, handler);
                });
                return;
            }

            target.removeEventListener(eventName, handler, listenerOptions);
            registry.delete(target, eventName, handler);
        }

        function unbindAll(target, eventName) {
            var events = registry.get(target);
            Object.keys(events).forEach(function (currentEvent) {
                events[currentEvent].forEach(function (handler) {
                    if (!Type.isString(eventName) || eventName === currentEvent) {
                        unbind(target, currentEvent, handler);
                    }
                });
            });
        }

        function bindOnce(target, eventName, handler, options) {
            var once = function once() {
                unbind(target, eventName, once, options);
                handler.apply(void 0, arguments);
            };

            bind(target, eventName, once, options);
        }

        var debugState = true;
        function enableDebug() {
            debugState = true;
        }
        function disableDebug() {
            debugState = false;
        }
        function isDebugEnabled() {
            return debugState;
        }
        function debug() {
            if (isDebugEnabled() && Type.isObject(window.console)) {
                if (Type.isFunction(window.console.log)) {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }

                    window.console.log('BX.debug: ', args.length > 0 ? args : args[0]);

                    if (args[0] instanceof Error && args[0].stack) {
                        window.console.log('BX.debug error stack trace', args[0].stack);
                    }
                }

                if (Type.isFunction(window.console.trace)) {
                    // eslint-disable-next-line
                    console.trace();
                }
            }
        }

        function fetchExtensionSettings(html) {
            if (Type.isStringFilled(html)) {
                var scripts = html.match(/<script type="extension\/settings" \b[^>]*>([\s\S]*?)<\/script>/g);

                if (Type.isArrayFilled(scripts)) {
                    return scripts.map(function (script) {
                        var _script$match = script.match(/data-extension="(.[a-z0-9_.-]+)"/),
                            _script$match2 = babelHelpers.slicedToArray(_script$match, 2),
                            extension = _script$match2[1];

                        return {
                            extension: extension,
                            script: script
                        };
                    });
                }
            }

            return [];
        }

        var Extension =
            /*#__PURE__*/
            function () {
                function Extension(options) {
                    babelHelpers.classCallCheck(this, Extension);
                    this.config = options.config || {};
                    this.name = options.extension;
                    this.state = 'scheduled'; // eslint-disable-next-line

                    var result = BX.processHTML(options.html || '');
                    this.inlineScripts = result.SCRIPT.reduce(inlineScripts, []);
                    this.externalScripts = result.SCRIPT.reduce(externalScripts, []);
                    this.externalStyles = result.STYLE.reduce(externalStyles, []);
                    this.settingsScripts = fetchExtensionSettings(result.HTML);
                }

                babelHelpers.createClass(Extension, [{
                    key: "load",
                    value: function load() {
                        var _this = this;

                        if (this.state === 'error') {
                            this.loadPromise = this.loadPromise || Promise.resolve(this);
                            console.warn('Extension', this.name, 'not found');
                        }

                        if (!this.loadPromise && this.state) {
                            this.state = 'load';
                            this.settingsScripts.forEach(function (entry) {
                                var isLoaded = !!document.querySelector("script[data-extension=\"".concat(entry.extension, "\"]"));

                                if (!isLoaded) {
                                    document.body.insertAdjacentHTML('beforeend', entry.script);
                                }
                            });
                            this.inlineScripts.forEach(BX.evalGlobal);
                            this.loadPromise = Promise.all([loadAll(this.externalScripts), loadAll(this.externalStyles)]).then(function () {
                                _this.state = 'loaded';

                                if (Type.isPlainObject(_this.config) && _this.config.namespace) {
                                    return Reflection.getClass(_this.config.namespace);
                                }

                                return window;
                            });
                        }

                        return this.loadPromise;
                    }
                }]);
                return Extension;
            }();

        var initialized = {};
        var ajaxController = 'main.bitrix.main.controller.loadext.getextensions';

        function makeIterable(value) {
            return Type.isArray(value) ? value : [value];
        }
        function isInitialized(extension) {
            return extension in initialized;
        }
        function getInitialized(extension) {
            return initialized[extension];
        }
        function isAllInitialized(extensions) {
            return extensions.every(isInitialized);
        }
        function loadExtensions(extensions) {
            return Promise.all(extensions.map(function (item) {
                return item.load();
            }));
        }
        function mergeExports(exports) {
            return exports.reduce(function (acc, currentExports) {
                if (Type.isObject(currentExports)) {
                    return babelHelpers.objectSpread({}, currentExports);
                }

                return currentExports;
            }, {});
        }
        function inlineScripts(acc, item) {
            if (item.isInternal) {
                acc.push(item.JS);
            }

            return acc;
        }
        function externalScripts(acc, item) {
            if (!item.isInternal) {
                acc.push(item.JS);
            }

            return acc;
        }
        function externalStyles(acc, item) {
            if (Type.isString(item) && item !== '') {
                acc.push(item);
            }

            return acc;
        }
        function request(options) {
            return new Promise(function (resolve) {
                // eslint-disable-next-line
                BX.ajax.runAction(ajaxController, {
                    data: options
                }).then(resolve);
            });
        }
        function prepareExtensions(response) {
            if (response.status !== 'success') {
                response.errors.map(console.warn);
                return [];
            }

            return response.data.map(function (item) {
                var initializedExtension = getInitialized(item.extension);

                if (initializedExtension) {
                    return initializedExtension;
                }

                initialized[item.extension] = new Extension(item);
                return initialized[item.extension];
            });
        }
        function loadAll(items) {
            var itemsList = makeIterable(items);

            if (!itemsList.length) {
                return Promise.resolve();
            }

            return new Promise(function (resolve) {
                // eslint-disable-next-line
                BX.load(itemsList, resolve);
            });
        }

        /**
         * Loads extensions asynchronously
         * @param {string|Array<string>} extension
         * @return {Promise<Array<Extension>>}
         */
        function loadExtension(extension) {
            var extensions = makeIterable(extension);
            var isAllInitialized$1 = isAllInitialized(extensions);

            if (isAllInitialized$1) {
                var initializedExtensions = extensions.map(getInitialized);
                return loadExtensions(initializedExtensions).then(mergeExports);
            }

            return request({
                extension: extensions
            }).then(prepareExtensions).then(loadExtensions).then(mergeExports);
        }

        var cloneableTags = ['[object Object]', '[object Array]', '[object RegExp]', '[object Arguments]', '[object Date]', '[object Error]', '[object Map]', '[object Set]', '[object ArrayBuffer]', '[object DataView]', '[object Float32Array]', '[object Float64Array]', '[object Int8Array]', '[object Int16Array]', '[object Int32Array]', '[object Uint8Array]', '[object Uint16Array]', '[object Uint32Array]', '[object Uint8ClampedArray]'];

        function isCloneable(value) {
            var isCloneableValue = Type.isObjectLike(value) && cloneableTags.includes(getTag(value));
            return isCloneableValue || Type.isDomNode(value);
        }

        function internalClone(value, map) {
            if (map.has(value)) {
                return map.get(value);
            }

            if (isCloneable(value)) {
                if (Type.isArray(value)) {
                    var cloned = Array.from(value);
                    map.set(value, cloned);
                    value.forEach(function (item, index) {
                        cloned[index] = internalClone(item, map);
                    });
                    return map.get(value);
                }

                if (Type.isDomNode(value)) {
                    return value.cloneNode(true);
                }

                if (Type.isMap(value)) {
                    var _result = new Map();

                    map.set(value, _result);
                    value.forEach(function (item, key) {
                        _result.set(internalClone(key, map), internalClone(item, map));
                    });
                    return _result;
                }

                if (Type.isSet(value)) {
                    var _result2 = new Set();

                    map.set(value, _result2);
                    value.forEach(function (item) {
                        _result2.add(internalClone(item, map));
                    });
                    return _result2;
                }

                if (Type.isDate(value)) {
                    return new Date(value);
                }

                if (Type.isRegExp(value)) {
                    var regExpFlags = /\w*$/;
                    var flags = regExpFlags.exec(value);

                    var _result3 = new RegExp(value.source);

                    if (flags && Type.isArray(flags)) {
                        _result3 = new RegExp(value.source, flags[0]);
                    }

                    _result3.lastIndex = value.lastIndex;
                    return _result3;
                }

                var proto = Object.getPrototypeOf(value);
                var result = Object.assign(Object.create(proto), value);
                map.set(value, result);
                Object.keys(value).forEach(function (key) {
                    result[key] = internalClone(value[key], map);
                });
                return result;
            }

            return value;
        }
        /**
         * Clones any cloneable object
         * @param value
         * @return {*}
         */

        function clone(value) {
            return internalClone(value, new WeakMap());
        }

        function merge(current, target) {
            return Object.entries(target).reduce(function (acc, _ref) {
                var _ref2 = babelHelpers.slicedToArray(_ref, 2),
                    key = _ref2[0],
                    value = _ref2[1];

                if (!Type.isDomNode(acc[key]) && Type.isObjectLike(acc[key]) && Type.isObjectLike(value)) {
                    acc[key] = merge(acc[key], value);
                    return acc;
                }

                acc[key] = value;
                return acc;
            }, current);
        }

        function createComparator(fields) {
            var orders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
            return function (a, b) {
                var field = fields[0];
                var order = orders[0] || 'asc';

                if (Type.isUndefined(field)) {
                    return 0;
                }

                var valueA = a[field];
                var valueB = b[field];

                if (Type.isString(valueA) && Type.isString(valueB)) {
                    valueA = valueA.toLowerCase();
                    valueB = valueB.toLowerCase();
                }

                if (valueA < valueB) {
                    return order === 'asc' ? -1 : 1;
                }

                if (valueA > valueB) {
                    return order === 'asc' ? 1 : -1;
                }

                return createComparator(fields.slice(1), orders.slice(1))(a, b);
            };
        }

        /**
         * @memberOf BX
         */

        var Runtime =
            /*#__PURE__*/
            function () {
                function Runtime() {
                    babelHelpers.classCallCheck(this, Runtime);
                }

                babelHelpers.createClass(Runtime, null, [{
                    key: "debounce",
                    value: function debounce(func) {
                        var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                        var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                        var timeoutId;
                        return function debounced() {
                            var _this = this;

                            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                                args[_key] = arguments[_key];
                            }

                            if (Type.isNumber(timeoutId)) {
                                clearTimeout(timeoutId);
                            }

                            timeoutId = setTimeout(function () {
                                func.apply(context || _this, args);
                            }, wait);
                        };
                    }
                }, {
                    key: "throttle",
                    value: function throttle(func) {
                        var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                        var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                        var timer = 0;
                        var invoke;
                        return function wrapper() {
                            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                                args[_key2] = arguments[_key2];
                            }

                            invoke = true;

                            if (!timer) {
                                var q = function q() {
                                    if (invoke) {
                                        func.apply(context || this, args);
                                        invoke = false;
                                        timer = setTimeout(q, wait);
                                    } else {
                                        timer = null;
                                    }
                                };

                                q();
                            }
                        };
                    }
                }, {
                    key: "html",
                    value: function html(node, _html) {
                        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

                        if (Type.isNil(_html) && Type.isDomNode(node)) {
                            return node.innerHTML;
                        } // eslint-disable-next-line


                        var parsedHtml = BX.processHTML(_html);
                        var externalCss = parsedHtml.STYLE.reduce(externalStyles, []);
                        var externalJs = parsedHtml.SCRIPT.reduce(externalScripts, []);
                        var inlineJs = parsedHtml.SCRIPT.reduce(inlineScripts, []);

                        if (Type.isDomNode(node)) {
                            if (params.htmlFirst || !externalJs.length && !externalCss.length) {
                                node.innerHTML = parsedHtml.HTML;
                            }
                        }

                        return Promise.all([loadAll(externalJs), loadAll(externalCss)]).then(function () {
                            if (Type.isDomNode(node) && (externalJs.length > 0 || externalCss.length > 0)) {
                                node.innerHTML = parsedHtml.HTML;
                            } // eslint-disable-next-line


                            inlineJs.forEach(function (script) {
                                return BX.evalGlobal(script);
                            });

                            if (Type.isFunction(params.callback)) {
                                params.callback();
                            }
                        });
                    }
                    /**
                     * Merges objects or arrays
                     * @param targets
                     * @return {any}
                     */

                }, {
                    key: "merge",
                    value: function merge$1() {
                        for (var _len3 = arguments.length, targets = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                            targets[_key3] = arguments[_key3];
                        }

                        if (Type.isArray(targets[0])) {
                            targets.unshift([]);
                        } else if (Type.isObject(targets[0])) {
                            targets.unshift({});
                        }

                        return targets.reduce(function (acc, item) {
                            return merge(acc, item);
                        }, targets[0]);
                    }
                }, {
                    key: "orderBy",
                    value: function orderBy(collection) {
                        var fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
                        var orders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
                        var comparator = createComparator(fields, orders);
                        return Object.values(collection).sort(comparator);
                    }
                }, {
                    key: "destroy",
                    value: function destroy(target) {
                        var errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Object is destroyed';

                        if (Type.isObject(target)) {
                            var onPropertyAccess = function onPropertyAccess() {
                                throw new Error(errorMessage);
                            };

                            var ownProperties = Object.keys(target);

                            var prototypeProperties = function () {
                                var targetPrototype = Object.getPrototypeOf(target);

                                if (Type.isObject(targetPrototype)) {
                                    return Object.getOwnPropertyNames(targetPrototype);
                                }

                                return [];
                            }();

                            var uniquePropertiesList = babelHelpers.toConsumableArray(new Set([].concat(babelHelpers.toConsumableArray(ownProperties), babelHelpers.toConsumableArray(prototypeProperties))));
                            uniquePropertiesList.filter(function (name) {
                                var descriptor = Object.getOwnPropertyDescriptor(target, name);
                                return !/__(.+)__/.test(name) && (!Type.isObject(descriptor) || descriptor.configurable === true);
                            }).forEach(function (name) {
                                Object.defineProperty(target, name, {
                                    get: onPropertyAccess,
                                    set: onPropertyAccess,
                                    configurable: false
                                });
                            });
                            Object.setPrototypeOf(target, null);
                        }
                    }
                }]);
                return Runtime;
            }();

        babelHelpers.defineProperty(Runtime, "debug", debug);
        babelHelpers.defineProperty(Runtime, "loadExtension", loadExtension);
        babelHelpers.defineProperty(Runtime, "clone", clone);

        var _isError = Symbol.for('BX.BaseError.isError');
        /**
         * @memberOf BX
         */


        var BaseError =
            /*#__PURE__*/
            function () {
                function BaseError(message, code, customData) {
                    babelHelpers.classCallCheck(this, BaseError);
                    this[_isError] = true;
                    this.message = '';
                    this.code = null;
                    this.customData = null;
                    this.setMessage(message);
                    this.setCode(code);
                    this.setCustomData(customData);
                }
                /**
                 * Returns a brief description of the error
                 * @returns {string}
                 */


                babelHelpers.createClass(BaseError, [{
                    key: "getMessage",
                    value: function getMessage() {
                        return this.message;
                    }
                    /**
                     * Sets a message of the error
                     * @param {string} message
                     * @returns {this}
                     */

                }, {
                    key: "setMessage",
                    value: function setMessage(message) {
                        if (Type.isString(message)) {
                            this.message = message;
                        }

                        return this;
                    }
                    /**
                     * Returns a code of the error
                     * @returns {?string}
                     */

                }, {
                    key: "getCode",
                    value: function getCode() {
                        return this.code;
                    }
                    /**
                     * Sets a code of the error
                     * @param {string} code
                     * @returns {this}
                     */

                }, {
                    key: "setCode",
                    value: function setCode(code) {
                        if (Type.isStringFilled(code) || code === null) {
                            this.code = code;
                        }

                        return this;
                    }
                    /**
                     * Returns custom data of the error
                     * @returns {null|*}
                     */

                }, {
                    key: "getCustomData",
                    value: function getCustomData() {
                        return this.customData;
                    }
                    /**
                     * Sets custom data of the error
                     * @returns {this}
                     */

                }, {
                    key: "setCustomData",
                    value: function setCustomData(customData) {
                        if (!Type.isUndefined(customData)) {
                            this.customData = customData;
                        }

                        return this;
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        var code = this.getCode();
                        var message = this.getMessage();

                        if (!Type.isStringFilled(code) && !Type.isStringFilled(message)) {
                            return '';
                        } else if (!Type.isStringFilled(code)) {
                            return "Error: ".concat(message);
                        } else if (!Type.isStringFilled(message)) {
                            return code;
                        } else {
                            return "".concat(code, ": ").concat(message);
                        }
                    }
                    /**
                     * Returns true if the object is an instance of BaseError
                     * @param error
                     * @returns {boolean}
                     */

                }], [{
                    key: "isError",
                    value: function isError(error) {
                        return Type.isObject(error) && error[_isError] === true;
                    }
                }]);
                return BaseError;
            }();

        /**
         * Implements base event object interface
         */

        var BaseEvent =
            /*#__PURE__*/
            function () {
                function BaseEvent() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
                        data: {}
                    };
                    babelHelpers.classCallCheck(this, BaseEvent);
                    this.type = '';
                    this.data = null;
                    this.target = null;
                    this.compatData = null;
                    this.defaultPrevented = false;
                    this.immediatePropagationStopped = false;
                    this.errors = [];
                    this.setData(options.data);
                    this.setCompatData(options.compatData);
                }

                babelHelpers.createClass(BaseEvent, [{
                    key: "getType",

                    /**
                     * Returns the name of the event
                     * @returns {string}
                     */
                    value: function getType() {
                        return this.type;
                    }
                    /**
                     *
                     * @param {string} type
                     */

                }, {
                    key: "setType",
                    value: function setType(type) {
                        if (Type.isStringFilled(type)) {
                            this.type = type;
                        }

                        return this;
                    }
                    /**
                     * Returns an event data
                     */

                }, {
                    key: "getData",
                    value: function getData() {
                        return this.data;
                    }
                    /**
                     * Sets an event data
                     * @param data
                     */

                }, {
                    key: "setData",
                    value: function setData(data) {
                        if (!Type.isUndefined(data)) {
                            this.data = data;
                        }

                        return this;
                    }
                    /**
                     * Returns arguments for BX.addCustomEvent handlers (deprecated).
                     * @returns {array | null}
                     */

                }, {
                    key: "getCompatData",
                    value: function getCompatData() {
                        return this.compatData;
                    }
                    /**
                     * Sets arguments for BX.addCustomEvent handlers (deprecated)
                     * @param data
                     */

                }, {
                    key: "setCompatData",
                    value: function setCompatData(data) {
                        if (Type.isArrayLike(data)) {
                            this.compatData = data;
                        }

                        return this;
                    }
                    /**
                     * Sets a event target
                     * @param target
                     */

                }, {
                    key: "setTarget",
                    value: function setTarget(target) {
                        this.target = target;
                        return this;
                    }
                    /**
                     * Returns a event target
                     */

                }, {
                    key: "getTarget",
                    value: function getTarget() {
                        return this.target;
                    }
                    /**
                     * Returns an array of event errors
                     * @returns {[]}
                     */

                }, {
                    key: "getErrors",
                    value: function getErrors() {
                        return this.errors;
                    }
                    /**
                     * Adds an error of the event.
                     * Event listeners can prevent emitter's default action and set the reason of this behavior.
                     * @param error
                     */

                }, {
                    key: "setError",
                    value: function setError(error) {
                        if (BaseError.isError(error)) {
                            this.errors.push(error);
                        }
                    }
                    /**
                     * Prevents default action
                     */

                }, {
                    key: "preventDefault",
                    value: function preventDefault() {
                        this.defaultPrevented = true;
                    }
                    /**
                     * Checks that is default action prevented
                     * @return {boolean}
                     */

                }, {
                    key: "isDefaultPrevented",
                    value: function isDefaultPrevented() {
                        return this.defaultPrevented;
                    }
                    /**
                     * Stops event immediate propagation
                     */

                }, {
                    key: "stopImmediatePropagation",
                    value: function stopImmediatePropagation() {
                        this.immediatePropagationStopped = true;
                    }
                    /**
                     * Checks that is immediate propagation stopped
                     * @return {boolean}
                     */

                }, {
                    key: "isImmediatePropagationStopped",
                    value: function isImmediatePropagationStopped() {
                        return this.immediatePropagationStopped;
                    }
                }], [{
                    key: "create",
                    value: function create(options) {
                        return new this(options);
                    }
                }]);
                return BaseEvent;
            }();

        var EventStore =
            /*#__PURE__*/
            function () {
                function EventStore() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                    babelHelpers.classCallCheck(this, EventStore);
                    this.defaultMaxListeners = Type.isNumber(options.defaultMaxListeners) ? options.defaultMaxListeners : 10;
                    this.eventStore = new WeakMap();
                }

                babelHelpers.createClass(EventStore, [{
                    key: "add",
                    value: function add(target) {
                        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                        var record = this.getRecordScheme();

                        if (Type.isNumber(options.maxListeners)) {
                            record.maxListeners = options.maxListeners;
                        }

                        this.eventStore.set(target, record);
                        return record;
                    }
                }, {
                    key: "get",
                    value: function get(target) {
                        return this.eventStore.get(target);
                    }
                }, {
                    key: "getOrAdd",
                    value: function getOrAdd(target) {
                        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                        return this.get(target) || this.add(target, options);
                    }
                }, {
                    key: "delete",
                    value: function _delete(context) {
                        this.eventStore.delete(context);
                    }
                }, {
                    key: "getRecordScheme",
                    value: function getRecordScheme() {
                        return {
                            eventsMap: new Map(),
                            onceMap: new Map(),
                            maxListeners: this.getDefaultMaxListeners(),
                            eventsMaxListeners: new Map()
                        };
                    }
                }, {
                    key: "getDefaultMaxListeners",
                    value: function getDefaultMaxListeners() {
                        return this.defaultMaxListeners;
                    }
                }]);
                return EventStore;
            }();

        var WarningStore =
            /*#__PURE__*/
            function () {
                function WarningStore() {
                    babelHelpers.classCallCheck(this, WarningStore);
                    this.warnings = new Map();
                    this.printDelayed = Runtime.debounce(this.print.bind(this), 500);
                }

                babelHelpers.createClass(WarningStore, [{
                    key: "add",
                    value: function add(target, eventName, listeners) {
                        var contextWarnings = this.warnings.get(target);

                        if (!contextWarnings) {
                            contextWarnings = Object.create(null);
                            this.warnings.set(target, contextWarnings);
                        }

                        if (!contextWarnings[eventName]) {
                            contextWarnings[eventName] = {};
                        }

                        contextWarnings[eventName].size = listeners.size;

                        if (!Type.isArray(contextWarnings[eventName].errors)) {
                            contextWarnings[eventName].errors = [];
                        }

                        contextWarnings[eventName].errors.push(new Error());
                    }
                }, {
                    key: "print",
                    value: function print() {
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.warnings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var _step$value = babelHelpers.slicedToArray(_step.value, 2),
                                    target = _step$value[0],
                                    warnings = _step$value[1];

                                for (var eventName in warnings) {
                                    console.groupCollapsed('Possible BX.Event.EventEmitter memory leak detected. ' + warnings[eventName].size + ' "' + eventName + '" listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.');
                                    console.dir(warnings[eventName].errors);
                                    console.groupEnd();
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return != null) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        this.clear();
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        this.warnings.clear();
                    }
                }, {
                    key: "printDelayed",
                    value: function printDelayed() {}
                }]);
                return WarningStore;
            }();

        var eventStore = new EventStore({
            defaultMaxListeners: 10
        });
        var warningStore = new WarningStore();
        var aliasStore = new Map();
        var globalTarget = {
            GLOBAL_TARGET: 'GLOBAL_TARGET' // this key only for debugging purposes

        };
        eventStore.add(globalTarget, {
            maxListeners: 25
        });
        var isEmitterProperty = Symbol.for('BX.Event.EventEmitter.isEmitter');
        var namespaceProperty = Symbol('namespaceProperty');
        var targetProperty = Symbol('targetProperty');

        var EventEmitter =
            /*#__PURE__*/
            function () {
                /** @private */
                function EventEmitter() {
                    var _this = this;

                    babelHelpers.classCallCheck(this, EventEmitter);
                    this[targetProperty] = null;
                    this[namespaceProperty] = null;
                    this[isEmitterProperty] = true;
                    var target = this;

                    if (Object.getPrototypeOf(this) === EventEmitter.prototype && arguments.length > 0) //new EventEmitter(obj) case
                    {
                        if (!Type.isObject(arguments.length <= 0 ? undefined : arguments[0])) {
                            throw new TypeError("The \"target\" argument must be an object.");
                        }

                        target = arguments.length <= 0 ? undefined : arguments[0];
                        this.setEventNamespace(arguments.length <= 1 ? undefined : arguments[1]);
                    }

                    this[targetProperty] = target;
                    setTimeout(function () {
                        if (_this.getEventNamespace() === null) {
                            console.warn('The instance of BX.Event.EventEmitter is supposed to have an event namespace. ' + 'Use emitter.setEventNamespace() to make events more unique.');
                        }
                    }, 500);
                }
                /**
                 * Makes a target observable
                 * @param {object} target
                 * @param {string} namespace
                 */


                babelHelpers.createClass(EventEmitter, [{
                    key: "setEventNamespace",
                    value: function setEventNamespace(namespace) {
                        if (Type.isStringFilled(namespace)) {
                            this[namespaceProperty] = namespace;
                        }
                    }
                }, {
                    key: "getEventNamespace",
                    value: function getEventNamespace() {
                        return this[namespaceProperty];
                    }
                    /**
                     * Subscribes listener on specified global event
                     * @param {object} target
                     * @param {string} eventName
                     * @param {Function<BaseEvent>} listener
                     * @param {object} options
                     */

                }, {
                    key: "subscribe",

                    /**
                     * Subscribes a listener on a specified event
                     * @param {string} eventName
                     * @param {Function<BaseEvent>} listener
                     * @return {this}
                     */
                    value: function subscribe(eventName, listener) {
                        EventEmitter.subscribe(this, eventName, listener);
                        return this;
                    }
                    /**
                     *
                     * @param {object} options
                     * @param {object} [aliases]
                     * @param {boolean} [compatMode=false]
                     */

                }, {
                    key: "subscribeFromOptions",
                    value: function subscribeFromOptions(options, aliases, compatMode) {
                        var _this2 = this;

                        if (!Type.isPlainObject(options)) {
                            return;
                        }

                        aliases = Type.isPlainObject(aliases) ? EventEmitter.normalizeAliases(aliases) : {};
                        Object.keys(options).forEach(function (eventName) {
                            var listener = options[eventName];

                            if (!Type.isFunction(listener)) {
                                throw new TypeError("The \"listener\" argument must be of type Function. Received type ".concat(babelHelpers.typeof(listener), "."));
                            }

                            eventName = EventEmitter.normalizeEventName(eventName);

                            if (aliases[eventName]) {
                                var actualName = aliases[eventName].eventName;
                                EventEmitter.subscribe(_this2, actualName, listener, {
                                    compatMode: compatMode !== false
                                });
                            } else {
                                EventEmitter.subscribe(_this2, eventName, listener, {
                                    compatMode: compatMode === true
                                });
                            }
                        });
                    }
                    /**
                     * Subscribes a listener that is called at
                     * most once for a specified event.
                     * @param {object} target
                     * @param {string} eventName
                     * @param {Function<BaseEvent>} listener
                     */

                }, {
                    key: "subscribeOnce",

                    /**
                     * Subscribes a listener that is called at most once for a specified event.
                     * @param {string} eventName
                     * @param {Function<BaseEvent>} listener
                     * @return {this}
                     */
                    value: function subscribeOnce(eventName, listener) {
                        EventEmitter.subscribeOnce(this, eventName, listener);
                        return this;
                    }
                    /**
                     * Unsubscribes an event listener
                     * @param {object} target
                     * @param {string} eventName
                     * @param {Function<BaseEvent>} listener
                     * @param options
                     */

                }, {
                    key: "unsubscribe",

                    /**
                     * Unsubscribes an event listener
                     * @param {string} eventName
                     * @param {Function<BaseEvent>} listener
                     * @return {this}
                     */
                    value: function unsubscribe(eventName, listener) {
                        EventEmitter.unsubscribe(this, eventName, listener);
                        return this;
                    }
                    /**
                     * Unsubscribes all event listeners
                     * @param {object} target
                     * @param {string} eventName
                     * @param options
                     */

                }, {
                    key: "unsubscribeAll",

                    /**
                     * Unsubscribes all event listeners
                     * @param {string} [eventName]
                     */
                    value: function unsubscribeAll(eventName) {
                        EventEmitter.unsubscribeAll(this, eventName);
                    }
                    /**
                     *
                     * @param {object} target
                     * @param {string} eventName
                     * @param {BaseEvent | any} event
                     * @param {object} options
                     * @returns {Array}
                     */

                }, {
                    key: "emit",

                    /**
                     * Emits specified event with specified event object
                     * @param {string} eventName
                     * @param {BaseEvent | any} event
                     * @return {this}
                     */
                    value: function emit(eventName, event) {
                        EventEmitter.emit(this, eventName, event);
                        return this;
                    }
                    /**
                     * Emits global event and returns a promise that is resolved when
                     * all promise returned from event handlers are resolved,
                     * or rejected when at least one of the returned promise is rejected.
                     * Importantly. You can return any value from synchronous handlers, not just promise
                     * @param {object} target
                     * @param {string} eventName
                     * @param {BaseEvent | any} event
                     * @return {Promise<Array>}
                     */

                }, {
                    key: "emitAsync",

                    /**
                     * Emits event and returns a promise that is resolved when
                     * all promise returned from event handlers are resolved,
                     * or rejected when at least one of the returned promise is rejected.
                     * Importantly. You can return any value from synchronous handlers, not just promise
                     * @param {string} eventName
                     * @param {BaseEvent|any} event
                     * @return {Promise<Array>}
                     */
                    value: function emitAsync(eventName, event) {
                        return EventEmitter.emitAsync(this, eventName, event);
                    }
                    /**
                     * @private
                     * @param {object} target
                     * @param {string} eventName
                     * @param {BaseEvent|any} event
                     * @returns {BaseEvent}
                     */

                }, {
                    key: "setMaxListeners",

                    /**
                     * Sets max events listeners count
                     * this.setMaxListeners(10) - sets the default value for all events
                     * this.setMaxListeners("onClose", 10) sets the value for onClose event
                     * @return {this}
                     * @param args
                     */
                    value: function setMaxListeners() {
                        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                            args[_key] = arguments[_key];
                        }

                        EventEmitter.setMaxListeners.apply(EventEmitter, [this].concat(args));
                        return this;
                    }
                    /**
                     * Returns max event listeners count
                     * @param {object} target
                     * @param {string} [eventName]
                     * @returns {number}
                     */

                }, {
                    key: "getMaxListeners",

                    /**
                     * Returns max event listeners count
                     * @param {string} [eventName]
                     * @returns {number}
                     */
                    value: function getMaxListeners(eventName) {
                        return EventEmitter.getMaxListeners(this, eventName);
                    }
                    /**
                     * Adds or subtracts max listeners count
                     * Event.EventEmitter.addMaxListeners() - adds one max listener for all events of global target
                     * Event.EventEmitter.addMaxListeners(3) - adds three max listeners for all events of global target
                     * Event.EventEmitter.addMaxListeners(-1) - subtracts one max listener for all events of global target
                     * Event.EventEmitter.addMaxListeners('onClose') - adds one max listener for onClose event of global target
                     * Event.EventEmitter.addMaxListeners('onClose', 2) - adds two max listeners for onClose event of global target
                     * Event.EventEmitter.addMaxListeners('onClose', -1) - subtracts one max listener for onClose event of global target
                     *
                     * Event.EventEmitter.addMaxListeners(obj) - adds one max listener for all events of 'obj' target
                     * Event.EventEmitter.addMaxListeners(obj, 3) - adds three max listeners for all events of 'obj' target
                     * Event.EventEmitter.addMaxListeners(obj, -1) - subtracts one max listener for all events of 'obj' target
                     * Event.EventEmitter.addMaxListeners(obj, 'onClose') - adds one max listener for onClose event of 'obj' target
                     * Event.EventEmitter.addMaxListeners(obj, 'onClose', 2) - adds two max listeners for onClose event of 'obj' target
                     * Event.EventEmitter.addMaxListeners(obj, 'onClose', -1) - subtracts one max listener for onClose event of 'obj' target
                     * @param args
                     * @returns {number}
                     */

                }, {
                    key: "incrementMaxListeners",

                    /**
                     * Increases max listeners count
                     * this.incrementMaxListeners() - adds one max listener for all events
                     * this.incrementMaxListeners(3) - adds three max listeners for all events
                     * this.incrementMaxListeners('onClose') - adds one max listener for onClose event
                     * this.incrementMaxListeners('onClose', 2) - adds two max listeners for onClose event
                     */
                    value: function incrementMaxListeners() {
                        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                            args[_key2] = arguments[_key2];
                        }

                        return EventEmitter.incrementMaxListeners.apply(EventEmitter, [this].concat(args));
                    }
                    /**
                     * Decreases max listeners count
                     *
                     * Event.EventEmitter.decrementMaxListeners() - subtracts one max listener for all events of global target
                     * Event.EventEmitter.decrementMaxListeners(3) - subtracts three max listeners for all events of global target
                     * Event.EventEmitter.decrementMaxListeners('onClose') - subtracts one max listener for onClose event of global target
                     * Event.EventEmitter.decrementMaxListeners('onClose', 2) - subtracts two max listeners for onClose event of global target
                     *
                     * Event.EventEmitter.decrementMaxListeners(obj) - subtracts one max listener for all events of 'obj' target
                     * Event.EventEmitter.decrementMaxListeners(obj, 3) - subtracts three max listeners for all events of 'obj' target
                     * Event.EventEmitter.decrementMaxListeners(obj, 'onClose') - subtracts one max listener for onClose event of 'obj' target
                     * Event.EventEmitter.decrementMaxListeners(obj, 'onClose', 2) - subtracts two max listeners for onClose event of 'obj' target
                     */

                }, {
                    key: "decrementMaxListeners",

                    /**
                     * Increases max listeners count
                     * this.decrementMaxListeners() - subtracts one max listener for all events
                     * this.decrementMaxListeners(3) - subtracts three max listeners for all events
                     * this.decrementMaxListeners('onClose') - subtracts one max listener for onClose event
                     * this.decrementMaxListeners('onClose', 2) - subtracts two max listeners for onClose event
                     */
                    value: function decrementMaxListeners() {
                        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                            args[_key3] = arguments[_key3];
                        }

                        return EventEmitter.decrementMaxListeners.apply(EventEmitter, [this].concat(args));
                    }
                    /**
                     * @private
                     * @param {Array} args
                     * @returns Array
                     */

                }, {
                    key: "getListeners",

                    /**
                     * Gets listeners list for specified event
                     * @param {string} eventName
                     */
                    value: function getListeners(eventName) {
                        return EventEmitter.getListeners(this, eventName);
                    }
                    /**
                     * Returns a full event name with namespace
                     * @param {string} eventName
                     * @returns {string}
                     */

                }, {
                    key: "getFullEventName",
                    value: function getFullEventName(eventName) {
                        if (!Type.isStringFilled(eventName)) {
                            throw new TypeError("The \"eventName\" argument must be a string.");
                        }

                        return EventEmitter.makeFullEventName(this.getEventNamespace(), eventName);
                    }
                    /**
                     * Registers aliases (old event names for BX.onCustomEvent)
                     * @param aliases
                     */

                }], [{
                    key: "makeObservable",
                    value: function makeObservable(target, namespace) {
                        if (!Type.isObject(target)) {
                            throw new TypeError('The "target" argument must be an object.');
                        }

                        if (!Type.isStringFilled(namespace)) {
                            throw new TypeError('The "namespace" must be an non-empty string.');
                        }

                        if (EventEmitter.isEventEmitter(target)) {
                            throw new TypeError('The "target" is an event emitter already.');
                        }

                        var targetProto = Object.getPrototypeOf(target);
                        var emitter = new EventEmitter();
                        emitter.setEventNamespace(namespace);
                        Object.setPrototypeOf(emitter, targetProto);
                        Object.setPrototypeOf(target, emitter);
                        Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function (method) {
                            if (['constructor'].includes(method)) {
                                return;
                            }

                            emitter[method] = function () {
                                for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                                    args[_key4] = arguments[_key4];
                                }

                                return EventEmitter.prototype[method].apply(target, args);
                            };
                        });
                    }
                }, {
                    key: "subscribe",
                    value: function subscribe(target, eventName, listener, options) {
                        if (Type.isString(target)) {
                            options = listener;
                            listener = eventName;
                            eventName = target;
                            target = this.GLOBAL_TARGET;
                        }

                        if (!Type.isObject(target)) {
                            throw new TypeError("The \"target\" argument must be an object.");
                        }

                        eventName = this.normalizeEventName(eventName);

                        if (!Type.isStringFilled(eventName)) {
                            throw new TypeError("The \"eventName\" argument must be a string.");
                        }

                        if (!Type.isFunction(listener)) {
                            throw new TypeError("The \"listener\" argument must be of type Function. Received type ".concat(babelHelpers.typeof(listener), "."));
                        }

                        options = Type.isPlainObject(options) ? options : {};
                        var fullEventName = this.resolveEventName(eventName, target, options.useGlobalNaming === true);

                        var _eventStore$getOrAdd = eventStore.getOrAdd(target),
                            eventsMap = _eventStore$getOrAdd.eventsMap,
                            onceMap = _eventStore$getOrAdd.onceMap;

                        var onceListeners = onceMap.get(fullEventName);
                        var listeners = eventsMap.get(fullEventName);

                        if (listeners && listeners.has(listener) || onceListeners && onceListeners.has(listener)) {
                            console.error("You cannot subscribe the same \"".concat(fullEventName, "\" event listener twice."));
                        } else {
                            if (listeners) {
                                listeners.set(listener, {
                                    listener: listener,
                                    options: options,
                                    sort: this.getNextSequenceValue()
                                });
                            } else {
                                listeners = new Map([[listener, {
                                    listener: listener,
                                    options: options,
                                    sort: this.getNextSequenceValue()
                                }]]);
                                eventsMap.set(fullEventName, listeners);
                            }
                        }

                        var maxListeners = this.getMaxListeners(target, eventName);

                        if (listeners.size > maxListeners) {
                            warningStore.add(target, fullEventName, listeners);
                            warningStore.printDelayed();
                        }
                    }
                }, {
                    key: "subscribeOnce",
                    value: function subscribeOnce(target, eventName, listener) {
                        var _this3 = this;

                        if (Type.isString(target)) {
                            listener = eventName;
                            eventName = target;
                            target = this.GLOBAL_TARGET;
                        }

                        if (!Type.isObject(target)) {
                            throw new TypeError("The \"target\" argument must be an object.");
                        }

                        eventName = this.normalizeEventName(eventName);

                        if (!Type.isStringFilled(eventName)) {
                            throw new TypeError("The \"eventName\" argument must be a string.");
                        }

                        if (!Type.isFunction(listener)) {
                            throw new TypeError("The \"listener\" argument must be of type Function. Received type ".concat(babelHelpers.typeof(listener), "."));
                        }

                        var fullEventName = this.resolveEventName(eventName, target);

                        var _eventStore$getOrAdd2 = eventStore.getOrAdd(target),
                            eventsMap = _eventStore$getOrAdd2.eventsMap,
                            onceMap = _eventStore$getOrAdd2.onceMap;

                        var listeners = eventsMap.get(fullEventName);
                        var onceListeners = onceMap.get(fullEventName);

                        if (listeners && listeners.has(listener) || onceListeners && onceListeners.has(listener)) {
                            console.error("You cannot subscribe the same \"".concat(fullEventName, "\" event listener twice."));
                        } else {
                            var once = function once() {
                                _this3.unsubscribe(target, eventName, once);

                                onceListeners.delete(listener);
                                listener.apply(void 0, arguments);
                            };

                            if (onceListeners) {
                                onceListeners.set(listener, once);
                            } else {
                                onceListeners = new Map([[listener, once]]);
                                onceMap.set(fullEventName, onceListeners);
                            }

                            this.subscribe(target, eventName, once);
                        }
                    }
                }, {
                    key: "unsubscribe",
                    value: function unsubscribe(target, eventName, listener, options) {
                        if (Type.isString(target)) {
                            listener = eventName;
                            eventName = target;
                            target = this.GLOBAL_TARGET;
                        }

                        eventName = this.normalizeEventName(eventName);

                        if (!Type.isStringFilled(eventName)) {
                            throw new TypeError("The \"eventName\" argument must be a string.");
                        }

                        if (!Type.isFunction(listener)) {
                            throw new TypeError("The \"listener\" argument must be of type Function. Received type ".concat(typeof event === "undefined" ? "undefined" : babelHelpers.typeof(event), "."));
                        }

                        options = Type.isPlainObject(options) ? options : {};
                        var fullEventName = this.resolveEventName(eventName, target, options.useGlobalNaming === true);
                        var targetInfo = eventStore.get(target);
                        var listeners = targetInfo && targetInfo.eventsMap.get(fullEventName);
                        var onceListeners = targetInfo && targetInfo.onceMap.get(fullEventName);

                        if (listeners) {
                            listeners.delete(listener);
                        }

                        if (onceListeners) {
                            var once = onceListeners.get(listener);

                            if (once) {
                                onceListeners.delete(listener);
                                listeners.delete(once);
                            }
                        }
                    }
                }, {
                    key: "unsubscribeAll",
                    value: function unsubscribeAll(target, eventName, options) {
                        if (Type.isString(target)) {
                            eventName = target;
                            target = this.GLOBAL_TARGET;
                        }

                        if (Type.isStringFilled(eventName)) {
                            var targetInfo = eventStore.get(target);

                            if (targetInfo) {
                                options = Type.isPlainObject(options) ? options : {};
                                var fullEventName = this.resolveEventName(eventName, target, options.useGlobalNaming === true);
                                targetInfo.eventsMap.delete(fullEventName);
                                targetInfo.onceMap.delete(fullEventName);
                            }
                        } else if (Type.isNil(eventName)) {
                            if (target === this.GLOBAL_TARGET) {
                                console.error('You cannot unsubscribe all global listeners.');
                            } else {
                                eventStore.delete(target);
                            }
                        }
                    }
                }, {
                    key: "emit",
                    value: function emit(target, eventName, event, options) {
                        if (Type.isString(target)) {
                            options = event;
                            event = eventName;
                            eventName = target;
                            target = this.GLOBAL_TARGET;
                        }

                        if (!Type.isObject(target)) {
                            throw new TypeError("The \"target\" argument must be an object.");
                        }

                        eventName = this.normalizeEventName(eventName);

                        if (!Type.isStringFilled(eventName)) {
                            throw new TypeError("The \"eventName\" argument must be a string.");
                        }

                        options = Type.isPlainObject(options) ? options : {};
                        var fullEventName = this.resolveEventName(eventName, target, options.useGlobalNaming === true);
                        var globalEvents = eventStore.get(this.GLOBAL_TARGET);
                        var globalListeners = globalEvents && globalEvents.eventsMap.get(fullEventName) || new Map();
                        var targetListeners = new Set();

                        if (target !== this.GLOBAL_TARGET) {
                            var targetEvents = eventStore.get(target);
                            targetListeners = targetEvents && targetEvents.eventsMap.get(fullEventName) || new Map();
                        }

                        var listeners = [].concat(babelHelpers.toConsumableArray(globalListeners.values()), babelHelpers.toConsumableArray(targetListeners.values()));
                        listeners.sort(function (a, b) {
                            return a.sort - b.sort;
                        });
                        var preparedEvent = this.prepareEvent(target, fullEventName, event);
                        var result = [];

                        for (var i = 0; i < listeners.length; i++) {
                            if (preparedEvent.isImmediatePropagationStopped()) {
                                break;
                            }

                            var _listeners$i = listeners[i],
                                listener = _listeners$i.listener,
                                listenerOptions = _listeners$i.options; //A previous listener could remove a current listener.

                            if (globalListeners.has(listener) || targetListeners.has(listener)) {
                                var listenerResult = void 0;

                                if (listenerOptions.compatMode) {
                                    var params = [];
                                    var compatData = preparedEvent.getCompatData();

                                    if (compatData !== null) {
                                        params = options.cloneData === true ? Runtime.clone(compatData) : compatData;
                                    } else {
                                        params = [preparedEvent];
                                    }

                                    var context = Type.isUndefined(options.thisArg) ? target : options.thisArg;
                                    listenerResult = listener.apply(context, params);
                                } else {
                                    listenerResult = Type.isUndefined(options.thisArg) ? listener(preparedEvent) : listener.call(options.thisArg, preparedEvent);
                                }

                                result.push(listenerResult);
                            }
                        }

                        return result;
                    }
                }, {
                    key: "emitAsync",
                    value: function emitAsync(target, eventName, event) {
                        if (Type.isString(target)) {
                            event = eventName;
                            eventName = target;
                            target = this.GLOBAL_TARGET;
                        }

                        return Promise.all(this.emit(target, eventName, event));
                    }
                }, {
                    key: "prepareEvent",
                    value: function prepareEvent(target, eventName, event) {
                        var preparedEvent = event;

                        if (!(event instanceof BaseEvent)) {
                            preparedEvent = new BaseEvent();
                            preparedEvent.setData(event);
                        }

                        preparedEvent.setTarget(this.isEventEmitter(target) ? target[targetProperty] : target);
                        preparedEvent.setType(eventName);
                        return preparedEvent;
                    }
                    /**
                     * @private
                     * @returns {number}
                     */

                }, {
                    key: "getNextSequenceValue",
                    value: function getNextSequenceValue() {
                        return this.sequenceValue++;
                    }
                    /**
                     * Sets max global events listeners count
                     * Event.EventEmitter.setMaxListeners(10) - sets the default value for all events (global target)
                     * Event.EventEmitter.setMaxListeners("onClose", 10) - sets the value for onClose event (global target)
                     * Event.EventEmitter.setMaxListeners(obj, 10) - sets the default value for all events (obj target)
                     * Event.EventEmitter.setMaxListeners(obj, "onClose", 10); - sets the value for onClose event (obj target)
                     * @return {void}
                     * @param args
                     */

                }, {
                    key: "setMaxListeners",
                    value: function setMaxListeners() {
                        var target = this.GLOBAL_TARGET;
                        var eventName = null;
                        var count = undefined;

                        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                            args[_key5] = arguments[_key5];
                        }

                        if (args.length === 1) {
                            count = args[0];
                        } else if (args.length === 2) {
                            if (Type.isString(args[0])) {
                                eventName = args[0];
                                count = args[1];
                            } else {
                                target = args[0];
                                count = args[1];
                            }
                        } else if (args.length >= 3) {
                            target = args[0];
                            eventName = args[1];
                            count = args[2];
                        }

                        if (!Type.isObject(target)) {
                            throw new TypeError("The \"target\" argument must be an object.");
                        }

                        if (eventName !== null && !Type.isStringFilled(eventName)) {
                            throw new TypeError("The \"eventName\" argument must be a string.");
                        }

                        if (!Type.isNumber(count) || count < 0) {
                            throw new TypeError("The value of \"count\" is out of range. It must be a non-negative number. Received ".concat(count, "."));
                        }

                        var targetInfo = eventStore.getOrAdd(target);

                        if (Type.isStringFilled(eventName)) {
                            var fullEventName = this.resolveEventName(eventName, target);
                            targetInfo.eventsMaxListeners.set(fullEventName, count);
                        } else {
                            targetInfo.maxListeners = count;
                        }
                    }
                }, {
                    key: "getMaxListeners",
                    value: function getMaxListeners(target, eventName) {
                        if (Type.isString(target)) {
                            eventName = target;
                            target = this.GLOBAL_TARGET;
                        } else if (Type.isNil(target)) {
                            target = this.GLOBAL_TARGET;
                        }

                        if (!Type.isObject(target)) {
                            throw new TypeError("The \"target\" argument must be an object.");
                        }

                        var targetInfo = eventStore.get(target);

                        if (targetInfo) {
                            var maxListeners = targetInfo.maxListeners;

                            if (Type.isStringFilled(eventName)) {
                                var fullEventName = this.resolveEventName(eventName, target);
                                maxListeners = targetInfo.eventsMaxListeners.get(fullEventName) || maxListeners;
                            }

                            return maxListeners;
                        }

                        return this.DEFAULT_MAX_LISTENERS;
                    }
                }, {
                    key: "addMaxListeners",
                    value: function addMaxListeners() {
                        var _this$destructMaxList = this.destructMaxListenersArgs.apply(this, arguments),
                            _this$destructMaxList2 = babelHelpers.slicedToArray(_this$destructMaxList, 3),
                            target = _this$destructMaxList2[0],
                            eventName = _this$destructMaxList2[1],
                            increment = _this$destructMaxList2[2];

                        var maxListeners = Math.max(this.getMaxListeners(target, eventName) + increment, 0);

                        if (Type.isStringFilled(eventName)) {
                            EventEmitter.setMaxListeners(target, eventName, maxListeners);
                        } else {
                            EventEmitter.setMaxListeners(target, maxListeners);
                        }

                        return maxListeners;
                    }
                    /**
                     * Increases max listeners count
                     *
                     * Event.EventEmitter.incrementMaxListeners() - adds one max listener for all events of global target
                     * Event.EventEmitter.incrementMaxListeners(3) - adds three max listeners for all events of global target
                     * Event.EventEmitter.incrementMaxListeners('onClose') - adds one max listener for onClose event of global target
                     * Event.EventEmitter.incrementMaxListeners('onClose', 2) - adds two max listeners for onClose event of global target
                     *
                     * Event.EventEmitter.incrementMaxListeners(obj) - adds one max listener for all events of 'obj' target
                     * Event.EventEmitter.incrementMaxListeners(obj, 3) - adds three max listeners for all events of 'obj' target
                     * Event.EventEmitter.incrementMaxListeners(obj, 'onClose') - adds one max listener for onClose event of 'obj' target
                     * Event.EventEmitter.incrementMaxListeners(obj, 'onClose', 2) - adds two max listeners for onClose event of 'obj' target
                     */

                }, {
                    key: "incrementMaxListeners",
                    value: function incrementMaxListeners() {
                        var _this$destructMaxList3 = this.destructMaxListenersArgs.apply(this, arguments),
                            _this$destructMaxList4 = babelHelpers.slicedToArray(_this$destructMaxList3, 3),
                            target = _this$destructMaxList4[0],
                            eventName = _this$destructMaxList4[1],
                            increment = _this$destructMaxList4[2];

                        return this.addMaxListeners(target, eventName, Math.abs(increment));
                    }
                }, {
                    key: "decrementMaxListeners",
                    value: function decrementMaxListeners() {
                        var _this$destructMaxList5 = this.destructMaxListenersArgs.apply(this, arguments),
                            _this$destructMaxList6 = babelHelpers.slicedToArray(_this$destructMaxList5, 3),
                            target = _this$destructMaxList6[0],
                            eventName = _this$destructMaxList6[1],
                            increment = _this$destructMaxList6[2];

                        return this.addMaxListeners(target, eventName, -Math.abs(increment));
                    }
                }, {
                    key: "destructMaxListenersArgs",
                    value: function destructMaxListenersArgs() {
                        var eventName = null;
                        var increment = 1;
                        var target = this.GLOBAL_TARGET;

                        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
                            args[_key6] = arguments[_key6];
                        }

                        if (args.length === 1) {
                            if (Type.isNumber(args[0])) {
                                increment = args[0];
                            } else if (Type.isString(args[0])) {
                                eventName = args[0];
                            } else {
                                target = args[0];
                            }
                        } else if (args.length === 2) {
                            if (Type.isString(args[0])) {
                                eventName = args[0];
                                increment = args[1];
                            } else if (Type.isString(args[1])) {
                                target = args[0];
                                eventName = args[1];
                            } else {
                                target = args[0];
                                increment = args[1];
                            }
                        } else if (args.length >= 3) {
                            target = args[0];
                            eventName = args[1];
                            increment = args[2];
                        }

                        if (!Type.isObject(target)) {
                            throw new TypeError("The \"target\" argument must be an object.");
                        }

                        if (eventName !== null && !Type.isStringFilled(eventName)) {
                            throw new TypeError("The \"eventName\" argument must be a string.");
                        }

                        if (!Type.isNumber(increment)) {
                            throw new TypeError("The value of \"increment\" must be a number.");
                        }

                        return [target, eventName, increment];
                    }
                    /**
                     * Gets listeners list for a specified event
                     * @param {object} target
                     * @param {string} eventName
                     */

                }, {
                    key: "getListeners",
                    value: function getListeners(target, eventName) {
                        if (Type.isString(target)) {
                            eventName = target;
                            target = this.GLOBAL_TARGET;
                        }

                        if (!Type.isObject(target)) {
                            throw new TypeError("The \"target\" argument must be an object.");
                        }

                        eventName = this.normalizeEventName(eventName);

                        if (!Type.isStringFilled(eventName)) {
                            throw new TypeError("The \"eventName\" argument must be a string.");
                        }

                        var targetInfo = eventStore.get(target);

                        if (!targetInfo) {
                            return new Map();
                        }

                        var fullEventName = this.resolveEventName(eventName, target);
                        return targetInfo.eventsMap.get(fullEventName) || new Map();
                    }
                }, {
                    key: "registerAliases",
                    value: function registerAliases(aliases) {
                        aliases = this.normalizeAliases(aliases);
                        Object.keys(aliases).forEach(function (alias) {
                            aliasStore.set(alias, {
                                eventName: aliases[alias].eventName,
                                namespace: aliases[alias].namespace
                            });
                        });
                        EventEmitter.mergeEventAliases(aliases);
                    }
                    /**
                     * @private
                     * @param aliases
                     */

                }, {
                    key: "normalizeAliases",
                    value: function normalizeAliases(aliases) {
                        if (!Type.isPlainObject(aliases)) {
                            throw new TypeError("The \"aliases\" argument must be an object.");
                        }

                        var result = Object.create(null);

                        for (var _alias in aliases) {
                            if (!Type.isStringFilled(_alias)) {
                                throw new TypeError("The alias must be an non-empty string.");
                            }

                            var options = aliases[_alias];

                            if (!options || !Type.isStringFilled(options.eventName) || !Type.isStringFilled(options.namespace)) {
                                throw new TypeError("The alias options must set the \"eventName\" and the \"namespace\".");
                            }

                            _alias = this.normalizeEventName(_alias);
                            result[_alias] = {
                                eventName: options.eventName,
                                namespace: options.namespace
                            };
                        }

                        return result;
                    }
                    /**
                     * @private
                     */

                }, {
                    key: "mergeEventAliases",
                    value: function mergeEventAliases(aliases) {
                        var _this4 = this;

                        var globalEvents = eventStore.get(this.GLOBAL_TARGET);

                        if (!globalEvents) {
                            return;
                        }

                        Object.keys(aliases).forEach(function (alias) {
                            var options = aliases[alias];
                            alias = _this4.normalizeEventName(alias);

                            var fullEventName = _this4.makeFullEventName(options.namespace, options.eventName);

                            var aliasListeners = globalEvents.eventsMap.get(alias);

                            if (aliasListeners) {
                                var listeners = globalEvents.eventsMap.get(fullEventName) || new Map();
                                globalEvents.eventsMap.set(fullEventName, new Map([].concat(babelHelpers.toConsumableArray(listeners), babelHelpers.toConsumableArray(aliasListeners))));
                                globalEvents.eventsMap.delete(alias);
                            }

                            var aliasOnceListeners = globalEvents.onceMap.get(alias);

                            if (aliasOnceListeners) {
                                var onceListeners = globalEvents.onceMap.get(fullEventName) || new Map();
                                globalEvents.onceMap.set(fullEventName, new Map([].concat(babelHelpers.toConsumableArray(onceListeners), babelHelpers.toConsumableArray(aliasOnceListeners))));
                                globalEvents.onceMap.delete(alias);
                            }

                            var aliasMaxListeners = globalEvents.eventsMaxListeners.get(alias);

                            if (aliasMaxListeners) {
                                var eventMaxListeners = globalEvents.eventsMaxListeners.get(fullEventName) || 0;
                                globalEvents.eventsMaxListeners.set(fullEventName, Math.max(eventMaxListeners, aliasMaxListeners));
                                globalEvents.eventsMaxListeners.delete(alias);
                            }
                        });
                    }
                    /**
                     * Returns true if the target is an instance of Event.EventEmitter
                     * @param {object} target
                     * @returns {boolean}
                     */

                }, {
                    key: "isEventEmitter",
                    value: function isEventEmitter(target) {
                        return Type.isObject(target) && target[isEmitterProperty] === true;
                    }
                    /**
                     * @private
                     * @param {string} eventName
                     * @returns {string}
                     */

                }, {
                    key: "normalizeEventName",
                    value: function normalizeEventName(eventName) {
                        if (!Type.isStringFilled(eventName)) {
                            return '';
                        }

                        return eventName.toLowerCase();
                    }
                    /**
                     * @private
                     * @param eventName
                     * @param target
                     * @param useGlobalNaming
                     * @returns {string}
                     */

                }, {
                    key: "resolveEventName",
                    value: function resolveEventName(eventName, target) {
                        var useGlobalNaming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                        eventName = this.normalizeEventName(eventName);

                        if (!Type.isStringFilled(eventName)) {
                            return '';
                        }

                        if (this.isEventEmitter(target) && useGlobalNaming !== true) {
                            if (target.getEventNamespace() !== null && eventName.includes('.')) {
                                console.warn("Possible the wrong event name \"".concat(eventName, "\"."));
                            }

                            eventName = target.getFullEventName(eventName);
                        } else if (aliasStore.has(eventName)) {
                            var _aliasStore$get = aliasStore.get(eventName),
                                namespace = _aliasStore$get.namespace,
                                actualEventName = _aliasStore$get.eventName;

                            eventName = this.makeFullEventName(namespace, actualEventName);
                        }

                        return eventName;
                    }
                    /**
                     * @private
                     * @param {string} namespace
                     * @param {string} eventName
                     * @returns {string}
                     */

                }, {
                    key: "makeFullEventName",
                    value: function makeFullEventName(namespace, eventName) {
                        var fullName = Type.isStringFilled(namespace) ? "".concat(namespace, ":").concat(eventName) : eventName;
                        return Type.isStringFilled(fullName) ? fullName.toLowerCase() : '';
                    }
                }]);
                return EventEmitter;
            }();

        babelHelpers.defineProperty(EventEmitter, "GLOBAL_TARGET", globalTarget);
        babelHelpers.defineProperty(EventEmitter, "DEFAULT_MAX_LISTENERS", eventStore.getDefaultMaxListeners());
        babelHelpers.defineProperty(EventEmitter, "sequenceValue", 1);

        var stack = [];
        /**
         * For compatibility only
         * @type {boolean}
         */
        // eslint-disable-next-line

        exports.isReady = false;
        function ready(handler) {
            switch (document.readyState) {
                case 'loading':
                    stack.push(handler);
                    break;

                case 'interactive':
                case 'complete':
                    if (Type.isFunction(handler)) {
                        handler();
                    }

                    exports.isReady = true;
                    break;
            }
        }
        document.addEventListener('readystatechange', function () {
            if (!exports.isReady) {
                stack.forEach(ready);
                stack = [];
            }
        });

        /**
         * @memberOf BX
         */

        var Event = function Event() {
            babelHelpers.classCallCheck(this, Event);
        };

        babelHelpers.defineProperty(Event, "bind", bind);
        babelHelpers.defineProperty(Event, "bindOnce", bindOnce);
        babelHelpers.defineProperty(Event, "unbind", unbind);
        babelHelpers.defineProperty(Event, "unbindAll", unbindAll);
        babelHelpers.defineProperty(Event, "ready", ready);
        babelHelpers.defineProperty(Event, "EventEmitter", EventEmitter);
        babelHelpers.defineProperty(Event, "BaseEvent", BaseEvent);

        function encodeAttributeValue(value) {
            if (Type.isPlainObject(value) || Type.isArray(value)) {
                return JSON.stringify(value);
            }

            return Text.encode(Text.decode(value));
        }

        function decodeAttributeValue(value) {
            if (Type.isString(value)) {
                var decodedValue = Text.decode(value);
                var result;

                try {
                    result = JSON.parse(decodedValue);
                } catch (e) {
                    result = decodedValue;
                }

                if (result === decodedValue) {
                    if (/^[\d.]+[.]?\d+$/.test(result)) {
                        return Number(result);
                    }
                }

                if (result === 'true' || result === 'false') {
                    return Boolean(result);
                }

                return result;
            }

            return value;
        }

        function getPageScroll() {
            var _document = document,
                documentElement = _document.documentElement,
                body = _document.body;
            var scrollTop = Math.max(window.pageYOffset || 0, documentElement ? documentElement.scrollTop : 0, body ? body.scrollTop : 0);
            var scrollLeft = Math.max(window.pageXOffset || 0, documentElement ? documentElement.scrollLeft : 0, body ? body.scrollLeft : 0);
            return {
                scrollTop: scrollTop,
                scrollLeft: scrollLeft
            };
        }

        /**
         * @memberOf BX
         */

        var Dom =
            /*#__PURE__*/
            function () {
                function Dom() {
                    babelHelpers.classCallCheck(this, Dom);
                }

                babelHelpers.createClass(Dom, null, [{
                    key: "replace",

                    /**
                     * Replaces old html element to new html element
                     * @param oldElement
                     * @param newElement
                     */
                    value: function replace(oldElement, newElement) {
                        if (Type.isDomNode(oldElement) && Type.isDomNode(newElement)) {
                            if (Type.isDomNode(oldElement.parentNode)) {
                                oldElement.parentNode.replaceChild(newElement, oldElement);
                            }
                        }
                    }
                    /**
                     * Removes element
                     * @param element
                     */

                }, {
                    key: "remove",
                    value: function remove(element) {
                        if (Type.isDomNode(element) && Type.isDomNode(element.parentNode)) {
                            element.parentNode.removeChild(element);
                        }
                    }
                    /**
                     * Cleans element
                     * @param element
                     */

                }, {
                    key: "clean",
                    value: function clean(element) {
                        if (Type.isDomNode(element)) {
                            while (element.childNodes.length > 0) {
                                element.removeChild(element.firstChild);
                            }

                            return;
                        }

                        if (Type.isString(element)) {
                            Dom.clean(document.getElementById(element));
                        }
                    }
                    /**
                     * Inserts element before target element
                     * @param current
                     * @param target
                     */

                }, {
                    key: "insertBefore",
                    value: function insertBefore(current, target) {
                        if (Type.isDomNode(current) && Type.isDomNode(target)) {
                            if (Type.isDomNode(target.parentNode)) {
                                target.parentNode.insertBefore(current, target);
                            }
                        }
                    }
                    /**
                     * Inserts element after target element
                     * @param current
                     * @param target
                     */

                }, {
                    key: "insertAfter",
                    value: function insertAfter(current, target) {
                        if (Type.isDomNode(current) && Type.isDomNode(target)) {
                            if (Type.isDomNode(target.parentNode)) {
                                var parent = target.parentNode;

                                if (Type.isDomNode(target.nextSibling)) {
                                    parent.insertBefore(current, target.nextSibling);
                                    return;
                                }

                                parent.appendChild(current);
                            }
                        }
                    }
                    /**
                     * Appends element to target element
                     * @param current
                     * @param target
                     */

                }, {
                    key: "append",
                    value: function append(current, target) {
                        if (Type.isDomNode(current) && Type.isDomNode(target)) {
                            target.appendChild(current);
                        }
                    }
                    /**
                     * Prepends element to target element
                     * @param current
                     * @param target
                     */

                }, {
                    key: "prepend",
                    value: function prepend(current, target) {
                        if (Type.isDomNode(current) && Type.isDomNode(target)) {
                            if (Type.isDomNode(target.firstChild)) {
                                target.insertBefore(current, target.firstChild);
                                return;
                            }

                            Dom.append(current, target);
                        }
                    }
                    /**
                     * Checks that element contains class name or class names
                     * @param element
                     * @param className
                     * @return {Boolean}
                     */

                }, {
                    key: "hasClass",
                    value: function hasClass(element, className) {
                        if (Type.isElementNode(element)) {
                            if (Type.isString(className)) {
                                var preparedClassName = className.trim();

                                if (preparedClassName.length > 0) {
                                    if (preparedClassName.includes(' ')) {
                                        return preparedClassName.split(' ').every(function (name) {
                                            return Dom.hasClass(element, name);
                                        });
                                    }

                                    if ('classList' in element) {
                                        return element.classList.contains(preparedClassName);
                                    }

                                    if (Type.isObject(element.className) && Type.isString(element.className.baseVal)) {
                                        return element.getAttribute('class').split(' ').some(function (name) {
                                            return name === preparedClassName;
                                        });
                                    }
                                }
                            }

                            if (Type.isArray(className) && className.length > 0) {
                                return className.every(function (name) {
                                    return Dom.hasClass(element, name);
                                });
                            }
                        }

                        return false;
                    }
                    /**
                     * Adds class name
                     * @param element
                     * @param className
                     */

                }, {
                    key: "addClass",
                    value: function addClass(element, className) {
                        if (Type.isElementNode(element)) {
                            if (Type.isString(className)) {
                                var preparedClassName = className.trim();

                                if (preparedClassName.length > 0) {
                                    if (preparedClassName.includes(' ')) {
                                        Dom.addClass(element, preparedClassName.split(' '));
                                        return;
                                    }

                                    if ('classList' in element) {
                                        element.classList.add(preparedClassName);
                                        return;
                                    }

                                    if (Type.isObject(element.className) && Type.isString(element.className.baseVal)) {
                                        if (element.className.baseVal === '') {
                                            element.className.baseVal = preparedClassName;
                                            return;
                                        }

                                        var names = element.className.baseVal.split(' ');

                                        if (!names.includes(preparedClassName)) {
                                            names.push(preparedClassName);
                                            element.className.baseVal = names.join(' ').trim();
                                            return;
                                        }
                                    }

                                    return;
                                }
                            }

                            if (Type.isArray(className)) {
                                className.forEach(function (name) {
                                    return Dom.addClass(element, name);
                                });
                            }
                        }
                    }
                    /**
                     * Removes class name
                     * @param element
                     * @param className
                     */

                }, {
                    key: "removeClass",
                    value: function removeClass(element, className) {
                        if (Type.isElementNode(element)) {
                            if (Type.isString(className)) {
                                var preparedClassName = className.trim();

                                if (preparedClassName.length > 0) {
                                    if (preparedClassName.includes(' ')) {
                                        Dom.removeClass(element, preparedClassName.split(' '));
                                        return;
                                    }

                                    if ('classList' in element) {
                                        element.classList.remove(preparedClassName);
                                        return;
                                    }

                                    if (Type.isObject(element.className) && Type.isString(element.className.baseVal)) {
                                        var names = element.className.baseVal.split(' ').filter(function (name) {
                                            return name !== preparedClassName;
                                        });
                                        element.className.baseVal = names.join(' ');
                                        return;
                                    }
                                }
                            }

                            if (Type.isArray(className)) {
                                className.forEach(function (name) {
                                    return Dom.removeClass(element, name);
                                });
                            }
                        }
                    }
                    /**
                     * Toggles class name
                     * @param element
                     * @param className
                     */

                }, {
                    key: "toggleClass",
                    value: function toggleClass(element, className) {
                        if (Type.isElementNode(element)) {
                            if (Type.isString(className)) {
                                var preparedClassName = className.trim();

                                if (preparedClassName.length > 0) {
                                    if (preparedClassName.includes(' ')) {
                                        Dom.toggleClass(element, preparedClassName.split(' '));
                                        return;
                                    }

                                    element.classList.toggle(preparedClassName);
                                    return;
                                }
                            }

                            if (Type.isArray(className)) {
                                className.forEach(function (name) {
                                    return Dom.toggleClass(element, name);
                                });
                            }
                        }
                    }
                    /**
                     * Styles element
                     */

                }, {
                    key: "style",
                    value: function style(element, prop, value) {
                        if (Type.isElementNode(element)) {
                            if (Type.isNull(prop)) {
                                element.removeAttribute('style');
                                return element;
                            }

                            if (Type.isPlainObject(prop)) {
                                Object.entries(prop).forEach(function (item) {
                                    var _item = babelHelpers.slicedToArray(item, 2),
                                        currentKey = _item[0],
                                        currentValue = _item[1];

                                    Dom.style(element, currentKey, currentValue);
                                });
                                return element;
                            }

                            if (Type.isString(prop)) {
                                if (Type.isUndefined(value) && element.nodeType !== Node.DOCUMENT_NODE) {
                                    var computedStyle = getComputedStyle(element);

                                    if (prop in computedStyle) {
                                        return computedStyle[prop];
                                    }

                                    return computedStyle.getPropertyValue(prop);
                                }

                                if (Type.isNull(value) || value === '' || value === 'null') {
                                    // eslint-disable-next-line
                                    element.style[prop] = '';
                                    return element;
                                }

                                if (Type.isString(value) || Type.isNumber(value)) {
                                    // eslint-disable-next-line
                                    element.style[prop] = value;
                                    return element;
                                }
                            }
                        }

                        return null;
                    }
                    /**
                     * Adjusts element
                     * @param target
                     * @param data
                     * @return {*}
                     */

                }, {
                    key: "adjust",
                    value: function adjust(target) {
                        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

                        if (!target.nodeType) {
                            return null;
                        }

                        var element = target;

                        if (target.nodeType === Node.DOCUMENT_NODE) {
                            element = target.body;
                        }

                        if (Type.isPlainObject(data)) {
                            if (Type.isPlainObject(data.attrs)) {
                                Object.keys(data.attrs).forEach(function (key) {
                                    if (key === 'class' || key.toLowerCase() === 'classname') {
                                        element.className = data.attrs[key];
                                        return;
                                    } // eslint-disable-next-line


                                    if (data.attrs[key] == '') {
                                        element.removeAttribute(key);
                                        return;
                                    }

                                    element.setAttribute(key, data.attrs[key]);
                                });
                            }

                            if (Type.isPlainObject(data.style)) {
                                Dom.style(element, data.style);
                            }

                            if (Type.isPlainObject(data.props)) {
                                Object.keys(data.props).forEach(function (key) {
                                    element[key] = data.props[key];
                                });
                            }

                            if (Type.isPlainObject(data.events)) {
                                Object.keys(data.events).forEach(function (key) {
                                    Event.bind(element, key, data.events[key]);
                                });
                            }

                            if (Type.isPlainObject(data.dataset)) {
                                Object.keys(data.dataset).forEach(function (key) {
                                    element.dataset[key] = data.dataset[key];
                                });
                            }

                            if (Type.isString(data.children)) {
                                data.children = [data.children];
                            }

                            if (Type.isArray(data.children) && data.children.length > 0) {
                                data.children.forEach(function (item) {
                                    if (Type.isDomNode(item)) {
                                        Dom.append(item, element);
                                    }

                                    if (Type.isString(item)) {
                                        element.innerHTML += item;
                                    }
                                });
                                return element;
                            }

                            if ('text' in data && !Type.isNil(data.text)) {
                                element.innerText = data.text;
                                return element;
                            }

                            if ('html' in data && !Type.isNil(data.html)) {
                                element.innerHTML = data.html;
                            }
                        }

                        return element;
                    }
                    /**
                     * Creates element
                     * @param tag
                     * @param data
                     * @param context
                     * @return {HTMLElement|HTMLBodyElement}
                     */

                }, {
                    key: "create",
                    value: function create(tag) {
                        var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                        var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
                        var tagName = tag;
                        var options = data;

                        if (Type.isObjectLike(tag)) {
                            options = tag;
                            tagName = tag.tag;
                        }

                        return Dom.adjust(context.createElement(tagName), options);
                    }
                    /**
                     * Shows element
                     * @param element
                     */

                }, {
                    key: "show",
                    value: function show(element) {
                        if (Type.isDomNode(element)) {
                            // eslint-disable-next-line
                            element.hidden = false;
                        }
                    }
                    /**
                     * Hides element
                     * @param element
                     */

                }, {
                    key: "hide",
                    value: function hide(element) {
                        if (Type.isDomNode(element)) {
                            // eslint-disable-next-line
                            element.hidden = true;
                        }
                    }
                    /**
                     * Checks that element is shown
                     * @param element
                     * @return {*|boolean}
                     */

                }, {
                    key: "isShown",
                    value: function isShown(element) {
                        return Type.isDomNode(element) && !element.hidden && element.style.getPropertyValue('display') !== 'none';
                    }
                    /**
                     * Toggles element visibility
                     * @param element
                     */

                }, {
                    key: "toggle",
                    value: function toggle(element) {
                        if (Type.isDomNode(element)) {
                            if (Dom.isShown(element)) {
                                Dom.hide(element);
                            } else {
                                Dom.show(element);
                            }
                        }
                    }
                    /**
                     * Gets element position relative page
                     * @param {HTMLElement} element
                     * @return {DOMRect}
                     */

                }, {
                    key: "getPosition",
                    value: function getPosition(element) {
                        if (Type.isDomNode(element)) {
                            var elementRect = element.getBoundingClientRect();

                            var _getPageScroll = getPageScroll(),
                                scrollLeft = _getPageScroll.scrollLeft,
                                scrollTop = _getPageScroll.scrollTop;

                            return new DOMRect(elementRect.left + scrollLeft, elementRect.top + scrollTop, elementRect.width, elementRect.height);
                        }

                        return new DOMRect();
                    }
                    /**
                     * Gets element position relative specified element position
                     * @param {HTMLElement} element
                     * @param {HTMLElement} relationElement
                     * @return {DOMRect}
                     */

                }, {
                    key: "getRelativePosition",
                    value: function getRelativePosition(element, relationElement) {
                        if (Type.isDomNode(element) && Type.isDomNode(relationElement)) {
                            var elementPosition = Dom.getPosition(element);
                            var relationElementPosition = Dom.getPosition(relationElement);
                            return new DOMRect(elementPosition.left - relationElementPosition.left, elementPosition.top - relationElementPosition.top, elementPosition.width, elementPosition.height);
                        }

                        return new DOMRect();
                    }
                }, {
                    key: "attr",
                    value: function attr(element, _attr, value) {
                        if (Type.isElementNode(element)) {
                            if (Type.isString(_attr)) {
                                if (!Type.isNil(value)) {
                                    return element.setAttribute(_attr, encodeAttributeValue(value));
                                }

                                if (Type.isNull(value)) {
                                    return element.removeAttribute(_attr);
                                }

                                return decodeAttributeValue(element.getAttribute(_attr));
                            }

                            if (Type.isPlainObject(_attr)) {
                                return Object.entries(_attr).forEach(function (_ref) {
                                    var _ref2 = babelHelpers.slicedToArray(_ref, 2),
                                        attrKey = _ref2[0],
                                        attrValue = _ref2[1];

                                    Dom.attr(element, attrKey, attrValue);
                                });
                            }
                        }

                        return null;
                    }
                }]);
                return Dom;
            }();

        var UA = navigator.userAgent.toLowerCase();
        /**
         * @memberOf BX
         */

        var Browser =
            /*#__PURE__*/
            function () {
                function Browser() {
                    babelHelpers.classCallCheck(this, Browser);
                }

                babelHelpers.createClass(Browser, null, [{
                    key: "isOpera",
                    value: function isOpera() {
                        return UA.includes('opera');
                    }
                }, {
                    key: "isIE",
                    value: function isIE() {
                        return 'attachEvent' in document && !Browser.isOpera();
                    }
                }, {
                    key: "isIE6",
                    value: function isIE6() {
                        return UA.includes('msie 6');
                    }
                }, {
                    key: "isIE7",
                    value: function isIE7() {
                        return UA.includes('msie 7');
                    }
                }, {
                    key: "isIE8",
                    value: function isIE8() {
                        return UA.includes('msie 8');
                    }
                }, {
                    key: "isIE9",
                    value: function isIE9() {
                        return 'documentMode' in document && document.documentMode >= 9;
                    }
                }, {
                    key: "isIE10",
                    value: function isIE10() {
                        return 'documentMode' in document && document.documentMode >= 10;
                    }
                }, {
                    key: "isSafari",
                    value: function isSafari() {
                        return UA.includes('webkit');
                    }
                }, {
                    key: "isFirefox",
                    value: function isFirefox() {
                        return UA.includes('firefox');
                    }
                }, {
                    key: "isChrome",
                    value: function isChrome() {
                        return UA.includes('chrome');
                    }
                }, {
                    key: "detectIEVersion",
                    value: function detectIEVersion() {
                        if (Browser.isOpera() || Browser.isSafari() || Browser.isFirefox() || Browser.isChrome()) {
                            return -1;
                        }

                        var rv = -1;

                        if (!!window.MSStream && !window.ActiveXObject && 'ActiveXObject' in window) {
                            rv = 11;
                        } else if (Browser.isIE10()) {
                            rv = 10;
                        } else if (Browser.isIE9()) {
                            rv = 9;
                        } else if (Browser.isIE()) {
                            rv = 8;
                        }

                        if (rv === -1 || rv === 8) {
                            if (navigator.appName === 'Microsoft Internet Explorer') {
                                var re = new RegExp('MSIE ([0-9]+[.0-9]*)');
                                var res = navigator.userAgent.match(re);

                                if (Type.isArrayLike(res) && res.length > 0) {
                                    rv = parseFloat(res[1]);
                                }
                            }

                            if (navigator.appName === 'Netscape') {
                                // Alternative check for IE 11
                                rv = 11;

                                var _re = new RegExp('Trident/.*rv:([0-9]+[.0-9]*)');

                                if (_re.exec(navigator.userAgent) != null) {
                                    var _res = navigator.userAgent.match(_re);

                                    if (Type.isArrayLike(_res) && _res.length > 0) {
                                        rv = parseFloat(_res[1]);
                                    }
                                }
                            }
                        }

                        return rv;
                    }
                }, {
                    key: "isIE11",
                    value: function isIE11() {
                        return Browser.detectIEVersion() >= 11;
                    }
                }, {
                    key: "isMac",
                    value: function isMac() {
                        return UA.includes('macintosh');
                    }
                }, {
                    key: "isAndroid",
                    value: function isAndroid() {
                        return UA.includes('android');
                    }
                }, {
                    key: "isIPad",
                    value: function isIPad() {
                        return UA.includes('ipad;');
                    }
                }, {
                    key: "isIPhone",
                    value: function isIPhone() {
                        return UA.includes('iphone;');
                    }
                }, {
                    key: "isIOS",
                    value: function isIOS() {
                        return Browser.isIPad() || Browser.isIPhone();
                    }
                }, {
                    key: "isMobile",
                    value: function isMobile() {
                        return Browser.isIPhone() || Browser.isIPad() || Browser.isAndroid() || UA.includes('mobile') || UA.includes('touch');
                    }
                }, {
                    key: "isRetina",
                    value: function isRetina() {
                        return window.devicePixelRatio && window.devicePixelRatio >= 2;
                    }
                }, {
                    key: "isDoctype",
                    value: function isDoctype(target) {
                        var doc = target || document;

                        if (doc.compatMode) {
                            return doc.compatMode === 'CSS1Compat';
                        }

                        return doc.documentElement && doc.documentElement.clientHeight;
                    }
                }, {
                    key: "isLocalStorageSupported",
                    value: function isLocalStorageSupported() {
                        try {
                            localStorage.setItem('test', 'test');
                            localStorage.removeItem('test');
                            return true;
                        } catch (e) {
                            return false;
                        }
                    }
                }, {
                    key: "addGlobalClass",
                    value: function addGlobalClass() {
                        var globalClass = 'bx-core';

                        if (Dom.hasClass(document.documentElement, globalClass)) {
                            return;
                        }

                        if (Browser.isIOS()) {
                            globalClass += ' bx-ios';
                        } else if (Browser.isMac()) {
                            globalClass += ' bx-mac';
                        } else if (Browser.isAndroid()) {
                            globalClass += ' bx-android';
                        }

                        globalClass += Browser.isMobile() ? ' bx-touch' : ' bx-no-touch';
                        globalClass += Browser.isRetina() ? ' bx-retina' : ' bx-no-retina';
                        var ieVersion = -1;

                        if (/AppleWebKit/.test(navigator.userAgent)) {
                            globalClass += ' bx-chrome';
                        } else if (Browser.detectIEVersion() > 0) {
                            ieVersion = Browser.detectIEVersion();
                            globalClass += " bx-ie bx-ie".concat(ieVersion);

                            if (ieVersion > 7 && ieVersion < 10 && !Browser.isDoctype()) {
                                globalClass += ' bx-quirks';
                            }
                        } else if (/Opera/.test(navigator.userAgent)) {
                            globalClass += ' bx-opera';
                        } else if (/Gecko/.test(navigator.userAgent)) {
                            globalClass += ' bx-firefox';
                        }

                        Dom.addClass(document.documentElement, globalClass);
                    }
                }, {
                    key: "detectAndroidVersion",
                    value: function detectAndroidVersion() {
                        var re = new RegExp('Android ([0-9]+[.0-9]*)');

                        if (re.exec(navigator.userAgent) != null) {
                            var res = navigator.userAgent.match(re);

                            if (Type.isArrayLike(res) && res.length > 0) {
                                return parseFloat(res[1]);
                            }
                        }

                        return 0;
                    }
                }, {
                    key: "isPropertySupported",
                    value: function isPropertySupported(jsProperty, returnCSSName) {
                        if (jsProperty === '') {
                            return false;
                        }

                        function getCssName(propertyName) {
                            return propertyName.replace(/([A-Z])/g, function () {
                                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                                    args[_key] = arguments[_key];
                                }

                                return "-".concat(args[1].toLowerCase());
                            });
                        }

                        function getJsName(cssName) {
                            var reg = /(\\-([a-z]))/g;

                            if (reg.test(cssName)) {
                                return cssName.replace(reg, function () {
                                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                                        args[_key2] = arguments[_key2];
                                    }

                                    return args[2].toUpperCase();
                                });
                            }

                            return cssName;
                        }

                        var property = jsProperty.includes('-') ? getJsName(jsProperty) : jsProperty;
                        var bReturnCSSName = !!returnCSSName;
                        var ucProperty = property.charAt(0).toUpperCase() + property.slice(1);
                        var props = ['Webkit', 'Moz', 'O', 'ms'].join("".concat(ucProperty, " "));
                        var properties = "".concat(property, " ").concat(props, " ").concat(ucProperty).split(' ');
                        var obj = document.body || document.documentElement;

                        for (var i = 0; i < properties.length; i += 1) {
                            var prop = properties[i];

                            if (obj && 'style' in obj && prop in obj.style) {
                                var lowerProp = prop.substr(0, prop.length - property.length).toLowerCase();
                                var prefix = prop === property ? '' : "-".concat(lowerProp, "-");
                                return bReturnCSSName ? prefix + getCssName(property) : prop;
                            }
                        }

                        return false;
                    }
                }, {
                    key: "addGlobalFeatures",
                    value: function addGlobalFeatures(features) {
                        if (!Type.isArray(features)) {
                            return;
                        }

                        var classNames = [];

                        for (var i = 0; i < features.length; i += 1) {
                            var support = !!Browser.isPropertySupported(features[i]);
                            classNames.push("bx-".concat(support ? '' : 'no-').concat(features[i].toLowerCase()));
                        }

                        Dom.addClass(document.documentElement, classNames.join(' '));
                    }
                }]);
                return Browser;
            }();

        var Cookie =
            /*#__PURE__*/
            function () {
                function Cookie() {
                    babelHelpers.classCallCheck(this, Cookie);
                }

                babelHelpers.createClass(Cookie, null, [{
                    key: "getList",

                    /**
                     * Gets cookies list for current domain
                     * @return {object}
                     */
                    value: function getList() {
                        return document.cookie.split(';').map(function (item) {
                            return item.split('=');
                        }).map(function (item) {
                            return item.map(function (subItem) {
                                return subItem.trim();
                            });
                        }).reduce(function (acc, item) {
                            var _item = babelHelpers.slicedToArray(item, 2),
                                key = _item[0],
                                value = _item[1];

                            acc[decodeURIComponent(key)] = decodeURIComponent(value);
                            return acc;
                        }, {});
                    }
                    /**
                     * Gets cookie value
                     * @param {string} name
                     * @return {*}
                     */

                }, {
                    key: "get",
                    value: function get(name) {
                        var cookiesList = Cookie.getList();

                        if (name in cookiesList) {
                            return cookiesList[name];
                        }

                        return undefined;
                    }
                    /**
                     * Sets cookie
                     * @param {string} name
                     * @param {*} value
                     * @param {object} [options]
                     */

                }, {
                    key: "set",
                    value: function set(name, value) {
                        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                        var attributes = babelHelpers.objectSpread({
                            expires: ''
                        }, options);

                        if (Type.isNumber(attributes.expires)) {
                            var now = +new Date();
                            var days = attributes.expires;
                            var dayInMs = 864e+5;
                            attributes.expires = new Date(now + days * dayInMs);
                        }

                        if (Type.isDate(attributes.expires)) {
                            attributes.expires = attributes.expires.toUTCString();
                        }

                        var safeName = decodeURIComponent(String(name)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
                        var safeValue = encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
                        var stringifiedAttributes = Object.keys(attributes).reduce(function (acc, key) {
                            var attributeValue = attributes[key];

                            if (!attributeValue) {
                                return acc;
                            }

                            if (attributeValue === true) {
                                return "".concat(acc, "; ").concat(key);
                            }
                            /**
                             * Considers RFC 6265 section 5.2:
                             * ...
                             * 3. If the remaining unparsed-attributes contains a %x3B (';')
                             * character:
                             * Consume the characters of the unparsed-attributes up to,
                             * not including, the first %x3B (';') character.
                             */


                            return "".concat(acc, "; ").concat(key, "=").concat(attributeValue.split(';')[0]);
                        }, '');
                        document.cookie = "".concat(safeName, "=").concat(safeValue).concat(stringifiedAttributes);
                    }
                    /**
                     * Removes cookie
                     * @param {string} name
                     * @param {object} [options]
                     */

                }, {
                    key: "remove",
                    value: function remove(name) {
                        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                        Cookie.set(name, '', babelHelpers.objectSpread({}, options, {
                            expires: -1
                        }));
                    }
                }]);
                return Cookie;
            }();

        function objectToFormData(source) {
            var formData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new FormData();
            var pre = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

            if (Type.isUndefined(source)) {
                return formData;
            }

            if (Type.isNull(source)) {
                formData.append(pre, '');
            } else if (Type.isArray(source)) {
                if (!source.length) {
                    var _key = "".concat(pre, "[]");

                    formData.append(_key, '');
                } else {
                    source.forEach(function (value, index) {
                        var key = "".concat(pre, "[").concat(index, "]");
                        objectToFormData(value, formData, key);
                    });
                }
            } else if (Type.isDate(source)) {
                formData.append(pre, source.toISOString());
            } else if (Type.isObject(source) && !Type.isFile(source) && !Type.isBlob(source)) {
                Object.keys(source).forEach(function (property) {
                    var value = source[property];
                    var preparedProperty = property;

                    if (Type.isArray(value)) {
                        while (property.length > 2 && property.lastIndexOf('[]') === property.length - 2) {
                            preparedProperty = property.substring(0, property.length - 2);
                        }
                    }

                    var key = pre ? "".concat(pre, "[").concat(preparedProperty, "]") : preparedProperty;
                    objectToFormData(value, formData, key);
                });
            } else {
                formData.append(pre, source);
            }

            return formData;
        }

        var Data =
            /*#__PURE__*/
            function () {
                function Data() {
                    babelHelpers.classCallCheck(this, Data);
                }

                babelHelpers.createClass(Data, null, [{
                    key: "convertObjectToFormData",

                    /**
                     * Converts object to FormData
                     * @param source
                     * @return {FormData}
                     */
                    value: function convertObjectToFormData(source) {
                        return objectToFormData(source);
                    }
                }]);
                return Data;
            }();

        /**
         * @memberOf BX
         */

        var Http = function Http() {
            babelHelpers.classCallCheck(this, Http);
        };

        babelHelpers.defineProperty(Http, "Cookie", Cookie);
        babelHelpers.defineProperty(Http, "Data", Data);

        function message(value) {
            if (Type.isString(value)) {
                if (Type.isNil(message[value])) {
                    // eslint-disable-next-line
                    EventEmitter.emit('onBXMessageNotFound', new BaseEvent({
                        compatData: [value]
                    }));

                    if (Type.isNil(message[value])) {
                        Runtime.debug("message undefined: ".concat(value));
                        message[value] = '';
                    }
                }
            }

            if (Type.isPlainObject(value)) {
                Object.keys(value).forEach(function (key) {
                    message[key] = value[key];
                });
            }

            return message[value];
        }

        if (!Type.isNil(window.BX) && Type.isFunction(window.BX.message)) {
            Object.keys(window.BX.message).forEach(function (key) {
                message(babelHelpers.defineProperty({}, key, window.BX.message[key]));
            });
        }

        /**
         * Implements interface for works with language messages
         * @memberOf BX
         */

        var Loc =
            /*#__PURE__*/
            function () {
                function Loc() {
                    babelHelpers.classCallCheck(this, Loc);
                }

                babelHelpers.createClass(Loc, null, [{
                    key: "getMessage",

                    /**
                     * Gets message by id
                     * @param {string} messageId
                     * @return {?string}
                     */
                    value: function getMessage(messageId) {
                        return message(messageId);
                    }
                    /**
                     * Sets message or messages
                     * @param {string | Object<string, string>} id
                     * @param {string} [value]
                     */

                }, {
                    key: "setMessage",
                    value: function setMessage(id, value) {
                        if (Type.isString(id) && Type.isString(value)) {
                            message(babelHelpers.defineProperty({}, id, value));
                        }

                        if (Type.isObject(id)) {
                            message(id);
                        }
                    }
                }]);
                return Loc;
            }();

        var handlers = new Map();
        var children = new Map();

        var getUid = function () {
            var incremental = 0;
            return function () {
                incremental += 1;
                return incremental;
            };
        }();

        function bindAll(element, handlersMap) {
            handlersMap.forEach(function (handler, key) {
                var currentElement = element.querySelector("[".concat(key, "]"));

                if (currentElement) {
                    currentElement.removeAttribute(key);
                    var event = key.replace(/-(.*)/, '');
                    Event.bind(currentElement, event, handler);
                    handlers.delete(key);
                }
            });
        }

        function replaceChild(element, childrenMap) {
            childrenMap.forEach(function (item, id) {
                var currentElement = element.getElementById(id);

                if (currentElement) {
                    Dom.replace(currentElement, item);
                    children.delete(id);
                }
            });
        }

        function render(sections) {
            var eventAttrRe = /[ |\t]on(\w+)="$/;
            var uselessSymbolsRe = /[\r\n\t]/g;

            for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                substitutions[_key - 1] = arguments[_key];
            }

            var html = substitutions.reduce(function (acc, item, index) {
                var preparedAcc = acc; // Process event handlers

                var matches = acc.match(eventAttrRe);

                if (matches && Type.isFunction(item)) {
                    var eventName = matches[1].replace(/=['|"]/, '');
                    var attrName = "".concat(eventName, "-").concat(getUid());
                    var attribute = "".concat(attrName, "=\"");
                    preparedAcc = preparedAcc.replace(eventAttrRe, " ".concat(attribute));
                    handlers.set(attrName, item);
                    preparedAcc += sections[index + 1].replace(uselessSymbolsRe, ' ').replace(/  +/g, ' ');
                    return preparedAcc;
                } // Process element


                if (Type.isDomNode(item)) {
                    var childKey = "tmp___".concat(getUid());
                    children.set(childKey, item);
                    preparedAcc += "<span id=\"".concat(childKey, "\"> </span>");
                    preparedAcc += sections[index + 1];
                    return preparedAcc;
                } // Process array


                if (Type.isArray(item)) {
                    babelHelpers.toConsumableArray(item).forEach(function (currentElement) {
                        if (Type.isDomNode(currentElement)) {
                            var _childKey = "tmp___".concat(getUid());

                            children.set(_childKey, currentElement);
                            preparedAcc += "<span id=\"".concat(_childKey, "\"> </span>");
                        }
                    });
                    preparedAcc += sections[index + 1];
                    return preparedAcc;
                }

                return preparedAcc + item + sections[index + 1];
            }, sections[0]);
            var lowercaseHtml = html.trim().toLowerCase();

            if (lowercaseHtml.startsWith('<!doctype') || lowercaseHtml.startsWith('<html')) {
                var doc = document.implementation.createHTMLDocument('');
                doc.documentElement.innerHTML = html;
                replaceChild(doc, children);
                bindAll(doc, handlers);
                handlers.clear();
                return doc;
            }

            var parser = new DOMParser();
            var parsedDocument = parser.parseFromString(html, 'text/html');
            replaceChild(parsedDocument, children);
            bindAll(parsedDocument, handlers);

            if (parsedDocument.head.children.length && parsedDocument.body.children.length) {
                return parsedDocument;
            }

            if (parsedDocument.body.children.length === 1) {
                var _parsedDocument$body$ = babelHelpers.slicedToArray(parsedDocument.body.children, 1),
                    el = _parsedDocument$body$[0];

                Dom.remove(el);
                return el;
            }

            if (parsedDocument.body.children.length > 1) {
                return babelHelpers.toConsumableArray(parsedDocument.body.children).map(function (item) {
                    Dom.remove(item);
                    return item;
                });
            }

            if (parsedDocument.body.children.length === 0) {
                if (parsedDocument.head.children.length === 1) {
                    var _parsedDocument$head$ = babelHelpers.slicedToArray(parsedDocument.head.children, 1),
                        _el = _parsedDocument$head$[0];

                    Dom.remove(_el);
                    return _el;
                }

                if (parsedDocument.head.children.length > 1) {
                    return babelHelpers.toConsumableArray(parsedDocument.head.children).map(function (item) {
                        Dom.remove(item);
                        return item;
                    });
                }
            }

            return false;
        }

        function parseProps(sections) {
            for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                substitutions[_key - 1] = arguments[_key];
            }

            return substitutions.reduce(function (acc, item, index) {
                var nextSectionIndex = index + 1;

                if (!Type.isPlainObject(item) && !Type.isArray(item)) {
                    return acc + item + sections[nextSectionIndex];
                }

                return "".concat(acc, "__s").concat(index).concat(sections[nextSectionIndex]);
            }, sections[0]).replace(/[\r\t]/gm, '').split(';\n').map(function (item) {
                return item.replace(/\n/, '');
            }).reduce(function (acc, item) {
                if (item !== '') {
                    var matches = item.match(/^[\w-. ]+:/);
                    var splitted = item.split(/^[\w-. ]+:/);

                    var _key2 = matches[0].replace(':', '').trim();

                    var value = splitted[1].trim();
                    var substitutionPlaceholderExp = /^__s\d+/;

                    if (substitutionPlaceholderExp.test(value)) {
                        acc[_key2] = substitutions[value.replace('__s', '')];
                        return acc;
                    }

                    acc[_key2] = value;
                }

                return acc;
            }, {});
        }
        /**
         * @memberOf BX
         */


        var Tag =
            /*#__PURE__*/
            function () {
                function Tag() {
                    babelHelpers.classCallCheck(this, Tag);
                }

                babelHelpers.createClass(Tag, null, [{
                    key: "safe",

                    /**
                     * Encodes all substitutions
                     * @param sections
                     * @param substitutions
                     * @return {string}
                     */
                    value: function safe(sections) {
                        for (var _len2 = arguments.length, substitutions = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
                            substitutions[_key3 - 1] = arguments[_key3];
                        }

                        return substitutions.reduce(function (acc, item, index) {
                            return acc + Text.encode(item) + sections[index + 1];
                        }, sections[0]);
                    }
                    /**
                     * Decodes all substitutions
                     * @param sections
                     * @param substitutions
                     * @return {string}
                     */

                }, {
                    key: "unsafe",
                    value: function unsafe(sections) {
                        for (var _len3 = arguments.length, substitutions = new Array(_len3 > 1 ? _len3 - 1 : 0), _key4 = 1; _key4 < _len3; _key4++) {
                            substitutions[_key4 - 1] = arguments[_key4];
                        }

                        return substitutions.reduce(function (acc, item, index) {
                            return acc + Text.decode(item) + sections[index + 1];
                        }, sections[0]);
                    }
                    /**
                     * Adds styles to specified element
                     * @param {HTMLElement} element
                     * @return {Function}
                     */

                }, {
                    key: "style",
                    value: function style(element) {
                        if (!Type.isDomNode(element)) {
                            throw new Error('element is not HTMLElement');
                        }

                        return function styleTagHandler() {
                            Dom.style(element, parseProps.apply(void 0, arguments));
                        };
                    }
                    /**
                     * Replace all messages identifiers to real messages
                     * @param sections
                     * @param substitutions
                     * @return {string}
                     */

                }, {
                    key: "message",
                    value: function message(sections) {
                        for (var _len4 = arguments.length, substitutions = new Array(_len4 > 1 ? _len4 - 1 : 0), _key5 = 1; _key5 < _len4; _key5++) {
                            substitutions[_key5 - 1] = arguments[_key5];
                        }

                        return substitutions.reduce(function (acc, item, index) {
                            return acc + Loc.getMessage(item) + sections[index + 1];
                        }, sections[0]);
                    }
                }, {
                    key: "attrs",

                    /**
                     * Adds attributes to specified element
                     * @param element
                     * @return {Function}
                     */
                    value: function attrs(element) {
                        if (!Type.isDomNode(element)) {
                            throw new Error('element is not HTMLElement');
                        }

                        return function attrsTagHandler() {
                            Dom.attr(element, parseProps.apply(void 0, arguments));
                        };
                    }
                }]);
                return Tag;
            }();

        babelHelpers.defineProperty(Tag, "render", render);
        babelHelpers.defineProperty(Tag, "attr", Tag.attrs);

        function getParser(format) {
            switch (format) {
                case 'index':
                    return function (sourceKey, value, accumulator) {
                        var result = /\[(\w*)\]$/.exec(sourceKey);
                        var key = sourceKey.replace(/\[\w*\]$/, '');

                        if (Type.isNil(result)) {
                            accumulator[key] = value;
                            return;
                        }

                        if (Type.isUndefined(accumulator[key])) {
                            accumulator[key] = {};
                        }

                        accumulator[key][result[1]] = value;
                    };

                case 'bracket':
                    return function (sourceKey, value, accumulator) {
                        var result = /(\[\])$/.exec(sourceKey);
                        var key = sourceKey.replace(/\[\]$/, '');

                        if (Type.isNil(result)) {
                            accumulator[key] = value;
                            return;
                        }

                        if (Type.isUndefined(accumulator[key])) {
                            accumulator[key] = [value];
                            return;
                        }

                        accumulator[key] = [].concat(accumulator[key], value);
                    };

                default:
                    return function (sourceKey, value, accumulator) {
                        var key = sourceKey.replace(/\[\]$/, '');
                        accumulator[key] = value;
                    };
            }
        }

        function getKeyFormat(key) {
            if (/^\w+\[([\w]+)\]$/.test(key)) {
                return 'index';
            }

            if (/^\w+\[\]$/.test(key)) {
                return 'bracket';
            }

            return 'default';
        }

        function parseQuery(input) {
            if (!Type.isString(input)) {
                return {};
            }

            var url = input.trim().replace(/^[?#&]/, '');

            if (!url) {
                return {};
            }

            return url.split('&').reduce(function (acc, param) {
                var _param$replace$split = param.replace(/\+/g, ' ').split('='),
                    _param$replace$split2 = babelHelpers.slicedToArray(_param$replace$split, 2),
                    key = _param$replace$split2[0],
                    value = _param$replace$split2[1];

                var keyFormat = getKeyFormat(key);
                var formatter = getParser(keyFormat);
                formatter(key, value, acc);
                return acc;
            }, {});
        }

        var urlExp = /^((\w+):)?(\/\/((\w+)?(:(\w+))?@)?([^\/\?:]+)(:(\d+))?)?(\/?([^\/\?#][^\?#]*)?)?(\?([^#]+))?(#(\w*))?/;
        function parseUrl(url) {
            var result = url.match(urlExp);

            if (Type.isArray(result)) {
                var queryParams = parseQuery(result[14]);
                return {
                    useShort: /^\/\//.test(url),
                    href: result[0] || '',
                    schema: result[2] || '',
                    host: result[8] || '',
                    port: result[10] || '',
                    path: result[11] || '',
                    query: result[14] || '',
                    queryParams: queryParams,
                    hash: result[16] || '',
                    username: result[5] || '',
                    password: result[7] || '',
                    origin: result[8] || ''
                };
            }

            return {};
        }

        function buildQueryString() {
            var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var queryString = Object.keys(params).reduce(function (acc, key) {
                if (Type.isArray(params[key])) {
                    params[key].forEach(function (paramValue) {
                        acc.push("".concat(key, "[]=").concat(paramValue));
                    }, '');
                }

                if (Type.isPlainObject(params[key])) {
                    Object.keys(params[key]).forEach(function (paramIndex) {
                        acc.push("".concat(key, "[").concat(paramIndex, "]=").concat(params[key][paramIndex]));
                    }, '');
                }

                if (!Type.isObject(params[key]) && !Type.isArray(params[key])) {
                    acc.push("".concat(key, "=").concat(params[key]));
                }

                return acc;
            }, []).join('&');

            if (queryString.length > 0) {
                return "?".concat(queryString);
            }

            return queryString;
        }

        function prepareParamValue(value) {
            if (Type.isArray(value)) {
                return value.map(function (item) {
                    return String(item);
                });
            }

            if (Type.isPlainObject(value)) {
                return babelHelpers.objectSpread({}, value);
            }

            return String(value);
        }

        var map = new WeakMap();
        /**
         * Implements interface for works with URI
         * @memberOf BX
         */

        var Uri =
            /*#__PURE__*/
            function () {
                babelHelpers.createClass(Uri, null, [{
                    key: "addParam",
                    value: function addParam(url) {
                        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                        return new Uri(url).setQueryParams(params).toString();
                    }
                }, {
                    key: "removeParam",
                    value: function removeParam(url, params) {
                        var _ref;

                        var removableParams = Type.isArray(params) ? params : [params];
                        return (_ref = new Uri(url)).removeQueryParam.apply(_ref, babelHelpers.toConsumableArray(removableParams)).toString();
                    }
                }]);

                function Uri() {
                    var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
                    babelHelpers.classCallCheck(this, Uri);
                    map.set(this, parseUrl(url));
                }
                /**
                 * Gets schema
                 * @return {?string}
                 */


                babelHelpers.createClass(Uri, [{
                    key: "getSchema",
                    value: function getSchema() {
                        return map.get(this).schema;
                    }
                    /**
                     * Sets schema
                     * @param {string} schema
                     * @return {Uri}
                     */

                }, {
                    key: "setSchema",
                    value: function setSchema(schema) {
                        map.get(this).schema = String(schema);
                        return this;
                    }
                    /**
                     * Gets host
                     * @return {?string}
                     */

                }, {
                    key: "getHost",
                    value: function getHost() {
                        return map.get(this).host;
                    }
                    /**
                     * Sets host
                     * @param {string} host
                     * @return {Uri}
                     */

                }, {
                    key: "setHost",
                    value: function setHost(host) {
                        map.get(this).host = String(host);
                        return this;
                    }
                    /**
                     * Gets port
                     * @return {?string}
                     */

                }, {
                    key: "getPort",
                    value: function getPort() {
                        return map.get(this).port;
                    }
                    /**
                     * Sets port
                     * @param {String | Number} port
                     * @return {Uri}
                     */

                }, {
                    key: "setPort",
                    value: function setPort(port) {
                        map.get(this).port = String(port);
                        return this;
                    }
                    /**
                     * Gets path
                     * @return {?string}
                     */

                }, {
                    key: "getPath",
                    value: function getPath() {
                        return map.get(this).path;
                    }
                    /**
                     * Sets path
                     * @param {string} path
                     * @return {Uri}
                     */

                }, {
                    key: "setPath",
                    value: function setPath(path) {
                        if (!/^\//.test(path)) {
                            map.get(this).path = "/".concat(String(path));
                            return this;
                        }

                        map.get(this).path = String(path);
                        return this;
                    }
                    /**
                     * Gets query
                     * @return {?string}
                     */

                }, {
                    key: "getQuery",
                    value: function getQuery() {
                        return buildQueryString(map.get(this).queryParams);
                    }
                    /**
                     * Gets query param value by name
                     * @param {string} key
                     * @return {?string}
                     */

                }, {
                    key: "getQueryParam",
                    value: function getQueryParam(key) {
                        var params = this.getQueryParams();

                        if (key in params) {
                            return params[key];
                        }

                        return null;
                    }
                    /**
                     * Sets query param
                     * @param {string} key
                     * @param [value]
                     * @return {Uri}
                     */

                }, {
                    key: "setQueryParam",
                    value: function setQueryParam(key) {
                        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
                        map.get(this).queryParams[key] = prepareParamValue(value);
                        return this;
                    }
                    /**
                     * Gets query params
                     * @return {Object<string, any>}
                     */

                }, {
                    key: "getQueryParams",
                    value: function getQueryParams() {
                        return babelHelpers.objectSpread({}, map.get(this).queryParams);
                    }
                    /**
                     * Sets query params
                     * @param {Object<string, any>} params
                     * @return {Uri}
                     */

                }, {
                    key: "setQueryParams",
                    value: function setQueryParams() {
                        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                        var currentParams = this.getQueryParams();
                        var newParams = babelHelpers.objectSpread({}, currentParams, params);
                        Object.keys(newParams).forEach(function (key) {
                            newParams[key] = prepareParamValue(newParams[key]);
                        });
                        map.get(this).queryParams = newParams;
                        return this;
                    }
                    /**
                     * Removes query params by name
                     * @param keys
                     * @return {Uri}
                     */

                }, {
                    key: "removeQueryParam",
                    value: function removeQueryParam() {
                        var currentParams = babelHelpers.objectSpread({}, map.get(this).queryParams);

                        for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
                            keys[_key] = arguments[_key];
                        }

                        keys.forEach(function (key) {
                            if (key in currentParams) {
                                delete currentParams[key];
                            }
                        });
                        map.get(this).queryParams = currentParams;
                        return this;
                    }
                    /**
                     * Gets fragment
                     * @return {?string}
                     */

                }, {
                    key: "getFragment",
                    value: function getFragment() {
                        return map.get(this).hash;
                    }
                    /**
                     * Sets fragment
                     * @param {string} hash
                     * @return {Uri}
                     */

                }, {
                    key: "setFragment",
                    value: function setFragment(hash) {
                        map.get(this).hash = String(hash);
                        return this;
                    }
                    /**
                     * Serializes URI
                     * @return {Object}
                     */

                }, {
                    key: "serialize",
                    value: function serialize() {
                        var serialized = babelHelpers.objectSpread({}, map.get(this));
                        serialized.href = this.toString();
                        return serialized;
                    }
                    /**
                     * Gets URI string
                     * @return {string}
                     */

                }, {
                    key: "toString",
                    value: function toString() {
                        var data = babelHelpers.objectSpread({}, map.get(this));
                        var protocol = data.schema ? "".concat(data.schema, "://") : '';

                        if (data.useShort) {
                            protocol = '//';
                        }

                        var port = function () {
                            if (Type.isString(data.port) && !['', '80'].includes(data.port)) {
                                return ":".concat(data.port);
                            }

                            return '';
                        }();

                        var host = this.getHost();
                        var path = this.getPath();
                        var query = buildQueryString(data.queryParams);
                        var hash = data.hash ? "#".concat(data.hash) : '';
                        return "".concat(host ? protocol : '').concat(host).concat(host ? port : '').concat(path).concat(query).concat(hash);
                    }
                }]);
                return Uri;
            }();

        /**
         * @memberOf BX
         */
        var Validation =
            /*#__PURE__*/
            function () {
                function Validation() {
                    babelHelpers.classCallCheck(this, Validation);
                }

                babelHelpers.createClass(Validation, null, [{
                    key: "isEmail",

                    /**
                     * Checks that value is valid email
                     * @param value
                     * @return {boolean}
                     */
                    value: function isEmail(value) {
                        var exp = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
                        return exp.test(String(value).toLowerCase());
                    }
                }]);
                return Validation;
            }();

        var BaseCache =
            /*#__PURE__*/
            function () {
                function BaseCache() {
                    babelHelpers.classCallCheck(this, BaseCache);
                    babelHelpers.defineProperty(this, "storage", new Map());
                }

                babelHelpers.createClass(BaseCache, [{
                    key: "get",

                    /**
                     * Gets cached value or default value
                     */
                    value: function get(key, defaultValue) {
                        if (!this.storage.has(key)) {
                            if (Type.isFunction(defaultValue)) {
                                return defaultValue();
                            }

                            if (!Type.isUndefined(defaultValue)) {
                                return defaultValue;
                            }
                        }

                        return this.storage.get(key);
                    }
                    /**
                     * Sets cache entry
                     */

                }, {
                    key: "set",
                    value: function set(key, value) {
                        this.storage.set(key, value);
                    }
                    /**
                     * Deletes cache entry
                     */

                }, {
                    key: "delete",
                    value: function _delete(key) {
                        this.storage.delete(key);
                    }
                    /**
                     * Checks that storage contains entry with specified key
                     */

                }, {
                    key: "has",
                    value: function has(key) {
                        return this.storage.has(key);
                    }
                    /**
                     * Gets cached value if exists,
                     */

                }, {
                    key: "remember",
                    value: function remember(key, defaultValue) {
                        if (!this.storage.has(key)) {
                            if (Type.isFunction(defaultValue)) {
                                this.storage.set(key, defaultValue());
                            } else if (!Type.isUndefined(defaultValue)) {
                                this.storage.set(key, defaultValue);
                            }
                        }

                        return this.storage.get(key);
                    }
                    /**
                     * Gets storage size
                     */

                }, {
                    key: "size",
                    value: function size() {
                        return this.storage.size;
                    }
                    /**
                     * Gets storage keys
                     */

                }, {
                    key: "keys",
                    value: function keys() {
                        return babelHelpers.toConsumableArray(this.storage.keys());
                    }
                    /**
                     * Gets storage values
                     */

                }, {
                    key: "values",
                    value: function values() {
                        return babelHelpers.toConsumableArray(this.storage.values());
                    }
                }]);
                return BaseCache;
            }();

        var MemoryCache =
            /*#__PURE__*/
            function (_BaseCache) {
                babelHelpers.inherits(MemoryCache, _BaseCache);

                function MemoryCache() {
                    var _babelHelpers$getProt;

                    var _this;

                    babelHelpers.classCallCheck(this, MemoryCache);

                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }

                    _this = babelHelpers.possibleConstructorReturn(this, (_babelHelpers$getProt = babelHelpers.getPrototypeOf(MemoryCache)).call.apply(_babelHelpers$getProt, [this].concat(args)));
                    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "storage", new Map());
                    return _this;
                }

                return MemoryCache;
            }(BaseCache);

        var LsStorage =
            /*#__PURE__*/
            function () {
                function LsStorage() {
                    babelHelpers.classCallCheck(this, LsStorage);
                    babelHelpers.defineProperty(this, "stackKey", 'BX.Cache.Storage.LsStorage.stack');
                    babelHelpers.defineProperty(this, "stack", null);
                }

                babelHelpers.createClass(LsStorage, [{
                    key: "getStack",

                    /**
                     * @private
                     */
                    value: function getStack() {
                        if (Type.isPlainObject(this.stack)) {
                            return this.stack;
                        }

                        var stack = localStorage.getItem(this.stackKey);

                        if (Type.isString(stack) && stack !== '') {
                            var parsedStack = JSON.parse(stack);

                            if (Type.isPlainObject(parsedStack)) {
                                this.stack = parsedStack;
                                return this.stack;
                            }
                        }

                        this.stack = {};
                        return this.stack;
                    }
                    /**
                     * @private
                     */

                }, {
                    key: "saveStack",
                    value: function saveStack() {
                        if (Type.isPlainObject(this.stack)) {
                            var preparedStack = JSON.stringify(this.stack);
                            localStorage.setItem(this.stackKey, preparedStack);
                        }
                    }
                }, {
                    key: "get",
                    value: function get(key) {
                        var stack = this.getStack();
                        return stack[key];
                    }
                }, {
                    key: "set",
                    value: function set(key, value) {
                        var stack = this.getStack();
                        stack[key] = value;
                        this.saveStack();
                    }
                }, {
                    key: "delete",
                    value: function _delete(key) {
                        var stack = this.getStack();

                        if (key in stack) {
                            delete stack[key];
                        }
                    }
                }, {
                    key: "has",
                    value: function has(key) {
                        var stack = this.getStack();
                        return key in stack;
                    }
                }, {
                    key: "keys",
                    value: function keys() {
                        var stack = this.getStack();
                        return Object.keys(stack);
                    }
                }, {
                    key: "values",
                    value: function values() {
                        var stack = this.getStack();
                        return Object.values(stack);
                    }
                }, {
                    key: "size",
                    get: function get() {
                        var stack = this.getStack();
                        return Object.keys(stack).length;
                    }
                }]);
                return LsStorage;
            }();

        var LocalStorageCache =
            /*#__PURE__*/
            function (_BaseCache) {
                babelHelpers.inherits(LocalStorageCache, _BaseCache);

                function LocalStorageCache() {
                    var _babelHelpers$getProt;

                    var _this;

                    babelHelpers.classCallCheck(this, LocalStorageCache);

                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                        args[_key] = arguments[_key];
                    }

                    _this = babelHelpers.possibleConstructorReturn(this, (_babelHelpers$getProt = babelHelpers.getPrototypeOf(LocalStorageCache)).call.apply(_babelHelpers$getProt, [this].concat(args)));
                    babelHelpers.defineProperty(babelHelpers.assertThisInitialized(_this), "storage", new LsStorage());
                    return _this;
                }

                return LocalStorageCache;
            }(BaseCache);

        /**
         * @memberOf BX
         */

        var Cache = function Cache() {
            babelHelpers.classCallCheck(this, Cache);
        };

        babelHelpers.defineProperty(Cache, "MemoryCache", MemoryCache);
        babelHelpers.defineProperty(Cache, "LocalStorageCache", LocalStorageCache);

        function convertPath(path) {
            if (Type.isStringFilled(path)) {
                return path.split('.').reduce(function (acc, item) {
                    item.split(/\[['"]?(.+?)['"]?\]/g).forEach(function (key) {
                        if (Type.isStringFilled(key)) {
                            acc.push(key);
                        }
                    });
                    return acc;
                }, []);
            }

            return [];
        }

        var SettingsCollection =
            /*#__PURE__*/
            function () {
                function SettingsCollection() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                    babelHelpers.classCallCheck(this, SettingsCollection);

                    if (Type.isPlainObject(options)) {
                        Object.assign(this, options);
                    }
                }

                babelHelpers.createClass(SettingsCollection, [{
                    key: "get",
                    value: function get(path) {
                        var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                        var convertedPath = convertPath(path);
                        return convertedPath.reduce(function (acc, key) {
                            if (!Type.isNil(acc) && acc !== defaultValue) {
                                if (!Type.isUndefined(acc[key])) {
                                    return acc[key];
                                }

                                return defaultValue;
                            }

                            return acc;
                        }, this);
                    }
                }]);
                return SettingsCollection;
            }();

        function deepFreeze(target) {
            if (Type.isObject(target)) {
                Object.values(target).forEach(function (value) {
                    deepFreeze(value);
                });
                return Object.freeze(target);
            }

            return target;
        }

        var settingsStorage = new Map();

        var Extension$1 =
            /*#__PURE__*/
            function () {
                function Extension() {
                    babelHelpers.classCallCheck(this, Extension);
                }

                babelHelpers.createClass(Extension, null, [{
                    key: "getSettings",
                    value: function getSettings(extensionName) {
                        if (Type.isStringFilled(extensionName)) {
                            if (settingsStorage.has(extensionName)) {
                                return settingsStorage.get(extensionName);
                            }

                            var settingsScriptNode = document.querySelector("script[data-extension=\"".concat(extensionName, "\"]"));

                            if (Type.isDomNode(settingsScriptNode)) {
                                var decodedSettings = function () {
                                    try {
                                        return new SettingsCollection(JSON.parse(settingsScriptNode.innerHTML));
                                    } catch (error) {
                                        return new SettingsCollection();
                                    }
                                }();

                                var frozenSettings = deepFreeze(decodedSettings);
                                settingsStorage.set(extensionName, frozenSettings);
                                return frozenSettings;
                            }
                        }

                        return deepFreeze(new SettingsCollection());
                    }
                }]);
                return Extension;
            }();

        function getElement(element) {
            if (Type.isString(element)) {
                return document.getElementById(element);
            }

            return element;
        }

        function getWindow(element) {
            if (Type.isElementNode(element)) {
                return element.ownerDocument.parentWindow || element.ownerDocument.defaultView || window;
            }

            if (Type.isDomNode(element)) {
                return element.parentWindow || element.defaultView || window;
            }

            return window;
        }

        /* eslint-disable prefer-rest-params */

        var getClass = Reflection.getClass,
            namespace = Reflection.namespace;
        var message$1 = message;
        /**
         * @memberOf BX
         */

        var replace = Dom.replace,
            remove = Dom.remove,
            clean = Dom.clean,
            insertBefore = Dom.insertBefore,
            insertAfter = Dom.insertAfter,
            append = Dom.append,
            prepend = Dom.prepend,
            style = Dom.style,
            adjust = Dom.adjust,
            create = Dom.create,
            isShown = Dom.isShown;
        var addClass = function addClass() {
            Dom.addClass.apply(Dom, babelHelpers.toConsumableArray(Runtime.merge([], Array.from(arguments), [getElement(arguments[0])])));
        };
        var removeClass = function removeClass() {
            Dom.removeClass.apply(Dom, babelHelpers.toConsumableArray(Runtime.merge(Array.from(arguments), [getElement(arguments[0])])));
        };
        var hasClass = function hasClass() {
            return Dom.hasClass.apply(Dom, babelHelpers.toConsumableArray(Runtime.merge(Array.from(arguments), [getElement(arguments[0])])));
        };
        var toggleClass = function toggleClass() {
            Dom.toggleClass.apply(Dom, babelHelpers.toConsumableArray(Runtime.merge(Array.from(arguments), [getElement(arguments[0])])));
        };
        var cleanNode = function cleanNode(element) {
            var removeElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            var currentElement = getElement(element);

            if (Type.isDomNode(currentElement)) {
                Dom.clean(currentElement);

                if (removeElement) {
                    Dom.remove(currentElement);
                    return currentElement;
                }
            }

            return currentElement;
        };
        var getCookie = Http.Cookie.get;
        var setCookie = function setCookie(name, value) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var attributes = babelHelpers.objectSpread({}, options);

            if (Type.isNumber(attributes.expires)) {
                attributes.expires /= 3600 * 24;
            }

            Http.Cookie.set(name, value, attributes);
        };
        var bind$1 = Event.bind,
            unbind$1 = Event.unbind,
            unbindAll$1 = Event.unbindAll,
            bindOnce$1 = Event.bindOnce,
            ready$1 = Event.ready;
        var debugEnableFlag = debugState,
            debugStatus = isDebugEnabled,
            debug$1 = debug;
        var debugEnable = function debugEnable(value) {
            if (value) {
                enableDebug();
            } else {
                disableDebug();
            }
        };
        var clone$1 = Runtime.clone,
            loadExt = Runtime.loadExtension,
            debounce = Runtime.debounce,
            throttle = Runtime.throttle,
            html = Runtime.html; // BX.type
        var type = babelHelpers.objectSpread({}, Object.getOwnPropertyNames(Type).filter(function (key) {
            return !['name', 'length', 'prototype', 'caller', 'arguments'].includes(key);
        }).reduce(function (acc, key) {
            acc[key] = Type[key];
            return acc;
        }, {}), {
            isNotEmptyString: function isNotEmptyString(value) {
                return Type.isString(value) && value !== '';
            },
            isNotEmptyObject: function isNotEmptyObject(value) {
                return Type.isObjectLike(value) && Object.keys(value).length > 0;
            },
            isMapKey: Type.isObject,
            stringToInt: function stringToInt(value) {
                var parsed = parseInt(value);
                return !Number.isNaN(parsed) ? parsed : 0;
            }
        }); // BX.browser

        var browser = {
            IsOpera: Browser.isOpera,
            IsIE: Browser.isIE,
            IsIE6: Browser.isIE6,
            IsIE7: Browser.isIE7,
            IsIE8: Browser.isIE8,
            IsIE9: Browser.isIE9,
            IsIE10: Browser.isIE10,
            IsIE11: Browser.isIE11,
            IsSafari: Browser.isSafari,
            IsFirefox: Browser.isFirefox,
            IsChrome: Browser.isChrome,
            DetectIeVersion: Browser.detectIEVersion,
            IsMac: Browser.isMac,
            IsAndroid: Browser.isAndroid,
            isIPad: Browser.isIPad,
            isIPhone: Browser.isIPhone,
            IsIOS: Browser.isIOS,
            IsMobile: Browser.isMobile,
            isRetina: Browser.isRetina,
            IsDoctype: Browser.isDoctype,
            SupportLocalStorage: Browser.isLocalStorageSupported,
            addGlobalClass: Browser.addGlobalClass,
            DetectAndroidVersion: Browser.detectAndroidVersion,
            isPropertySupported: Browser.isPropertySupported,
            addGlobalFeatures: Browser.addGlobalFeatures
        }; // eslint-disable-next-line

        var ajax = window.BX ? window.BX.ajax : function () {};
        function GetWindowScrollSize() {
            var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
            return {
                scrollWidth: doc.documentElement.scrollWidth,
                scrollHeight: doc.documentElement.scrollHeight
            };
        }
        function GetWindowScrollPos() {
            var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
            var win = getWindow(doc);
            return {
                scrollLeft: win.pageXOffset,
                scrollTop: win.pageYOffset
            };
        }
        function GetWindowInnerSize() {
            var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
            var win = getWindow(doc);
            return {
                innerWidth: win.innerWidth,
                innerHeight: win.innerHeight
            };
        }
        function GetWindowSize() {
            var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
            return babelHelpers.objectSpread({}, GetWindowInnerSize(doc), GetWindowScrollPos(doc), GetWindowScrollSize(doc));
        }
        function GetContext(node) {
            return getWindow(node);
        }
        function pos(element) {
            var relative = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            if (!element) {
                return new DOMRect().toJSON();
            }

            if (element.ownerDocument === document && !relative) {
                var clientRect = element.getBoundingClientRect();
                var root = document.documentElement;
                var _document = document,
                    body = _document.body;
                return {
                    top: Math.round(clientRect.top + (root.scrollTop || body.scrollTop)),
                    left: Math.round(clientRect.left + (root.scrollLeft || body.scrollLeft)),
                    width: Math.round(clientRect.right - clientRect.left),
                    height: Math.round(clientRect.bottom - clientRect.top),
                    right: Math.round(clientRect.right + (root.scrollLeft || body.scrollLeft)),
                    bottom: Math.round(clientRect.bottom + (root.scrollTop || body.scrollTop))
                };
            }

            var x = 0;
            var y = 0;
            var w = element.offsetWidth;
            var h = element.offsetHeight;
            var first = true; // eslint-disable-next-line no-param-reassign

            for (; element != null; element = element.offsetParent) {
                if (!first && relative && BX.is_relative(element)) {
                    break;
                }

                x += element.offsetLeft;
                y += element.offsetTop;

                if (first) {
                    first = false; // eslint-disable-next-line no-continue

                    continue;
                }

                x += Text.toNumber(Dom.style(element, 'border-left-width'));
                y += Text.toNumber(Dom.style(element, 'border-top-width'));
            }

            return new DOMRect(x, y, w, h).toJSON();
        }
        function addCustomEvent(eventObject, eventName, eventHandler) {
            if (Type.isString(eventObject)) {
                eventHandler = eventName;
                eventName = eventObject;
                eventObject = EventEmitter.GLOBAL_TARGET;
            }

            if (eventObject === window) {
                eventObject = EventEmitter.GLOBAL_TARGET;
            }

            if (!Type.isObject(eventObject)) {
                console.error('The "eventObject" argument must be an object. Received type ' + babelHelpers.typeof(eventObject) + '.');
                return;
            }

            if (!Type.isStringFilled(eventName)) {
                console.error('The "eventName" argument must be a string.');
                return;
            }

            if (!Type.isFunction(eventHandler)) {
                console.error('The "eventHandler" argument must be a function. Received type ' + babelHelpers.typeof(eventHandler) + '.');
                return;
            }

            eventName = eventName.toLowerCase();
            EventEmitter.subscribe(eventObject, eventName, eventHandler, {
                compatMode: true,
                useGlobalNaming: true
            });
        }
        function onCustomEvent(eventObject, eventName, eventParams, secureParams) {
            if (Type.isString(eventObject)) {
                secureParams = eventParams;
                eventParams = eventName;
                eventName = eventObject;
                eventObject = EventEmitter.GLOBAL_TARGET;
            }

            if (!Type.isObject(eventObject) || eventObject === window) {
                eventObject = EventEmitter.GLOBAL_TARGET;
            }

            if (!eventParams) {
                eventParams = [];
            }

            eventName = eventName.toLowerCase();
            var event = new BaseEvent();
            event.setData(eventParams);
            event.setCompatData(eventParams);
            EventEmitter.emit(eventObject, eventName, event, {
                cloneData: secureParams === true,
                useGlobalNaming: true
            });
        }
        function removeCustomEvent(eventObject, eventName, eventHandler) {
            if (Type.isString(eventObject)) {
                eventHandler = eventName;
                eventName = eventObject;
                eventObject = EventEmitter.GLOBAL_TARGET;
            }

            if (!Type.isFunction(eventHandler)) {
                console.error('The "eventHandler" argument must be a function. Received type ' + babelHelpers.typeof(eventHandler) + '.');
                return;
            }

            if (eventObject === window) {
                eventObject = EventEmitter.GLOBAL_TARGET;
            }

            eventName = eventName.toLowerCase();
            EventEmitter.unsubscribe(eventObject, eventName, eventHandler, {
                useGlobalNaming: true
            });
        }
        function removeAllCustomEvents(eventObject, eventName) {
            if (Type.isString(eventObject)) {
                eventName = eventObject;
                eventObject = EventEmitter.GLOBAL_TARGET;
            }

            if (eventObject === window) {
                eventObject = EventEmitter.GLOBAL_TARGET;
            }

            eventName = eventName.toLowerCase();
            EventEmitter.unsubscribeAll(eventObject, eventName, {
                useGlobalNaming: true
            });
        }

        if (global && global.window && global.window.BX) {
            Object.assign(global.window.BX, exports);
        }

        exports.BaseError = BaseError;
        exports.Browser = Browser;
        exports.Cache = Cache;
        exports.Dom = Dom;
        exports.Event = Event;
        exports.Extension = Extension$1;
        exports.GetContext = GetContext;
        exports.GetWindowInnerSize = GetWindowInnerSize;
        exports.GetWindowScrollPos = GetWindowScrollPos;
        exports.GetWindowScrollSize = GetWindowScrollSize;
        exports.GetWindowSize = GetWindowSize;
        exports.Http = Http;
        exports.Loc = Loc;
        exports.Reflection = Reflection;
        exports.Runtime = Runtime;
        exports.Tag = Tag;
        exports.Text = Text;
        exports.Type = Type;
        exports.Uri = Uri;
        exports.Validation = Validation;
        exports.addClass = addClass;
        exports.addCustomEvent = addCustomEvent;
        exports.adjust = adjust;
        exports.ajax = ajax;
        exports.append = append;
        exports.bind = bind$1;
        exports.bindOnce = bindOnce$1;
        exports.browser = browser;
        exports.clean = clean;
        exports.cleanNode = cleanNode;
        exports.clone = clone$1;
        exports.create = create;
        exports.debounce = debounce;
        exports.debug = debug$1;
        exports.debugEnable = debugEnable;
        exports.debugEnableFlag = debugEnableFlag;
        exports.debugStatus = debugStatus;
        exports.getClass = getClass;
        exports.getCookie = getCookie;
        exports.hasClass = hasClass;
        exports.html = html;
        exports.insertAfter = insertAfter;
        exports.insertBefore = insertBefore;
        exports.isShown = isShown;
        exports.loadExt = loadExt;
        exports.message = message$1;
        exports.namespace = namespace;
        exports.onCustomEvent = onCustomEvent;
        exports.pos = pos;
        exports.prepend = prepend;
        exports.ready = ready$1;
        exports.remove = remove;
        exports.removeAllCustomEvents = removeAllCustomEvents;
        exports.removeClass = removeClass;
        exports.removeCustomEvent = removeCustomEvent;
        exports.replace = replace;
        exports.setCookie = setCookie;
        exports.style = style;
        exports.throttle = throttle;
        exports.toggleClass = toggleClass;
        exports.type = type;
        exports.unbind = unbind$1;
        exports.unbindAll = unbindAll$1;

    }(this.BX = this.BX || {}));



    (function(BX) {
        /* list of registered proxy functions */
        var proxyList = new WeakMap();
        var deferList = new WeakMap();

        /* List of denied event handlers */
        var deniedEvents = [];

        /* list of registered custom events */
        var customEvents = new WeakMap();
        var customEventsCnt = 0;

        /* list of external garbage collectors */
        var garbageCollectors = [];

        /* list of loaded CSS files */
        var cssList = [];
        var cssInit = false;

        /* list of loaded JS files */
        var jsList = [];
        var jsInit = false;

        var eventTypes = {
            click: 'MouseEvent',
            dblclick: 'MouseEvent',
            mousedown: 'MouseEvent',
            mousemove: 'MouseEvent',
            mouseout: 'MouseEvent',
            mouseover: 'MouseEvent',
            mouseup: 'MouseEvent',
            focus: 'MouseEvent',
            blur: 'MouseEvent'
        };

        var lastWait = [];

        var CHECK_FORM_ELEMENTS = {tagName: /^INPUT|SELECT|TEXTAREA|BUTTON$/i};

        var PRELOADING = 1;
        var PRELOADED = 2;
        var LOADING = 3;
        var LOADED = 4;
        var assets = {};
        var isAsync = null;

        BX.MSLEFT = 1;
        BX.MSMIDDLE = 2;
        BX.MSRIGHT = 4;

        BX.AM_PM_UPPER = 1;
        BX.AM_PM_LOWER = 2;
        BX.AM_PM_NONE = false;

        BX.ext = function(ob)
        {
            for (var i in ob)
            {
                if(ob.hasOwnProperty(i))
                {
                    this[i] = ob[i];
                }
            }
        };

        var r = {
            script: /<script([^>]*)>/ig,
            script_end: /<\/script>/ig,
            script_src: /src=["\']([^"\']+)["\']/i,
            script_type: /type=["\']([^"\']+)["\']/i,
            space: /\s+/,
            ltrim: /^[\s\r\n]+/g,
            rtrim: /[\s\r\n]+$/g,
            style: /<link.*?(rel="stylesheet"|type="text\/css")[^>]*>/i,
            style_href: /href=["\']([^"\']+)["\']/i
        };

        BX.processHTML = function(data, scriptsRunFirst)
        {
            var matchScript, matchStyle, matchSrc, matchHref, matchType, scripts = [], styles = [];
            var textIndexes = [];
            var lastIndex = r.script.lastIndex = r.script_end.lastIndex = 0;

            while ((matchScript = r.script.exec(data)) !== null)
            {
                r.script_end.lastIndex = r.script.lastIndex;
                var matchScriptEnd = r.script_end.exec(data);
                if (matchScriptEnd === null)
                {
                    break;
                }

                // skip script tags of special types
                var skipTag = false;
                if ((matchType = matchScript[1].match(r.script_type)) !== null)
                {
                    if(
                        matchType[1] == 'text/html'
                        || matchType[1] == 'text/template'
                        || matchType[1] == 'extension/settings'
                    )
                    {
                        skipTag = true;
                    }
                }

                if(skipTag)
                {
                    textIndexes.push([lastIndex, r.script_end.lastIndex - lastIndex]);
                }
                else
                {
                    textIndexes.push([lastIndex, matchScript.index - lastIndex]);

                    var bRunFirst = scriptsRunFirst || (matchScript[1].indexOf('bxrunfirst') != '-1');

                    if ((matchSrc = matchScript[1].match(r.script_src)) !== null)
                    {
                        scripts.push({"bRunFirst": bRunFirst, "isInternal": false, "JS": matchSrc[1]});
                    }
                    else
                    {
                        var start = matchScript.index + matchScript[0].length;
                        var js = data.substr(start, matchScriptEnd.index-start);

                        scripts.push({"bRunFirst": bRunFirst, "isInternal": true, "JS": js});
                    }
                }

                lastIndex = matchScriptEnd.index + 9;
                r.script.lastIndex = lastIndex;
            }

            textIndexes.push([lastIndex, lastIndex === 0 ? data.length : data.length - lastIndex]);
            var pureData = "";
            for (var i = 0, length = textIndexes.length; i < length; i++)
            {
                if (BX.type.isString(data) && BX.type.isFunction(data.substr))
                {
                    pureData += data.substr(textIndexes[i][0], textIndexes[i][1]);
                }
            }

            while ((matchStyle = pureData.match(r.style)) !== null)
            {
                if ((matchHref = matchStyle[0].match(r.style_href)) !== null && matchStyle[0].indexOf('media="') < 0)
                {
                    styles.push(matchHref[1]);
                }

                pureData = pureData.replace(matchStyle[0], '');
            }

            return {'HTML': pureData, 'SCRIPT': scripts, 'STYLE': styles};
        };

        /* OO emulation utility */
        BX.extend = function(child, parent)
        {
            var f = function() {};
            f.prototype = parent.prototype;

            child.prototype = new f();
            child.prototype.constructor = child;

            child.superclass = parent.prototype;
            child.prototype.superclass = parent.prototype;
            if(parent.prototype.constructor == Object.prototype.constructor)
            {
                parent.prototype.constructor = parent;
            }
        };

        BX.is_subclass_of = function(ob, parent_class)
        {
            if (ob instanceof parent_class)
                return true;

            if (parent_class.superclass)
                return BX.is_subclass_of(ob, parent_class.superclass);

            return false;
        };

        BX.clearNodeCache = function()
        {
            return false;
        };

        BX.bitrix_sessid = function() {return BX.message("bitrix_sessid"); };

        /**
         * Creates document fragment with child nodes.
         *
         * @param {Node[]} nodes
         * @return {DocumentFragment}
         */
        BX.createFragment = function(nodes)
        {
            var fragment = document.createDocumentFragment();

            if(!BX.type.isArray(nodes))
            {
                return fragment;
            }
            for(var i = 0; i < nodes.length; i++)
            {
                fragment.appendChild(nodes[i]);
            }

            return fragment;
        };

        /**
         * @deprecated
         * @use BX.style
         * @param element
         * @param opacity
         */
        BX.setOpacity = function(element, opacity)
        {
            var opacityValue = parseFloat(opacity);

            if (!isNaN(opacityValue) && BX.type.isDomNode(element))
            {
                opacityValue = opacityValue < 1 ? opacityValue : opacityValue / 100;
                BX.style(element, 'opacity', opacityValue);
            }
        };

        /**
         * @deprecated
         * @param el
         * @return {*}
         */
        BX.hoverEvents = function(el)
        {
            if (el)
                return BX.adjust(el, {events: BX.hoverEvents()});
            else
                return {mouseover: BX.hoverEventsHover, mouseout: BX.hoverEventsHout};
        };

        /**
         * @deprecated
         */
        BX.hoverEventsHover = function(){BX.addClass(this,'bx-hover');this.BXHOVER=true;};
        /**
         * @deprecated
         */
        BX.hoverEventsHout = function(){BX.removeClass(this,'bx-hover');this.BXHOVER=false;};

        /**
         * @deprecated
         */
        BX.focusEvents = function(el)
        {
            if (el)
                return BX.adjust(el, {events: BX.focusEvents()});
            else
                return {mouseover: BX.focusEventsFocus, mouseout: BX.focusEventsBlur};
        };

        /**
         * @deprecated
         */
        BX.focusEventsFocus = function(){BX.addClass(this,'bx-focus');this.BXFOCUS=true;};
        /**
         * @deprecated
         */
        BX.focusEventsBlur = function(){BX.removeClass(this,'bx-focus');this.BXFOCUS=false;};

        BX.setUnselectable = function(node)
        {
            BX.style(node, {
                'userSelect': 'none',
                'MozUserSelect': 'none',
                'WebkitUserSelect': 'none',
                'KhtmlUserSelect': 'none',
            });
            node.setAttribute('unSelectable', 'on');
        };

        BX.setSelectable = function(node)
        {
            BX.style(node, {
                'userSelect': null,
                'MozUserSelect': null,
                'WebkitUserSelect': null,
                'KhtmlUserSelect': null,
            });
            node.removeAttribute('unSelectable');
        };

        BX.styleIEPropertyName = function(name)
        {
            if (name == 'float')
                name = BX.browser.IsIE() ? 'styleFloat' : 'cssFloat';
            else
            {
                var res = BX.browser.isPropertySupported(name);
                if (res)
                {
                    name = res;
                }
                else
                {
                    var reg = /(\-([a-z]){1})/g;
                    if (reg.test(name))
                    {
                        name = name.replace(reg, function () {return arguments[2].toUpperCase();});
                    }
                }
            }
            return name;
        };

        BX.focus = function(el)
        {
            try
            {
                el.focus();
                return true;
            }
            catch (e)
            {
                return false;
            }
        };

        BX.firstChild = function(el)
        {
            return BX.type.isDomNode(el) ? el.firstElementChild : null;
        };

        BX.lastChild = function(el)
        {
            return BX.type.isDomNode(el) ? el.lastElementChild : null;
        };

        BX.previousSibling = function(el)
        {
            return BX.type.isDomNode(el) ? el.previousElementSibling : null;
        };

        BX.nextSibling = function(el)
        {
            return BX.type.isDomNode(el) ? el.nextElementSibling : null;
        };

        /*
		params: {
			obj : html node
			className : className value
			recursive : used only for older browsers to optimize the tree traversal, in new browsers the search is always recursively, default - true
		}

		Search all nodes with className
	*/
        /**
         * @deprecated
         * @use .querySelectorAll
         * @param obj
         * @param className
         * @param recursive
         * @return {*}
         */
        BX.findChildrenByClassName = function(obj, className, recursive)
        {
            if(!obj || !obj.childNodes) return null;

            var result = [];
            if (typeof(obj.getElementsByClassName) == 'undefined')
            {
                recursive = recursive !== false;
                result = BX.findChildren(obj, {className : className}, recursive);
            }
            else
            {
                var col = obj.getElementsByClassName(className);
                for (i=0,l=col.length;i<l;i++)
                {
                    result[i] = col[i];
                }
            }
            return result;
        };

        /*
		params: {
			obj : html node
			className : className value
			recursive : used only for older browsers to optimize the tree traversal, in new browsers the search is always recursively, default - true
		}

		Search first node with className
	*/
        /**
         * @deprecated
         * @use .querySelector
         * @param obj
         * @param className
         * @param recursive
         * @return {*}
         */
        BX.findChildByClassName = function(obj, className, recursive)
        {
            if(!obj || !obj.childNodes) return null;

            var result = null;
            if (typeof(obj.getElementsByClassName) == 'undefined')
            {
                recursive = recursive !== false;
                result = BX.findChild(obj, {className : className}, recursive);
            }
            else
            {
                var col = obj.getElementsByClassName(className);
                if (col && typeof(col[0]) != 'undefined')
                {
                    result = col[0];
                }
                else
                {
                    result = null;
                }
            }
            return result;
        };

        /*
		params: {
			tagName|tag : 'tagName',
			className|class : 'className',
			attribute : {attribute : value, attribute : value} | attribute | [attribute, attribute....],
			property : {prop: value, prop: value} | prop | [prop, prop]
		}

		all values can be RegExps or strings
	*/
        /**
         * @deprecated
         * @use .querySelectorAll
         * @param obj
         * @param params
         * @param recursive
         * @return {*|Node}
         */
        BX.findChildren = function(obj, params, recursive)
        {
            return BX.findChild(obj, params, recursive, true);
        };

        /**
         * @deprecated
         * @use .querySelectorAll
         * @param obj
         * @param params
         * @param recursive
         * @param get_all
         * @return {*}
         */
        BX.findChild = function(obj, params, recursive, get_all)
        {
            if(!obj || !obj.childNodes) return null;

            recursive = !!recursive; get_all = !!get_all;

            var n = obj.childNodes.length, result = [];

            for (var j=0; j<n; j++)
            {
                var child = obj.childNodes[j];

                if (_checkNode(child, params))
                {
                    if (get_all)
                        result.push(child);
                    else
                        return child;
                }

                if(recursive == true)
                {
                    var res = BX.findChild(child, params, recursive, get_all);
                    if (res)
                    {
                        if (get_all)
                            result = BX.util.array_merge(result, res);
                        else
                            return res;
                    }
                }
            }

            if (get_all || result.length > 0)
                return result;
            else
                return null;
        };

        /**
         * @deprecated
         * @use .closest()
         * @param obj
         * @param params
         * @param maxParent
         * @return {*}
         */
        BX.findParent = function(obj, params, maxParent)
        {
            if(!obj)
                return null;

            var o = obj;
            while(o.parentNode)
            {
                var parent = o.parentNode;

                if (_checkNode(parent, params))
                    return parent;

                o = parent;

                if (!!maxParent &&
                    (BX.type.isFunction(maxParent)
                        || typeof maxParent == 'object'))
                {
                    if (BX.type.isElementNode(maxParent))
                    {
                        if (o == maxParent)
                            break;
                    }
                    else
                    {
                        if (_checkNode(o, maxParent))
                            break;
                    }
                }
            }
            return null;
        };

        /**
         * @deprecated
         * @use .querySelector
         * @param obj
         * @param params
         * @return {*}
         */
        BX.findNextSibling = function(obj, params)
        {
            if(!obj)
                return null;
            var o = obj;
            while(o.nextSibling)
            {
                var sibling = o.nextSibling;
                if (_checkNode(sibling, params))
                    return sibling;
                o = sibling;
            }
            return null;
        };

        /**
         * @deprecated
         * @use .querySelector
         * @param obj
         * @param params
         * @return {*}
         */
        BX.findPreviousSibling = function(obj, params)
        {
            if(!obj)
                return null;

            var o = obj;
            while(o.previousSibling)
            {
                var sibling = o.previousSibling;
                if(_checkNode(sibling, params))
                    return sibling;
                o = sibling;
            }
            return null;
        };

        BX.checkNode = function(obj, params)
        {
            return _checkNode(obj, params);
        };

        /**
         * @deprecated
         * @use .querySelectorAll
         * @param form
         * @return {Array}
         */
        BX.findFormElements = function(form)
        {
            if (BX.type.isString(form))
                form = document.forms[form]||BX(form);

            var res = [];

            if (BX.type.isElementNode(form))
            {
                if (form.tagName.toUpperCase() == 'FORM')
                {
                    res = form.elements;
                }
                else
                {
                    res = BX.findChildren(form, CHECK_FORM_ELEMENTS, true);
                }
            }

            return res;
        };

        /**
         * @deprecated
         * @use .contains()
         * @param whichNode
         * @param forNode
         * @return {boolean}
         */
        BX.isParentForNode = function(whichNode, forNode)
        {
            if (BX.type.isDomNode(whichNode) && BX.type.isDomNode(forNode))
            {
                return whichNode.contains(forNode);
            }

            return false;
        };

        BX.getCaretPosition = function(node)
        {
            var pos = 0;

            if(node.selectionStart || node.selectionStart == 0)
            {
                pos = node.selectionStart;
            }
            else if(document.selection)
            {
                node.focus();
                var selection = document.selection.createRange();
                selection.moveStart('character', -node.value.length);
                pos = selection.text.length;
            }

            return (pos);
        };

        BX.setCaretPosition = function(node, pos)
        {
            if(!BX.isNodeInDom(node) || BX.isNodeHidden(node) || node.disabled)
            {
                return;
            }

            if(node.setSelectionRange)
            {
                node.focus();
                node.setSelectionRange(pos, pos);
            }
            else if(node.createTextRange)
            {
                var range = node.createTextRange();
                range.collapse(true);
                range.moveEnd('character', pos);
                range.moveStart('character', pos);
                range.select();
            }
        };

        // access private. use BX.mergeEx instead.
        // todo: refactor BX.merge, make it work through BX.mergeEx
        BX.merge = function(){
            var arg = Array.prototype.slice.call(arguments);

            if(arg.length < 2)
                return {};

            var result = arg.shift();

            for(var i = 0; i < arg.length; i++)
            {
                for(var k in arg[i]){

                    if(typeof arg[i] == 'undefined' || arg[i] == null)
                        continue;

                    if(arg[i].hasOwnProperty(k)){

                        if(typeof arg[i][k] == 'undefined' || arg[i][k] == null)
                            continue;

                        if(typeof arg[i][k] == 'object' && !BX.type.isDomNode(arg[i][k]) && (typeof arg[i][k]['isUIWidget'] == 'undefined')){

                            // go deeper

                            var isArray = 'length' in arg[i][k];

                            if(typeof result[k] != 'object')
                                result[k] = isArray ? [] : {};

                            if(isArray)
                                BX.util.array_merge(result[k], arg[i][k]);
                            else
                                BX.merge(result[k], arg[i][k]);

                        }else
                            result[k] = arg[i][k];
                    }
                }
            }

            return result;
        };

        BX.mergeEx = function()
        {
            var arg = Array.prototype.slice.call(arguments);
            if(arg.length < 2)
            {
                return {};
            }

            var result = arg.shift();
            for (var i = 0; i < arg.length; i++)
            {
                for (var k in arg[i])
                {
                    if (typeof arg[i] == "undefined" || arg[i] == null || !arg[i].hasOwnProperty(k))
                    {
                        continue;
                    }

                    if (BX.type.isPlainObject(arg[i][k]) && BX.type.isPlainObject(result[k]))
                    {
                        BX.mergeEx(result[k], arg[i][k]);
                    }
                    else
                    {
                        result[k] = BX.type.isPlainObject(arg[i][k]) ? BX.clone(arg[i][k]) : arg[i][k];
                    }
                }
            }

            return result;
        };

        BX.getEventButton = function(e)
        {
            e = e || window.event;

            var flags = 0;

            if (typeof e.which != 'undefined')
            {
                switch (e.which)
                {
                    case 1: flags = flags|BX.MSLEFT; break;
                    case 2: flags = flags|BX.MSMIDDLE; break;
                    case 3: flags = flags|BX.MSRIGHT; break;
                }
            }
            else if (typeof e.button != 'undefined')
            {
                flags = event.button;
            }

            return flags || BX.MSLEFT;
        };

        var captured_events = null, _bind = null;
        BX.CaptureEvents = function(el_c, evname_c)
        {
            if (_bind)
                return;

            _bind = BX.bind;
            captured_events = [];

            BX.bind = function(el, evname, func)
            {
                if (el === el_c && evname === evname_c)
                    captured_events.push(func);

                _bind.apply(this, arguments);
            }
        };

        BX.CaptureEventsGet = function()
        {
            if (_bind)
            {
                BX.bind = _bind;

                var captured = captured_events;

                _bind = null;
                captured_events = null;
                return captured;
            }
            return null;
        };

        // Don't even try to use it for submit event!
        BX.fireEvent = function(ob,ev)
        {
            var result = false, e = null;
            if (BX.type.isDomNode(ob))
            {
                result = true;
                if (document.createEventObject)
                {
                    // IE
                    if (eventTypes[ev] != 'MouseEvent')
                    {
                        e = document.createEventObject();
                        e.type = ev;
                        result = ob.fireEvent('on' + ev, e);
                    }

                    if (ob[ev])
                    {
                        ob[ev]();
                    }
                }
                else
                {
                    // non-IE
                    e = null;

                    switch (eventTypes[ev])
                    {
                        case 'MouseEvent':
                            e = document.createEvent('MouseEvent');
                            try
                            {
                                e.initMouseEvent(ev, true, true, top, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, null);
                            }
                            catch (initException)
                            {
                                e.initMouseEvent(ev, true, true, window, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, null);
                            }

                            break;
                        default:
                            e = document.createEvent('Event');
                            e.initEvent(ev, true, true);
                    }

                    result = ob.dispatchEvent(e);
                }
            }

            return result;
        };

        BX.getWheelData = function(e)
        {
            e = e || window.event;
            e.wheelData = e.detail ? e.detail * -1 : e.wheelDelta / 40;
            return e.wheelData;
        };

        BX.proxy_context = null;

        BX.delegate = function (func, thisObject)
        {
            if (!func || !thisObject)
                return func;

            return function() {
                var cur = BX.proxy_context;
                BX.proxy_context = this;
                var res = func.apply(thisObject, arguments);
                BX.proxy_context = cur;
                return res;
            }
        };

        BX.delegateLater = function (func_name, thisObject, contextObject)
        {
            return function()
            {
                if (thisObject[func_name])
                {
                    var cur = BX.proxy_context;
                    BX.proxy_context = this;
                    var res = thisObject[func_name].apply(contextObject||thisObject, arguments);
                    BX.proxy_context = cur;
                    return res;
                }
                return null;
            }
        };

        BX.proxy = function(func, thisObject)
        {
            return getObjectDelegate(func, thisObject, proxyList);
        };

        BX.defer = function(func, thisObject)
        {
            if (!!thisObject)
                return BX.defer_proxy(func, thisObject);
            else
                return function() {
                    var arg = arguments;
                    setTimeout(function(){func.apply(this,arg)}, 10);
                };
        };

        BX.defer_proxy = function(func, thisObject)
        {
            return getObjectDelegate(func, thisObject, deferList, BX.defer);
        };

        /**
         *
         * @private
         */
        function getObjectDelegate(func, thisObject, collection, decorator)
        {
            if (!BX.type.isFunction(func) || !BX.type.isMapKey(thisObject))
            {
                return func;
            }

            var objectDelegates = collection.get(thisObject);
            if (!objectDelegates)
            {
                objectDelegates = new WeakMap();
                collection.set(thisObject, objectDelegates);
            }

            var delegate = objectDelegates.get(func);
            if (!delegate)
            {
                delegate = decorator ? decorator(BX.delegate(func, thisObject)) : BX.delegate(func, thisObject);
                objectDelegates.set(func, delegate);
            }

            return delegate;
        }

        BX.once = function(el, evname, func)
        {
            var fn = function()
            {
                BX.unbind(el, evname, fn);
                func.apply(this, arguments);
            };

            return fn;
        };

        BX.bindDelegate = function (elem, eventName, isTarget, handler)
        {
            var h = BX.delegateEvent(isTarget, handler);
            BX.bind(elem, eventName, h);
            return h;
        };

        BX.delegateEvent = function(isTarget, handler)
        {
            return function(e)
            {
                e = e || window.event;
                var target = e.target || e.srcElement;

                while (target != this)
                {
                    if (_checkNode(target, isTarget))
                    {
                        return handler.call(target, e);
                    }
                    if (target && target.parentNode)
                        target = target.parentNode;
                    else
                        break;
                }
                return null;
            }
        };

        BX.False = function() {return false;};
        BX.DoNothing = function() {};

        // TODO: also check event handlers set via BX.bind()
        BX.denyEvent = function(el, ev)
        {
            deniedEvents.push([el, ev, el['on' + ev]]);
            el['on' + ev] = BX.DoNothing;
        };

        BX.allowEvent = function(el, ev)
        {
            for(var i=0, len=deniedEvents.length; i<len; i++)
            {
                if (deniedEvents[i][0] == el && deniedEvents[i][1] == ev)
                {
                    el['on' + ev] = deniedEvents[i][2];
                    BX.util.deleteFromArray(deniedEvents, i);
                    return;
                }
            }
        };

        BX.fixEventPageXY = function(event)
        {
            BX.fixEventPageX(event);
            BX.fixEventPageY(event);
            return event;
        };

        BX.fixEventPageX = function(event)
        {
            if (event.pageX == null && event.clientX != null)
            {
                event.pageX =
                    event.clientX +
                    (document.documentElement && document.documentElement.scrollLeft || document.body && document.body.scrollLeft || 0) -
                    (document.documentElement.clientLeft || 0);
            }

            return event;
        };

        BX.fixEventPageY = function(event)
        {
            if (event.pageY == null && event.clientY != null)
            {
                event.pageY =
                    event.clientY +
                    (document.documentElement && document.documentElement.scrollTop || document.body && document.body.scrollTop || 0) -
                    (document.documentElement.clientTop || 0);
            }

            return event;
        };

        /**
         * @deprecated
         * @see e.preventDefault()
         */
        BX.PreventDefault = function(e)
        {
            if(!e) e = window.event;
            if(e.stopPropagation)
            {
                e.preventDefault();
                e.stopPropagation();
            }
            else
            {
                e.cancelBubble = true;
                e.returnValue = false;
            }
            return false;
        };

        /**
         * @deprecated
         * @see e.preventDefault();
         *
         * @param e
         * @return {boolean}
         */
        BX.eventReturnFalse = function(e)
        {
            e=e||window.event;
            if (e && e.preventDefault) e.preventDefault();
            else e.returnValue = false;
            return false;
        };

        /**
         * @deprecated
         * @see e.stopPropagation()
         * @param e
         */
        BX.eventCancelBubble = function(e)
        {
            e=e||window.event;
            if(e && e.stopPropagation)
                e.stopPropagation();
            else
                e.cancelBubble = true;
        };

        BX.bindDebouncedChange = function(node, fn, fnInstant, timeout, ctx)
        {
            ctx = ctx || window;
            timeout = timeout || 300;

            var dataTag = 'bx-dc-previous-value';
            BX.data(node, dataTag, node.value);

            var act = function(fn, val){

                var pVal = BX.data(node, dataTag);

                if(typeof pVal == 'undefined' || pVal != val){
                    if(typeof ctx != 'object')
                        fn(val);
                    else
                        fn.apply(ctx, [val]);
                }
            };

            var actD = BX.debounce(function(){
                var val = node.value;
                act(fn, val);
                BX.data(node, dataTag, val);
            }, timeout);

            BX.bind(node, 'keyup', actD);
            BX.bind(node, 'change', actD);
            BX.bind(node, 'input', actD);

            if(BX.type.isFunction(fnInstant)){

                var actI = function(){
                    act(fnInstant, node.value);
                };

                BX.bind(node, 'keyup', actI);
                BX.bind(node, 'change', actI);
                BX.bind(node, 'input', actI);
            }
        };

        BX.parseJSON = function(data, context)
        {
            var result = null;
            if (BX.type.isNotEmptyString(data))
            {
                try {
                    if (data.indexOf("\n") >= 0)
                        eval('result = ' + data);
                    else
                        result = (new Function("return " + data))();
                } catch(e) {
                    BX.onCustomEvent(context, 'onParseJSONFailure', [data, context])
                }
            }
            else if(BX.type.isPlainObject(data))
            {
                return data;
            }

            return result;
        };

        BX.submit = function(obForm, action_name, action_value, onAfterSubmit)
        {
            action_name = action_name || 'save';
            if (!obForm['BXFormSubmit_' + action_name])
            {
                obForm['BXFormSubmit_' + action_name] = obForm.appendChild(BX.create('INPUT', {
                    'props': {
                        'type': 'submit',
                        'name': action_name,
                        'value': action_value || 'Y'
                    },
                    'style': {
                        'display': 'none'
                    }
                }));
            }

            if (obForm.sessid)
                obForm.sessid.value = BX.bitrix_sessid();

            setTimeout(BX.delegate(function() {BX.fireEvent(this, 'click'); if (onAfterSubmit) onAfterSubmit();}, obForm['BXFormSubmit_' + action_name]), 10);
        };

        BX.show = function(ob, displayType)
        {
            if (ob.BXDISPLAY || !_checkDisplay(ob, displayType))
            {
                ob.style.display = ob.BXDISPLAY;
            }
        };

        BX.hide = function(ob, displayType)
        {
            if (!ob.BXDISPLAY)
                _checkDisplay(ob, displayType);

            ob.style.display = 'none';
        };

        BX.toggle = function(ob, values)
        {
            if (!values && BX.type.isElementNode(ob))
            {
                var bShow = true;
                if (ob.BXDISPLAY)
                    bShow = !_checkDisplay(ob);
                else
                    bShow = ob.style.display == 'none';

                if (bShow)
                    BX.show(ob);
                else
                    BX.hide(ob);
            }
            else if (BX.type.isArray(values))
            {
                for (var i=0,len=values.length; i<len; i++)
                {
                    if (ob == values[i])
                    {
                        ob = values[i==len-1 ? 0 : i+1];
                        break;
                    }
                }
                if (i==len)
                    ob = values[0];
            }

            return ob;
        };

        function _checkDisplay(ob, displayType)
        {
            if (typeof displayType != 'undefined')
                ob.BXDISPLAY = displayType;

            var d = ob.style.display || BX.style(ob, 'display');
            if (d != 'none')
            {
                ob.BXDISPLAY = ob.BXDISPLAY || d;
                return true;
            }
            else
            {
                ob.BXDISPLAY = ob.BXDISPLAY || 'block';
                return false;
            }
        }

        /* some useful util functions */

        BX.util = {
            /**
             * @deprecated
             * @use [].filter(value => !BX.Type.isNil(value))
             * @param ar
             * @return {*}
             */
            array_values: function(ar)
            {
                if (!BX.type.isArray(ar))
                    return BX.util._array_values_ob(ar);
                var arv = [];
                for(var i=0,l=ar.length;i<l;i++)
                    if (ar[i] !== null && typeof ar[i] != 'undefined')
                        arv.push(ar[i]);
                return arv;
            },

            /**
             * @deprecated
             * @use Object.values([]).filter(value => !BX.Type.isNil(value))
             * @param ar
             * @return {Array}
             * @private
             */
            _array_values_ob: function(ar)
            {
                var arv = [];
                for(var i in ar)
                    if (ar[i] !== null && typeof ar[i] != 'undefined')
                        arv.push(ar[i]);
                return arv;
            },

            /**
             * @deprecated
             * @use
             * @param ar
             * @return {*}
             */
            array_keys: function(ar)
            {
                if (!BX.type.isArray(ar))
                    return BX.util._array_keys_ob(ar);
                var arv = [];
                for(var i=0,l=ar.length;i<l;i++)
                    if (ar[i] !== null && typeof ar[i] != 'undefined')
                        arv.push(i);
                return arv;
            },

            _array_keys_ob: function(ar)
            {
                var arv = [];
                for(var i in ar)
                    if (ar[i] !== null && typeof ar[i] != 'undefined')
                        arv.push(i);
                return arv;
            },

            object_keys: function(obj)
            {
                var arv = [];
                for(var k in obj)
                {
                    if(obj.hasOwnProperty(k))
                    {
                        arv.push(k);
                    }
                }
                return arv;
            },

            /**
             * @deprecated
             * @use firstArr.concat(secondArr);
             * @param first
             * @param second
             * @return {*[]}
             */
            array_merge: function(first, second)
            {
                if (!BX.type.isArray(first)) first = [];
                if (!BX.type.isArray(second)) second = [];

                var i = first.length, j = 0;

                if (typeof second.length === "number")
                {
                    for (var l = second.length; j < l; j++)
                    {
                        first[i++] = second[j];
                    }
                }
                else
                {
                    while (second[j] !== undefined)
                    {
                        first[i++] = second[j++];
                    }
                }

                first.length = i;

                return first;
            },

            array_flip: function (object)
            {
                var newObject = {};

                for (var key in object)
                {
                    newObject[object[key]] = key;
                }

                return newObject;
            },

            array_diff: function(ar1, ar2, hash)
            {
                hash = BX.type.isFunction(hash) ? hash : null;
                var i, length, v, h, map = {}, result = [];
                for(i = 0, length = ar2.length; i < length; i++)
                {
                    v = ar2[i];
                    h = hash ? hash(v) : v;
                    map[h] = true;
                }

                for(i = 0, length = ar1.length; i < length; i++)
                {
                    v = ar1[i];
                    h = hash ? hash(v) : v;
                    if(typeof(map[h]) === "undefined")
                    {
                        result.push(v);
                    }
                }
                return result;
            },

            /**
             * @deprecated
             * @use Set
             */
            array_unique: function(ar)
            {
                var i=0,j,len=ar.length;
                if(len<2) return ar;

                for (; i<len-1;i++)
                {
                    for (j=i+1; j<len;j++)
                    {
                        if (ar[i]==ar[j])
                        {
                            ar.splice(j--,1); len--;
                        }
                    }
                }

                return ar;
            },

            /**
             * @deprecated
             * @use myArr.includes(needle)
             */
            in_array: function(needle, haystack)
            {
                for(var i=0; i<haystack.length; i++)
                {
                    if(haystack[i] == needle)
                        return true;
                }
                return false;
            },

            /**
             * @deprecated
             * @use myArr.findIndex(item => item === needle);
             */
            array_search: function(needle, haystack)
            {
                for(var i=0; i<haystack.length; i++)
                {
                    if(haystack[i] == needle)
                        return i;
                }
                return -1;
            },

            object_search_key: function(needle, haystack)
            {
                if (typeof haystack[needle] != 'undefined')
                    return haystack[needle];

                for(var i in haystack)
                {
                    if (typeof haystack[i] == "object")
                    {
                        var result = BX.util.object_search_key(needle, haystack[i]);
                        if (result !== false)
                            return result;
                    }
                }
                return false;
            },

            trim: function(s)
            {
                if (BX.type.isString(s))
                {
                    return s.trim();
                }

                return s;
            },

            urlencode: function(s){return encodeURIComponent(s);},

            // it may also be useful. via sVD.
            deleteFromArray: function(ar, ind) {return ar.slice(0, ind).concat(ar.slice(ind + 1));},
            insertIntoArray: function(ar, ind, el) {return ar.slice(0, ind).concat([el]).concat(ar.slice(ind));},

            htmlspecialchars: function(str)
            {
                return BX.Text.encode(str);
            },

            htmlspecialcharsback: function(str)
            {
                return BX.Text.decode(str);
            },

            // Quote regular expression characters plus an optional character
            preg_quote: function(str, delimiter)
            {
                if(!str.replace)
                    return str;
                return str.replace(new RegExp('[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\' + (delimiter || '') + '-]', 'g'), '\\$&');
            },

            jsencode: function(str)
            {
                if (!str || !str.replace)
                    return str;

                var escapes =
                    [
                        { c: "\\\\", r: "\\\\" }, // should be first
                        { c: "\\t", r: "\\t" },
                        { c: "\\n", r: "\\n" },
                        { c: "\\r", r: "\\r" },
                        { c: "\"", r: "\\\"" },
                        { c: "'", r: "\\'" },
                        { c: "<", r: "\\x3C" },
                        { c: ">", r: "\\x3E" },
                        { c: "\\u2028", r: "\\u2028" },
                        { c: "\\u2029", r: "\\u2029" }
                    ];
                for (var i = 0; i < escapes.length; i++)
                    str = str.replace(new RegExp(escapes[i].c, 'g'), escapes[i].r);
                return str;
            },

            getCssName: function(jsName)
            {
                if (!BX.type.isNotEmptyString(jsName))
                {
                    return "";
                }

                return jsName.replace(/[A-Z]/g, function(match) {
                    return "-" + match.toLowerCase();
                });
            },

            getJsName: function(cssName)
            {
                var regex = /\-([a-z]){1}/g;
                if (regex.test(cssName))
                {
                    return cssName.replace(regex, function(match, letter) {
                        return letter.toUpperCase();
                    });
                }

                return cssName;
            },

            nl2br: function(str)
            {
                if (!str || !str.replace)
                    return str;

                return str.replace(/([^>])\n/g, '$1<br/>');
            },

            /**
             * @deprecated
             * @use .padStart() / .padEnd()
             * @param input
             * @param pad_length
             * @param pad_string
             * @param pad_type
             * @return {*}
             */
            str_pad: function(input, pad_length, pad_string, pad_type)
            {
                pad_string = pad_string || ' ';
                pad_type = pad_type || 'right';
                input = input.toString();

                if (pad_type === 'left')
                {
                    return BX.util.str_pad_left(input, pad_length, pad_string);
                }

                return BX.util.str_pad_right(input, pad_length, pad_string);
            },

            str_pad_left: function(input, pad_length, pad_string)
            {
                return input.toString().padStart(pad_length, pad_string);
            },

            str_pad_right: function(input, pad_length, pad_string)
            {
                return input.toString().padEnd(pad_length, pad_string);
            },

            strip_tags: function(str)
            {
                return str.split(/<[^>]+>/g).join('');
            },

            strip_php_tags: function(str)
            {
                return str.replace(/<\?(.|[\r\n])*?\?>/g, '');
            },

            popup: function(url, width, height)
            {
                var w, h;
                if(BX.browser.IsOpera())
                {
                    w = document.body.offsetWidth;
                    h = document.body.offsetHeight;
                }
                else
                {
                    w = screen.width;
                    h = screen.height;
                }
                return window.open(url, '', 'status=no,scrollbars=yes,resizable=yes,width='+width+',height='+height+',top='+Math.floor((h - height)/2-14)+',left='+Math.floor((w - width)/2-5));
            },

            shuffle: function(array)
            {
                var temporaryValue, randomIndex;
                var currentIndex = array.length;

                while (0 !== currentIndex)
                {
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex -= 1;

                    temporaryValue = array[currentIndex];
                    array[currentIndex] = array[randomIndex];
                    array[randomIndex] = temporaryValue;
                }

                return array;
            },

            // BX.util.objectSort(object, sortBy, sortDir) - Sort object by property
            // function params: 1 - object for sort, 2 - sort by property, 3 - sort direction (asc/desc)
            // return: sort array [[objectElement], [objectElement]] in sortDir direction

            // example: BX.util.objectSort({'L1': {'name': 'Last'}, 'F1': {'name': 'First'}}, 'name', 'asc');
            // return: [{'name' : 'First'}, {'name' : 'Last'}]
            objectSort: function(object, sortBy, sortDir)
            {
                sortDir = sortDir == 'asc'? 'asc': 'desc';

                var arItems = [], i;
                for (i in object)
                {
                    if (object.hasOwnProperty(i) && object[i][sortBy])
                    {
                        arItems.push([i, object[i][sortBy]]);
                    }
                }

                if (sortDir == 'asc')
                {
                    arItems.sort(function(i, ii) {
                        var s1, s2;
                        if (BX.type.isDate(i[1]))
                        {
                            s1 = i[1].getTime();
                        }
                        else if (!isNaN(i[1]))
                        {
                            s1 = parseInt(i[1]);
                        }
                        else
                        {
                            s1 = i[1].toString().toLowerCase();
                        }

                        if (BX.type.isDate(ii[1]))
                        {
                            s2 = ii[1].getTime();
                        }
                        else if (!isNaN(ii[1]))
                        {
                            s2 = parseInt(ii[1]);
                        }
                        else
                        {
                            s2 = ii[1].toString().toLowerCase();
                        }

                        if (s1 > s2)
                            return 1;
                        else if (s1 < s2)
                            return -1;
                        else
                            return 0;
                    });
                }
                else
                {
                    arItems.sort(function(i, ii) {
                        var s1, s2;
                        if (BX.type.isDate(i[1]))
                        {
                            s1 = i[1].getTime();
                        }
                        else if (!isNaN(i[1]))
                        {
                            s1 = parseInt(i[1]);
                        }
                        else
                        {
                            s1 = i[1].toString().toLowerCase();
                        }

                        if (BX.type.isDate(ii[1]))
                        {
                            s2 = ii[1].getTime();
                        }
                        else if (!isNaN(ii[1]))
                        {
                            s2 = parseInt(ii[1]);
                        }
                        else
                        {
                            s2 = ii[1].toString().toLowerCase();
                        }

                        if (s1 < s2)
                            return 1;
                        else if (s1 > s2)
                            return -1;
                        else
                            return 0;
                    });
                }

                var arReturnArray = Array();
                for (i = 0; i < arItems.length; i++)
                {
                    arReturnArray.push(object[arItems[i][0]]);
                }

                return arReturnArray;
            },

            objectMerge: function()
            {
                return BX.mergeEx.apply(window, arguments);
            },

            objectClone : function(object)
            {
                return BX.clone(object, true);
            },

            // #fdf9e5 => {r=253, g=249, b=229}
            hex2rgb: function(color)
            {
                var rgb = color.replace(/[# ]/g,"").replace(/^(.)(.)(.)$/,'$1$1$2$2$3$3').match(/.{2}/g);
                for (var i=0;  i<3; i++)
                {
                    rgb[i] = parseInt(rgb[i], 16);
                }
                return {'r':rgb[0],'g':rgb[1],'b':rgb[2]};
            },

            /**
             * @deprecated
             * @use BX.Uri
             * @param url
             * @param param
             * @return {string}
             */
            remove_url_param: function(url, param)
            {
                return BX.Uri.removeParam(url, param);
            },

            /*
		{'param1': 'value1', 'param2': 'value2'}
		 */
            /**
             * @deprecated
             * @use BX.Uri
             * @param url
             * @param params
             * @return {string}
             */
            add_url_param: function(url, params)
            {
                var preparedParams = Object.entries(params).reduce(function(acc, item) {
                    acc[item[0]] = BX.type.isArray(item[1]) ? item[1].join() : item[1];
                    return acc;
                }, {});

                return BX.Uri.addParam(url, preparedParams);
            },

            /*
	{'param1': 'value1', 'param2': 'value2'}
	 */
            buildQueryString: function(params)
            {
                var result = '';
                for (var key in params)
                {
                    var value = params[key];
                    if(BX.type.isArray(value))
                    {
                        value.forEach(function(valueElement, index)
                        {
                            result += encodeURIComponent(key + "[" + index + "]") + "=" + encodeURIComponent(valueElement) + "&";
                        });
                    }
                    else
                    {
                        result += encodeURIComponent(key) + "=" + encodeURIComponent(value) + "&";
                    }
                }

                if(result.length > 0)
                {
                    result = result.substr(0, result.length - 1);
                }
                return result;
            },

            even: function(digit)
            {
                return (parseInt(digit) % 2 == 0);
            },

            hashCode: function(str)
            {
                if(!BX.type.isNotEmptyString(str))
                {
                    return 0;
                }

                var hash = 0;
                for (var i = 0; i < str.length; i++)
                {
                    var c = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + c;
                    hash = hash & hash;
                }
                return hash;
            },

            getRandomString: function (length)
            {
                return BX.Text.getRandom(length);
            },

            number_format: function(number, decimals, dec_point, thousands_sep)
            {
                var i, j, kw, kd, km, sign = '';
                decimals = Math.abs(decimals);
                if (isNaN(decimals) || decimals < 0)
                {
                    decimals = 2;
                }
                dec_point = dec_point || ',';
                if (typeof thousands_sep === 'undefined')
                    thousands_sep = '.';

                number = (+number || 0).toFixed(decimals);
                if (number < 0)
                {
                    sign = '-';
                    number = -number;
                }

                i = parseInt(number, 10) + '';
                j = (i.length > 3 ? i.length % 3 : 0);

                km = (j ? i.substr(0, j) + thousands_sep : '');
                kw = i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + thousands_sep);
                kd = (decimals ? dec_point + Math.abs(number - i).toFixed(decimals).replace(/-/, '0').slice(2) : '');

                return sign + km + kw + kd;
            },

            getExtension: function (url)
            {
                url = url || "";
                var items = url.split("?")[0].split(".");
                return items[items.length-1].toLowerCase();
            },
            addObjectToForm: function(object, form, prefix)
            {
                if(!BX.type.isString(prefix))
                {
                    prefix = "";
                }

                for(var key in object)
                {
                    if(!object.hasOwnProperty(key))
                    {
                        continue;
                    }

                    var value = object[key];
                    var name = prefix !== "" ? (prefix + "[" + key + "]") : key;
                    if(BX.type.isArray(value))
                    {
                        var obj = {};
                        for(var i = 0; i < value.length; i++)
                        {
                            obj[i] = value[i];
                        }

                        BX.util.addObjectToForm(obj, form, name);
                    }
                    else if(BX.type.isPlainObject(value))
                    {
                        BX.util.addObjectToForm(value, form, name);
                    }
                    else
                    {
                        value = BX.type.isFunction(value.toString) ? value.toString() : "";
                        if(value !== "")
                        {
                            form.appendChild(BX.create("INPUT", { attrs: { type: "hidden", name: name, value: value } }));
                        }
                    }
                }
            },

            observe: function(object, enable)
            {
                console.error('BX.util.observe: function is no longer supported by browser.');
                return false;
            },

            escapeRegExp: function(str)
            {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            }
        };

        BX.validation = {
            checkIfEmail: function(s)
            {
                var atom = "[=a-z0-9_+~'!$&*^`|#%/?{}-]";
                return (new RegExp('^\\s*'+atom+'+(\\.'+atom+'+)*@([a-z0-9-]+\\.)+[a-z0-9-]{2,20}\\s*$', 'i')).test(s);
            },
            checkIfPhone: function(s)
            {
                var regexp = new RegExp(
                    typeof(BX.PhoneNumber) === "undefined"
                        ? BX.PhoneNumber.getValidNumberPattern()
                        : '^\\s*\\+?\s*[0-9(-)\\s]+\\s*$',
                    'i'
                );
                return regexp.test(s);
            }
        };

        BX.prop =
            {
                get: function(object, key, defaultValue)
                {
                    return object && object.hasOwnProperty(key) ? object[key] : defaultValue;
                },
                getObject: function(object, key, defaultValue)
                {
                    return object && BX.type.isPlainObject(object[key]) ? object[key] : defaultValue;
                },
                getElementNode: function(object, key, defaultValue)
                {
                    return object && BX.type.isElementNode(object[key]) ? object[key] : defaultValue;
                },
                getArray: function(object, key, defaultValue)
                {
                    return object && BX.type.isArray(object[key]) ? object[key] : defaultValue;
                },
                getFunction: function(object, key, defaultValue)
                {
                    return object && BX.type.isFunction(object[key]) ? object[key] : defaultValue;
                },
                getNumber: function(object, key, defaultValue)
                {
                    if(!(object && object.hasOwnProperty(key)))
                    {
                        return defaultValue;
                    }

                    var value = object[key];
                    if(BX.type.isNumber(value))
                    {
                        return value;
                    }

                    value = parseFloat(value);
                    return !isNaN(value) ? value : defaultValue;
                },
                getInteger: function(object, key, defaultValue)
                {
                    if(!(object && object.hasOwnProperty(key)))
                    {
                        return defaultValue;
                    }

                    var value = object[key];
                    if(BX.type.isNumber(value))
                    {
                        return value;
                    }

                    value = parseInt(value);
                    return !isNaN(value) ? value : defaultValue;
                },
                getBoolean: function(object, key, defaultValue)
                {
                    if(!(object && object.hasOwnProperty(key)))
                    {
                        return defaultValue;
                    }

                    var value = object[key];
                    return (BX.type.isBoolean(value)
                            ? value
                            : (BX.type.isString(value) ? (value.toLowerCase() === "true") : !!value)
                    );
                },
                getString: function(object, key, defaultValue)
                {
                    if(!(object && object.hasOwnProperty(key)))
                    {
                        return defaultValue;
                    }

                    var value = object[key];
                    return BX.type.isString(value) ? value : (value ? value.toString() : '');
                },
                extractDate: function(datetime)
                {
                    if(!BX.type.isDate(datetime))
                    {
                        datetime = new Date();
                    }

                    datetime.setHours(0);
                    datetime.setMinutes(0);
                    datetime.setSeconds(0);
                    datetime.setMilliseconds(0);

                    return datetime;
                }
            };

        BX.isNodeInDom = function(node, doc)
        {
            return node === (doc || document) ? true :
                (node.parentNode ? BX.isNodeInDom(node.parentNode) : false);
        };

        BX.isNodeHidden = function(node)
        {
            if (node === document)
                return false;
            else if (BX.style(node, 'display') == 'none')
                return true;
            else
                return (node.parentNode ? BX.isNodeHidden(node.parentNode) : true);
        };

        BX.evalPack = function(code)
        {
            while (code.length > 0)
            {
                var c = code.shift();

                if (c.TYPE == 'SCRIPT_EXT' || c.TYPE == 'SCRIPT_SRC')
                {
                    BX.loadScript(c.DATA, function() {BX.evalPack(code)});
                    return;
                }
                else if (c.TYPE == 'SCRIPT')
                {
                    BX.evalGlobal(c.DATA);
                }
            }
        };

        BX.evalGlobal = function(data)
        {
            if (data)
            {
                var head = document.getElementsByTagName("head")[0] || document.documentElement,
                    script = document.createElement("script");

                script.type = "text/javascript";

                if (!BX.browser.IsIE())
                {
                    script.appendChild(document.createTextNode(data));
                }
                else
                {
                    script.text = data;
                }

                head.insertBefore(script, head.firstChild);
                head.removeChild(script);
            }
        };

        BX.garbage = function(call, thisObject)
        {
            garbageCollectors.push({callback: call, context: thisObject});
        };

        BX.GetDocElement = function (pDoc)
        {
            pDoc = pDoc || document;
            return (BX.browser.IsDoctype(pDoc) ? pDoc.documentElement : pDoc.body);
        };

        BX.scrollTop = function(node, val){
            if(typeof val != 'undefined'){

                if(node == window){
                    throw new Error('scrollTop() for window is not implemented');
                }else
                    node.scrollTop = parseInt(val);

            }else{

                if(node == window)
                    return BX.GetWindowScrollPos().scrollTop;

                return node.scrollTop;
            }
        };

        BX.scrollLeft = function(node, val){
            if(typeof val != 'undefined'){

                if(node == window){
                    throw new Error('scrollLeft() for window is not implemented');
                }else
                    node.scrollLeft = parseInt(val);

            }else{

                if(node == window)
                    return BX.GetWindowScrollPos().scrollLeft;

                return node.scrollLeft;
            }
        };

        BX.hide_object = function(ob)
        {
            ob = BX(ob);
            ob.style.position = 'absolute';
            ob.style.top = '-1000px';
            ob.style.left = '-1000px';
            ob.style.height = '10px';
            ob.style.width = '10px';
        };

        BX.is_relative = function(el)
        {
            var p = BX.style(el, 'position');
            return p == 'relative' || p == 'absolute';
        };

        BX.is_float = function(el)
        {
            var p = BX.style(el, 'float');
            return p == 'right' || p == 'left';
        };

        BX.is_fixed = function(el)
        {
            var p = BX.style(el, 'position');
            return p == 'fixed';
        };

        BX.width = function(node, val){
            if(typeof val != 'undefined')
                BX.style(node, 'width', parseInt(val)+'px');
            else{

                if(node == window)
                    return window.innerWidth;

                //return parseInt(BX.style(node, 'width'));
                return BX.pos(node).width;
            }
        };

        BX.height = function(node, val){
            if(typeof val != 'undefined')
                BX.style(node, 'height', parseInt(val)+'px');
            else{

                if(node == window)
                    return window.innerHeight;

                //return parseInt(BX.style(node, 'height'));
                return BX.pos(node).height;
            }
        };

        BX.align = function(pos, w, h, type)
        {
            if (type)
                type = type.toLowerCase();
            else
                type = '';

            var pDoc = document;
            if (BX.type.isElementNode(pos))
            {
                pDoc = pos.ownerDocument;
                pos = BX.pos(pos);
            }

            var x = pos["left"], y = pos["bottom"];

            var scroll = BX.GetWindowScrollPos(pDoc);
            var size = BX.GetWindowInnerSize(pDoc);

            if((size.innerWidth + scroll.scrollLeft) - (pos["left"] + w) < 0)
            {
                if(pos["right"] - w >= 0 )
                    x = pos["right"] - w;
                else
                    x = scroll.scrollLeft;
            }

            if(((size.innerHeight + scroll.scrollTop) - (pos["bottom"] + h) < 0) || ~type.indexOf('top'))
            {
                if(pos["top"] - h >= 0 || ~type.indexOf('top'))
                    y = pos["top"] - h;
                else
                    y = scroll.scrollTop;
            }

            return {'left':x, 'top':y};
        };

        BX.scrollToNode = function(node)
        {
            var obNode = BX(node);

            if (obNode.scrollIntoView)
                obNode.scrollIntoView(true);
            else
            {
                var arNodePos = BX.pos(obNode);
                window.scrollTo(arNodePos.left, arNodePos.top);
            }
        };

        /* non-xhr loadings */
        BX.showWait = function(node, msg)
        {
            node = BX(node) || document.body || document.documentElement;
            msg = msg || BX.message('JS_CORE_LOADING');

            var container_id = node.id || Math.random();

            var obMsg = node.bxmsg = document.body.appendChild(BX.create('DIV', {
                props: {
                    id: 'wait_' + container_id
                },
                style: {
                    background: 'url("/bitrix/js/main/core/images/wait.gif") no-repeat scroll 10px center #fcf7d1',
                    border: '1px solid #E1B52D',
                    color: 'black',
                    fontFamily: 'Verdana,Arial,sans-serif',
                    fontSize: '11px',
                    padding: '10px 30px 10px 37px',
                    position: 'absolute',
                    zIndex:'10000',
                    textAlign:'center'
                },
                text: msg
            }));

            setTimeout(BX.delegate(_adjustWait, node), 10);

            lastWait[lastWait.length] = obMsg;
            return obMsg;
        };

        BX.closeWait = function(node, obMsg)
        {
            if(node && !obMsg)
                obMsg = node.bxmsg;
            if(node && !obMsg && BX.hasClass(node, 'bx-core-waitwindow'))
                obMsg = node;
            if(node && !obMsg)
                obMsg = BX('wait_' + node.id);
            if(!obMsg)
                obMsg = lastWait.pop();

            if (obMsg && obMsg.parentNode)
            {
                for (var i=0,len=lastWait.length;i<len;i++)
                {
                    if (obMsg == lastWait[i])
                    {
                        lastWait = BX.util.deleteFromArray(lastWait, i);
                        break;
                    }
                }

                obMsg.parentNode.removeChild(obMsg);
                if (node) node.bxmsg = null;
                BX.cleanNode(obMsg, true);
            }
        };

        BX.setJSList = function(scripts)
        {
            if (BX.type.isArray(scripts))
            {
                scripts = scripts.map(function(script) {
                    return normalizeUrl(script)
                });

                jsList = jsList.concat(scripts);
            }
        };

        BX.getJSList = function()
        {
            initJsList();
            return jsList;
        };

        BX.setCSSList = function(cssFiles)
        {
            if (BX.type.isArray(cssFiles))
            {
                cssFiles = cssFiles.map(function(cssFile) {
                    return normalizeUrl(cssFile);
                });

                cssList = cssList.concat(cssFiles);
            }
        };

        BX.getCSSList = function()
        {
            initCssList();
            return cssList;
        };

        BX.getJSPath = function(js)
        {
            return js.replace(/^(http[s]*:)*\/\/[^\/]+/i, '');
        };

        BX.getCSSPath = function(css)
        {
            return css.replace(/^(http[s]*:)*\/\/[^\/]+/i, '');
        };

        BX.getCDNPath = function(path)
        {
            return path;
        };

        BX.loadScript = function(script, callback, doc)
        {
            if (BX.type.isString(script))
            {
                script = [script];
            }

            return BX.load(script, callback, doc);
        };

        BX.loadCSS = function(css, doc, win)
        {
            if (BX.type.isString(css))
            {
                css = [css];
            }

            if (BX.type.isArray(css))
            {
                css = css.map(function(url) {
                    return { url: url, ext: "css" }
                });

                BX.load(css, null, doc);
            }
        };

        BX.load = function(items, callback, doc)
        {
            if (!BX.isReady)
            {
                var _args = arguments;
                BX.ready(function() {
                    BX.load.apply(this, _args);
                });
                return null;
            }

            doc = doc || document;
            if (isAsync === null)
            {
                isAsync = "async" in doc.createElement("script") || "MozAppearance" in doc.documentElement.style || window.opera;
            }

            return isAsync ? loadAsync(items, callback, doc) : loadAsyncEmulation(items, callback, doc);
        };

        BX.convert =
            {
                toNumber: function(value)
                {
                    if(BX.type.isNumber(value))
                    {
                        return value;
                    }

                    value = Number(value);
                    return !isNaN(value) ? value : 0;
                },
                nodeListToArray: function(nodes)
                {
                    try
                    {
                        return (Array.prototype.slice.call(nodes, 0));
                    }
                    catch (ex)
                    {
                        var ary = [];
                        for(var i = 0, l = nodes.length; i < l; i++)
                        {
                            ary.push(nodes[i]);
                        }
                        return ary;
                    }
                }
            };

        function loadAsync(items, callback, doc)
        {
            if (!BX.type.isArray(items))
            {
                return;
            }

            function allLoaded(items)
            {
                items = items || assets;
                for (var name in items)
                {
                    if (items.hasOwnProperty(name) && items[name].state !== LOADED)
                    {
                        return false;
                    }
                }

                return true;
            }

            if (!BX.type.isFunction(callback))
            {
                callback = null;
            }

            var itemSet = {}, item, i;
            for (i = 0; i < items.length; i++)
            {
                item = items[i];
                item = getAsset(item);
                itemSet[item.name] = item;
            }

            var callbackWasCalled = false;
            if (items.length > 0)
            {
                for (i = 0; i < items.length; i++)
                {
                    item = items[i];
                    item = getAsset(item);
                    load(item, function () {
                        if (allLoaded(itemSet))
                        {
                            if (!callbackWasCalled)
                            {
                                callback && callback();
                                callbackWasCalled = true;
                            }

                        }
                    }, doc);
                }
            }
            else
            {
                if (typeof callback === 'function')
                {
                    callback();
                    callbackWasCalled = true;
                }
            }
        }

        function loadAsyncEmulation(items, callback, doc)
        {
            function onPreload(asset)
            {
                asset.state = PRELOADED;
                if (BX.type.isArray(asset.onpreload) && asset.onpreload)
                {
                    for (var i = 0; i < asset.onpreload.length; i++)
                    {
                        asset.onpreload[i].call();
                    }
                }
            }

            function preLoad(asset)
            {
                if (asset.state === undefined)
                {
                    asset.state = PRELOADING;
                    asset.onpreload = [];

                    loadAsset(
                        { url: asset.url, type: "cache", ext: asset.ext},
                        function () { onPreload(asset); },
                        doc
                    );
                }
            }

            if (!BX.type.isArray(items))
            {
                return;
            }

            if (!BX.type.isFunction(callback))
            {
                callback = null;
            }

            var rest = [].slice.call(items, 1);
            for (var i = 0; i < rest.length; i++)
            {
                preLoad(getAsset(rest[i]));
            }

            load(getAsset(items[0]), items.length === 1 ? callback : function () {
                loadAsyncEmulation.apply(null, [rest, callback, doc]);
            }, doc);
        }

        function load(asset, callback, doc)
        {
            callback = callback || BX.DoNothing;

            if (asset.state === LOADED)
            {
                callback();
                return;
            }

            if (asset.state === PRELOADING)
            {
                asset.onpreload.push(function () {
                    load(asset, callback, doc);
                });
                return;
            }

            asset.state = LOADING;

            loadAsset(
                asset,
                function () {
                    asset.state = LOADED;
                    callback();
                },
                doc
            );
        }

        function loadAsset(asset, callback, doc)
        {
            callback = callback || BX.DoNothing;

            function error(event)
            {
                ele.onload = ele.onreadystatechange = ele.onerror = null;
                callback();
            }

            function process(event)
            {
                event = event || window.event;
                if (event.type === "load" || (/loaded|complete/.test(ele.readyState) && (!doc.documentMode || doc.documentMode < 9)))
                {
                    window.clearTimeout(asset.errorTimeout);
                    window.clearTimeout(asset.cssTimeout);
                    ele.onload = ele.onreadystatechange = ele.onerror = null;
                    callback();
                }
            }

            function isCssLoaded()
            {
                if (asset.state !== LOADED && asset.cssRetries <= 20)
                {
                    for (var i = 0, l = doc.styleSheets.length; i < l; i++)
                    {
                        if (doc.styleSheets[i].href === ele.href)
                        {
                            process({"type": "load"});
                            return;
                        }
                    }

                    asset.cssRetries++;
                    asset.cssTimeout = window.setTimeout(isCssLoaded, 250);
                }
            }

            var ele;
            var ext = BX.type.isNotEmptyString(asset.ext) ? asset.ext : BX.util.getExtension(asset.url);

            if (ext === "css")
            {
                ele = doc.createElement("link");
                ele.type = "text/" + (asset.type || "css");
                ele.rel = "stylesheet";
                ele.href = asset.url;

                asset.cssRetries = 0;
                asset.cssTimeout = window.setTimeout(isCssLoaded, 500);
            }
            else
            {
                ele = doc.createElement("script");
                ele.type = "text/" + (asset.type || "javascript");
                ele.src = asset.url;
            }

            ele.onload = ele.onreadystatechange = process;
            ele.onerror = error;

            ele.async = false;
            ele.defer = false;

            asset.errorTimeout = window.setTimeout(function () {
                error({type: "timeout"});
            }, 7000);

            if (ext === "css")
            {
                cssList.push(normalizeMinUrl(normalizeUrl(asset.url)));
            }
            else
            {
                jsList.push(normalizeMinUrl(normalizeUrl(asset.url)));
            }

            var templateLink = null;
            var head = doc.head || doc.getElementsByTagName("head")[0];
            if (ext === "css" && (templateLink = getTemplateLink(head)) !== null)
            {
                templateLink.parentNode.insertBefore(ele, templateLink);
            }
            else
            {
                head.insertBefore(ele, head.lastChild);
            }
        }

        function getAsset(item)
        {
            var asset = {};
            if (typeof item === "object")
            {
                asset = item;
                asset.name = asset.name ? asset.name : BX.util.hashCode(item.url);
            }
            else
            {
                asset = { name: BX.util.hashCode(item), url : item };
            }

            var ext = BX.type.isNotEmptyString(asset.ext) ? asset.ext : BX.util.getExtension(asset.url);
            if ((ext === "css" && isCssLoaded(asset.url)) || isScriptLoaded(asset.url))
            {
                asset.state = LOADED;
            }

            var existing = assets[asset.name];
            if (existing && existing.url === asset.url)
            {
                return existing;
            }

            assets[asset.name] = asset;
            return asset;
        }

        function normalizeUrl(url)
        {
            if (!BX.type.isNotEmptyString(url))
            {
                return "";
            }

            url = BX.getJSPath(url);
            url = url.replace(/\?[0-9]*$/, "");

            return url;
        }

        function normalizeMinUrl(url)
        {
            if (!BX.type.isNotEmptyString(url))
            {
                return "";
            }

            var minPos = url.indexOf(".min");
            return minPos >= 0 ? url.substr(0, minPos) + url.substr(minPos + 4) : url;
        }

        function isCssLoaded(fileSrc)
        {
            initCssList();

            fileSrc = normalizeUrl(fileSrc);
            var fileSrcMin = normalizeMinUrl(fileSrc);

            return (fileSrc !== fileSrcMin && BX.util.in_array(fileSrcMin, cssList)) || BX.util.in_array(fileSrc, cssList);
        }

        function initCssList()
        {
            if(!cssInit)
            {
                var linksCol = document.getElementsByTagName('link');

                if(!!linksCol && linksCol.length > 0)
                {
                    for(var i = 0; i < linksCol.length; i++)
                    {
                        var href = linksCol[i].getAttribute('href');
                        if (BX.type.isNotEmptyString(href))
                        {
                            href = normalizeMinUrl(normalizeUrl(href));
                            cssList.push(href);
                        }
                    }
                }
                cssInit = true;
            }
        }

        function getTemplateLink(head)
        {
            var findLink = function(tag)
            {
                var links = head.getElementsByTagName(tag);
                for (var i = 0, length = links.length; i < length; i++)
                {
                    var templateStyle = links[i].getAttribute("data-template-style");
                    if (BX.type.isNotEmptyString(templateStyle) && templateStyle == "true")
                    {
                        return links[i];
                    }
                }

                return null;
            };

            var link = findLink("link");
            if (link === null)
            {
                link = findLink("style");
            }

            return link;
        }

        function isScriptLoaded(fileSrc)
        {
            initJsList();

            fileSrc = normalizeUrl(fileSrc);
            var fileSrcMin = normalizeMinUrl(fileSrc);

            return (fileSrc !== fileSrcMin && BX.util.in_array(fileSrcMin, jsList)) || BX.util.in_array(fileSrc, jsList);
        }

        function initJsList()
        {
            if(!jsInit)
            {
                var scriptCol = document.getElementsByTagName('script');

                if(!!scriptCol && scriptCol.length > 0)
                {
                    for(var i=0; i<scriptCol.length; i++)
                    {
                        var src = scriptCol[i].getAttribute('src');

                        if (BX.type.isNotEmptyString(src))
                        {
                            src = normalizeMinUrl(normalizeUrl(src));
                            jsList.push(src);
                        }
                    }
                }
                jsInit = true;
            }
        }

        function reloadInternal(back_url, bAddClearCache)
        {
            if (back_url === true)
            {
                bAddClearCache = true;
                back_url = null;
            }

            var topWindow = BX.PageObject.getRootWindow();
            var new_href = back_url || topWindow.location.href;

            var hashpos = new_href.indexOf('#'), hash = '';

            if (hashpos != -1)
            {
                hash = new_href.substr(hashpos);
                new_href = new_href.substr(0, hashpos);
            }

            if (bAddClearCache && new_href.indexOf('clear_cache=Y') < 0)
                new_href += (new_href.indexOf('?') == -1 ? '?' : '&') + 'clear_cache=Y';

            if (hash)
            {
                // hack for clearing cache in ajax mode components with history emulation
                if (bAddClearCache && (hash.substr(0, 5) == 'view/' || hash.substr(0, 6) == '#view/') && hash.indexOf('clear_cache%3DY') < 0)
                    hash += (hash.indexOf('%3F') == -1 ? '%3F' : '%26') + 'clear_cache%3DY';

                new_href = new_href.replace(/(\?|\&)_r=[\d]*/, '');
                new_href += (new_href.indexOf('?') == -1 ? '?' : '&') + '_r='+Math.round(Math.random()*10000) + hash;
            }

            topWindow.location.href = new_href;
        }

        BX.reload = function(back_url, bAddClearCache)
        {
            if (window !== window.top)
            {
                BX.Runtime
                    .loadExtension('main.pageobject')
                    .then(function() {
                        reloadInternal(back_url, bAddClearCache);
                    });
            }
            else
            {
                reloadInternal(back_url, bAddClearCache);
            }
        };

        BX.clearCache = function()
        {
            BX.showWait();
            BX.reload(true);
        };

        BX.template = function(tpl, callback, bKillTpl)
        {
            BX.ready(function() {
                _processTpl(BX(tpl), callback, bKillTpl);
            });
        };

        BX.isAmPmMode = function(returnConst)
        {
            if (returnConst === true)
            {
                return BX.message.AMPM_MODE;
            }
            return BX.message.AMPM_MODE !== false;
        };

        BX.formatDate = function(date, format)
        {
            date = date || new Date();

            var bTime = date.getHours() || date.getMinutes() || date.getSeconds(),
                str = !!format
                    ? format :
                    (bTime ? BX.message('FORMAT_DATETIME') : BX.message('FORMAT_DATE')
                    );

            return str.replace(/YYYY/ig, date.getFullYear())
                .replace(/MMMM/ig, BX.util.str_pad_left((date.getMonth()+1).toString(), 2, '0'))
                .replace(/MM/ig, BX.util.str_pad_left((date.getMonth()+1).toString(), 2, '0'))
                .replace(/DD/ig, BX.util.str_pad_left(date.getDate().toString(), 2, '0'))
                .replace(/HH/ig, BX.util.str_pad_left(date.getHours().toString(), 2, '0'))
                .replace(/MI/ig, BX.util.str_pad_left(date.getMinutes().toString(), 2, '0'))
                .replace(/SS/ig, BX.util.str_pad_left(date.getSeconds().toString(), 2, '0'));
        };
        BX.formatName = function(user, template, login)
        {
            user = user || {};
            template = (template || '');
            var replacement = {
                TITLE : (user["TITLE"] || ''),
                NAME : (user["NAME"] || ''),
                LAST_NAME : (user["LAST_NAME"] || ''),
                SECOND_NAME : (user["SECOND_NAME"] || ''),
                LOGIN : (user["LOGIN"] || ''),
                NAME_SHORT : user["NAME"] ? user["NAME"].substr(0, 1) + '.' : '',
                LAST_NAME_SHORT : user["LAST_NAME"] ? user["LAST_NAME"].substr(0, 1) + '.' : '',
                SECOND_NAME_SHORT : user["SECOND_NAME"] ? user["SECOND_NAME"].substr(0, 1) + '.' : '',
                EMAIL : (user["EMAIL"] || ''),
                ID : (user["ID"] || ''),
                NOBR : "",
                '/NOBR' : ""
            }, result = template;
            for (var ii in replacement)
            {
                if (replacement.hasOwnProperty(ii))
                {
                    result = result.replace("#" + ii+ "#", replacement[ii])
                }
            }
            result = result.replace(/([\s]+)/gi, " ").trim();
            if (result == "")
            {
                result = (login == "Y" ? replacement["LOGIN"] : "");
                result = (result == "" ? "Noname" : result);
            }
            return result;
        };

        BX.getNumMonth = function(month)
        {
            var wordMonthCut = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
            var wordMonth = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];

            var q = month.toUpperCase();
            for (i = 1; i <= 12; i++)
            {
                if (q == BX.message('MON_'+i).toUpperCase() || q == BX.message('MONTH_'+i).toUpperCase() || q == wordMonthCut[i-1].toUpperCase() || q == wordMonth[i-1].toUpperCase())
                {
                    return i;
                }
            }
            return month;
        };

        BX.parseDate = function(str, bUTC, formatDate, formatDatetime)
        {
            if (BX.type.isNotEmptyString(str))
            {
                if (!formatDate)
                    formatDate = BX.message('FORMAT_DATE');
                if (!formatDatetime)
                    formatDatetime = BX.message('FORMAT_DATETIME');

                var regMonths = '';
                for (i = 1; i <= 12; i++)
                {
                    regMonths = regMonths + '|' + BX.message('MON_'+i);
                }

                var expr = new RegExp('([0-9]+|[a-z]+' + regMonths + ')', 'ig');
                var aDate = str.match(expr),
                    aFormat = formatDate.match(/(DD|MI|MMMM|MM|M|YYYY)/ig),
                    i, cnt,
                    aDateArgs=[], aFormatArgs=[],
                    aResult={};

                if (!aDate)
                    return null;

                if(aDate.length > aFormat.length)
                {
                    aFormat = formatDatetime.match(/(DD|MI|MMMM|MM|M|YYYY|HH|H|SS|TT|T|GG|G)/ig);
                }

                for(i = 0, cnt = aDate.length; i < cnt; i++)
                {
                    if(BX.util.trim(aDate[i]) != '')
                    {
                        aDateArgs[aDateArgs.length] = aDate[i];
                    }
                }

                for(i = 0, cnt = aFormat.length; i < cnt; i++)
                {
                    if(BX.util.trim(aFormat[i]) != '')
                    {
                        aFormatArgs[aFormatArgs.length] = aFormat[i];
                    }
                }


                var m = BX.util.array_search('MMMM', aFormatArgs);
                if (m > 0)
                {
                    aDateArgs[m] = BX.getNumMonth(aDateArgs[m]);
                    aFormatArgs[m] = "MM";
                }
                else
                {
                    m = BX.util.array_search('M', aFormatArgs);
                    if (m > 0)
                    {
                        aDateArgs[m] = BX.getNumMonth(aDateArgs[m]);
                        aFormatArgs[m] = "MM";
                    }
                }

                for(i = 0, cnt = aFormatArgs.length; i < cnt; i++)
                {
                    var k = aFormatArgs[i].toUpperCase();
                    aResult[k] = k == 'T' || k == 'TT' ? aDateArgs[i] : parseInt(aDateArgs[i], 10);
                }

                if(aResult['DD'] > 0 && aResult['MM'] > 0 && aResult['YYYY'] > 0)
                {
                    var d = new Date();

                    if(bUTC)
                    {
                        d.setUTCDate(1);
                        d.setUTCFullYear(aResult['YYYY']);
                        d.setUTCMonth(aResult['MM'] - 1);
                        d.setUTCDate(aResult['DD']);
                        d.setUTCHours(0, 0, 0, 0);
                    }
                    else
                    {
                        d.setDate(1);
                        d.setFullYear(aResult['YYYY']);
                        d.setMonth(aResult['MM'] - 1);
                        d.setDate(aResult['DD']);
                        d.setHours(0, 0, 0, 0);
                    }

                    if(
                        (!isNaN(aResult['HH']) || !isNaN(aResult['GG']) || !isNaN(aResult['H']) || !isNaN(aResult['G']))
                        && !isNaN(aResult['MI'])
                    )
                    {
                        if (!isNaN(aResult['H']) || !isNaN(aResult['G']))
                        {
                            var bPM = (aResult['T']||aResult['TT']||'am').toUpperCase()=='PM';
                            var h = parseInt(aResult['H']||aResult['G']||0, 10);
                            if(bPM)
                            {
                                aResult['HH'] = h + (h == 12 ? 0 : 12);
                            }
                            else
                            {
                                aResult['HH'] = h < 12 ? h : 0;
                            }
                        }
                        else
                        {
                            aResult['HH'] = parseInt(aResult['HH']||aResult['GG']||0, 10);
                        }

                        if (isNaN(aResult['SS']))
                            aResult['SS'] = 0;

                        if(bUTC)
                        {
                            d.setUTCHours(aResult['HH'], aResult['MI'], aResult['SS']);
                        }
                        else
                        {
                            d.setHours(aResult['HH'], aResult['MI'], aResult['SS']);
                        }
                    }

                    return d;
                }
            }

            return null;
        };

        BX.selectUtils =
            {
                addNewOption: function(oSelect, opt_value, opt_name, do_sort, check_unique)
                {
                    oSelect = BX(oSelect);
                    if(oSelect)
                    {
                        var n = oSelect.length;
                        if(check_unique !== false)
                        {
                            for(var i=0;i<n;i++)
                            {
                                if(oSelect[i].value==opt_value)
                                {
                                    return;
                                }
                            }
                        }

                        oSelect.options[n] = new Option(opt_name, opt_value, false, false);
                    }

                    if(do_sort === true)
                    {
                        this.sortSelect(oSelect);
                    }
                },

                deleteOption: function(oSelect, opt_value)
                {
                    oSelect = BX(oSelect);
                    if(oSelect)
                    {
                        for(var i=0;i<oSelect.length;i++)
                        {
                            if(oSelect[i].value==opt_value)
                            {
                                oSelect.remove(i);
                                break;
                            }
                        }
                    }
                },

                deleteSelectedOptions: function(oSelect)
                {
                    oSelect = BX(oSelect);
                    if(oSelect)
                    {
                        var i=0;
                        while(i<oSelect.length)
                        {
                            if(oSelect[i].selected)
                            {
                                oSelect[i].selected=false;
                                oSelect.remove(i);
                            }
                            else
                            {
                                i++;
                            }
                        }
                    }
                },

                deleteAllOptions: function(oSelect)
                {
                    oSelect = BX(oSelect);
                    if(oSelect)
                    {
                        for(var i=oSelect.length-1; i>=0; i--)
                        {
                            oSelect.remove(i);
                        }
                    }
                },

                optionCompare: function(record1, record2)
                {
                    var value1 = record1.optText.toLowerCase();
                    var value2 = record2.optText.toLowerCase();
                    if (value1 > value2) return(1);
                    if (value1 < value2) return(-1);
                    return(0);
                },

                sortSelect: function(oSelect)
                {
                    oSelect = BX(oSelect);
                    if(oSelect)
                    {
                        var myOptions = [];
                        var n = oSelect.options.length;
                        var i;
                        for (i=0;i<n;i++)
                        {
                            myOptions[i] = {
                                optText:oSelect[i].text,
                                optValue:oSelect[i].value
                            };
                        }
                        myOptions.sort(this.optionCompare);
                        oSelect.length=0;
                        n = myOptions.length;
                        for(i=0;i<n;i++)
                        {
                            oSelect[i] = new Option(myOptions[i].optText, myOptions[i].optValue, false, false);
                        }
                    }
                },

                selectAllOptions: function(oSelect)
                {
                    oSelect = BX(oSelect);
                    if(oSelect)
                    {
                        var n = oSelect.length;
                        for(var i=0;i<n;i++)
                        {
                            oSelect[i].selected=true;
                        }
                    }
                },

                selectOption: function(oSelect, opt_value)
                {
                    oSelect = BX(oSelect);
                    if(oSelect)
                    {
                        var n = oSelect.length;
                        for(var i=0;i<n;i++)
                        {
                            oSelect[i].selected = (oSelect[i].value == opt_value);
                        }
                    }
                },

                addSelectedOptions: function(oSelect, to_select_id, check_unique, do_sort)
                {
                    oSelect = BX(oSelect);
                    if(!oSelect)
                        return;
                    var n = oSelect.length;
                    for(var i=0; i<n; i++)
                        if(oSelect[i].selected)
                            this.addNewOption(to_select_id, oSelect[i].value, oSelect[i].text, do_sort, check_unique);
                },

                moveOptionsUp: function(oSelect)
                {
                    oSelect = BX(oSelect);
                    if(!oSelect)
                        return;
                    var n = oSelect.length;
                    for(var i=0; i<n; i++)
                    {
                        if(oSelect[i].selected && i>0 && oSelect[i-1].selected == false)
                        {
                            var option = new Option(oSelect[i].text, oSelect[i].value);
                            oSelect[i] = new Option(oSelect[i-1].text, oSelect[i-1].value);
                            oSelect[i].selected = false;
                            oSelect[i-1] = option;
                            oSelect[i-1].selected = true;
                        }
                    }
                },

                moveOptionsDown: function(oSelect)
                {
                    oSelect = BX(oSelect);
                    if(!oSelect)
                        return;
                    var n = oSelect.length;
                    for(var i=n-1; i>=0; i--)
                    {
                        if(oSelect[i].selected && i<n-1 && oSelect[i+1].selected == false)
                        {
                            var option = new Option(oSelect[i].text, oSelect[i].value);
                            oSelect[i] = new Option(oSelect[i+1].text, oSelect[i+1].value);
                            oSelect[i].selected = false;
                            oSelect[i+1] = option;
                            oSelect[i+1].selected = true;
                        }
                    }
                }
            };

        BX.getEventTarget = function(e)
        {
            if(e.target)
            {
                return e.target;
            }
            else if(e.srcElement)
            {
                return e.srcElement;
            }
            return null;
        };

        /******* HINT ***************/
// if function has 2 params - the 2nd one is hint html. otherwise hint_html is third and hint_title - 2nd;
// '<div onmouseover="BX.hint(this, 'This is &lt;b&gt;Hint&lt;/b&gt;')"'>;
// BX.hint(el, 'This is <b>Hint</b>') - this won't work, use constructor
        BX.hint = function(el, hint_title, hint_html, hint_id)
        {
            if (null == hint_html)
            {
                hint_html = hint_title;
                hint_title = '';
            }

            if (null == el.BXHINT)
            {
                el.BXHINT = new BX.CHint({
                    parent: el, hint: hint_html, title: hint_title, id: hint_id
                });
                el.BXHINT.Show();
            }
        };

        BX.hint_replace = function(el, hint_title, hint_html)
        {
            if (null == hint_html)
            {
                hint_html = hint_title;
                hint_title = '';
            }

            if (!el || !el.parentNode || !hint_html)
                return null;

            var obHint = new BX.CHint({
                hint: hint_html,
                title: hint_title
            });

            obHint.CreateParent();

            el.parentNode.insertBefore(obHint.PARENT, el);
            el.parentNode.removeChild(el);

            obHint.PARENT.style.marginLeft = '5px';

            return el;
        };

        BX.CHint = function(params)
        {
            this.PARENT = BX(params.parent);

            this.HINT = params.hint;
            this.HINT_TITLE = params.title;

            this.PARAMS = {};
            for (var i in this.defaultSettings)
            {
                if (null == params[i])
                    this.PARAMS[i] = this.defaultSettings[i];
                else
                    this.PARAMS[i] = params[i];
            }

            if (null != params.id)
                this.ID = params.id;

            this.timer = null;
            this.bInited = false;
            this.msover = true;

            if (this.PARAMS.showOnce)
            {
                this.__show();
                this.msover = false;
                this.timer = setTimeout(BX.proxy(this.__hide, this), this.PARAMS.hide_timeout);
            }
            else if (this.PARENT)
            {
                BX.bind(this.PARENT, 'mouseover', BX.proxy(this.Show, this));
                BX.bind(this.PARENT, 'mouseout', BX.proxy(this.Hide, this));
            }
        };

        BX.CHint.openHints = new Set();

        BX.CHint.globalDisabled = false;

        BX.CHint.handleMenuOpen = function() {
            BX.CHint.globalDisabled = true;

            BX.CHint.openHints.forEach(function(hint) {
                hint.__hide_immediately();
            });
        };

        BX.CHint.handleMenuClose = function() {
            BX.CHint.globalDisabled = false;
        };

        BX.addCustomEvent('onMenuOpen', BX.CHint.handleMenuOpen);
        BX.addCustomEvent('onMenuClose', BX.CHint.handleMenuClose);

        BX.CHint.prototype.defaultSettings = {
            show_timeout: 1000,
            hide_timeout: 500,
            dx: 2,
            showOnce: false,
            preventHide: true,
            min_width: 250
        };

        BX.CHint.prototype.CreateParent = function(element, params)
        {
            if (this.PARENT)
            {
                BX.unbind(this.PARENT, 'mouseover', BX.proxy(this.Show, this));
                BX.unbind(this.PARENT, 'mouseout', BX.proxy(this.Hide, this));
            }

            if (!params) params = {};
            var type = 'icon';

            if (params.type && (params.type == "link" || params.type == "icon"))
                type = params.type;

            if (element)
                type = "element";

            if (type == "icon")
            {
                element = BX.create('IMG', {
                    props: {
                        src: params.iconSrc
                            ? params.iconSrc
                            : "/bitrix/js/main/core/images/hint.gif"
                    }
                });
            }
            else if (type == "link")
            {
                element = BX.create("A", {
                    props: {href: 'javascript:void(0)'},
                    html: '[?]'
                });
            }

            this.PARENT = element;

            BX.bind(this.PARENT, 'mouseover', BX.proxy(this.Show, this));
            BX.bind(this.PARENT, 'mouseout', BX.proxy(this.Hide, this));

            return this.PARENT;
        };

        BX.CHint.prototype.Show = function()
        {
            this.msover = true;

            if (null != this.timer)
                clearTimeout(this.timer);

            this.timer = setTimeout(BX.proxy(this.__show, this), this.PARAMS.show_timeout);
        };

        BX.CHint.prototype.Hide = function()
        {
            this.msover = false;

            if (null != this.timer)
                clearTimeout(this.timer);

            this.timer = setTimeout(BX.proxy(this.__hide, this), this.PARAMS.hide_timeout);
        };

        BX.CHint.prototype.__show = function()
        {
            if (!this.msover || this.disabled || BX.CHint.globalDisabled) return;
            if (!this.bInited) this.Init();

            if (this.prepareAdjustPos())
            {
                this.DIV.style.display = 'block';
                this.adjustPos();

                BX.CHint.openHints.add(this);

                BX.bind(window, 'scroll', BX.proxy(this.__onscroll, this));

                if (this.PARAMS.showOnce)
                {
                    this.timer = setTimeout(BX.proxy(this.__hide, this), this.PARAMS.hide_timeout);
                }
            }
        };

        BX.CHint.prototype.__onscroll = function()
        {
            if (!BX.admin || !BX.admin.panel || !BX.admin.panel.isFixed()) return;

            if (this.scrollTimer) clearTimeout(this.scrollTimer);

            this.DIV.style.display = 'none';
            this.scrollTimer = setTimeout(BX.proxy(this.Reopen, this), this.PARAMS.show_timeout);
        };

        BX.CHint.prototype.Reopen = function()
        {
            if (null != this.timer) clearTimeout(this.timer);
            this.timer = setTimeout(BX.proxy(this.__show, this), 50);
        };

        BX.CHint.prototype.__hide = function()
        {
            if (this.msover) return;
            if (!this.bInited) return;

            BX.unbind(window, 'scroll', BX.proxy(this.Reopen, this));

            BX.CHint.openHints.delete(this);

            if (this.PARAMS.showOnce)
            {
                this.Destroy();
            }
            else
            {
                this.DIV.style.display = 'none';
            }
        };

        BX.CHint.prototype.__hide_immediately = function()
        {
            this.msover = false;
            this.__hide();
        };

        BX.CHint.prototype.Init = function()
        {
            this.DIV = document.body.appendChild(BX.create('DIV', {
                props: {className: 'bx-panel-tooltip'},
                style: {display: 'none'},
                children: [
                    BX.create('DIV', {
                        props: {className: 'bx-panel-tooltip-top-border'},
                        html: '<div class="bx-panel-tooltip-corner bx-panel-tooltip-left-corner"></div><div class="bx-panel-tooltip-border"></div><div class="bx-panel-tooltip-corner bx-panel-tooltip-right-corner"></div>'
                    }),
                    (this.CONTENT = BX.create('DIV', {
                        props: {className: 'bx-panel-tooltip-content'},
                        children: [
                            BX.create('DIV', {
                                props: {className: 'bx-panel-tooltip-underlay'},
                                children: [
                                    BX.create('DIV', {props: {className: 'bx-panel-tooltip-underlay-bg'}})
                                ]
                            })
                        ]
                    })),

                    BX.create('DIV', {
                        props: {className: 'bx-panel-tooltip-bottom-border'},
                        html: '<div class="bx-panel-tooltip-corner bx-panel-tooltip-left-corner"></div><div class="bx-panel-tooltip-border"></div><div class="bx-panel-tooltip-corner bx-panel-tooltip-right-corner"></div>'
                    })
                ]
            }));

            if (this.ID)
            {
                this.CONTENT.insertBefore(BX.create('A', {
                    attrs: {href: 'javascript:void(0)'},
                    props: {className: 'bx-panel-tooltip-close'},
                    events: {click: BX.delegate(this.Close, this)}
                }), this.CONTENT.firstChild)
            }

            if (this.HINT_TITLE)
            {
                this.CONTENT.appendChild(
                    BX.create('DIV', {
                        props: {className: 'bx-panel-tooltip-title'},
                        text: this.HINT_TITLE
                    })
                )
            }

            if (this.HINT)
            {
                this.CONTENT_TEXT = this.CONTENT.appendChild(BX.create('DIV', {props: {className: 'bx-panel-tooltip-text'}})).appendChild(BX.create('SPAN', {html: this.HINT}));
            }

            if (this.PARAMS.preventHide)
            {
                BX.bind(this.DIV, 'mouseout', BX.proxy(this.Hide, this));
                BX.bind(this.DIV, 'mouseover', BX.proxy(this.Show, this));
            }

            this.bInited = true;
        };

        BX.CHint.prototype.setContent = function(content)
        {
            this.HINT = content;

            if (this.CONTENT_TEXT)
                this.CONTENT_TEXT.innerHTML = this.HINT;
            else
                this.CONTENT_TEXT = this.CONTENT.appendChild(BX.create('DIV', {props: {className: 'bx-panel-tooltip-text'}})).appendChild(BX.create('SPAN', {html: this.HINT}));
        };

        BX.CHint.prototype.prepareAdjustPos = function()
        {
            this._wnd = {scrollPos: BX.GetWindowScrollPos(),scrollSize:BX.GetWindowScrollSize()};
            return BX.style(this.PARENT, 'display') != 'none';
        };

        BX.CHint.prototype.getAdjustPos = function()
        {
            var res = {}, pos = BX.pos(this.PARENT), min_top = 0;

            res.top = pos.bottom + this.PARAMS.dx;

            if (BX.admin && BX.admin.panel.DIV)
            {
                min_top = BX.admin.panel.DIV.offsetHeight + this.PARAMS.dx;

                if (BX.admin.panel.isFixed())
                {
                    min_top += this._wnd.scrollPos.scrollTop;
                }
            }

            if (res.top < min_top)
                res.top = min_top;
            else
            {
                if (res.top + this.DIV.offsetHeight > this._wnd.scrollSize.scrollHeight)
                    res.top = pos.top - this.PARAMS.dx - this.DIV.offsetHeight;
            }

            res.left = pos.left;
            if (pos.left < this.PARAMS.dx)
                pos.left = this.PARAMS.dx;
            else
            {
                var floatWidth = this.DIV.offsetWidth;

                var max_left = this._wnd.scrollSize.scrollWidth - floatWidth - this.PARAMS.dx;

                if (res.left > max_left)
                    res.left = max_left;
            }

            return res;
        };

        BX.CHint.prototype.adjustWidth = function()
        {
            if (this.bWidthAdjusted) return;

            var w = this.DIV.offsetWidth, h = this.DIV.offsetHeight;

            if (w > this.PARAMS.min_width)
                w = Math.round(Math.sqrt(1.618*w*h));

            if (w < this.PARAMS.min_width)
                w = this.PARAMS.min_width;

            this.DIV.style.width = w + "px";

            if (this._adjustWidthInt)
                clearInterval(this._adjustWidthInt);
            this._adjustWidthInt = setInterval(BX.delegate(this._adjustWidthInterval, this), 5);

            this.bWidthAdjusted = true;
        };

        BX.CHint.prototype._adjustWidthInterval = function()
        {
            if (!this.DIV || this.DIV.style.display == 'none')
                clearInterval(this._adjustWidthInt);

            var
                dW = 20,
                maxWidth = 1500,
                w = this.DIV.offsetWidth,
                w1 = this.CONTENT_TEXT.offsetWidth;

            if (w > 0 && w1 > 0 && w - w1 < dW && w < maxWidth)
            {
                this.DIV.style.width = (w + dW) + "px";
                return;
            }

            clearInterval(this._adjustWidthInt);
        };

        BX.CHint.prototype.adjustPos = function()
        {
            this.adjustWidth();

            var pos = this.getAdjustPos();

            this.DIV.style.top = pos.top + 'px';
            this.DIV.style.left = pos.left + 'px';
        };

        BX.CHint.prototype.Close = function()
        {
            if (this.ID && BX.WindowManager)
                BX.WindowManager.saveWindowOptions(this.ID, {display: 'off'});
            this.__hide_immediately();
            this.Destroy();
        };

        BX.CHint.prototype.Destroy = function()
        {
            if (this.PARENT)
            {
                BX.unbind(this.PARENT, 'mouseover', BX.proxy(this.Show, this));
                BX.unbind(this.PARENT, 'mouseout', BX.proxy(this.Hide, this));
            }

            if (this.DIV)
            {
                BX.unbind(this.DIV, 'mouseover', BX.proxy(this.Show, this));
                BX.unbind(this.DIV, 'mouseout', BX.proxy(this.Hide, this));

                BX.cleanNode(this.DIV, true);
            }
        };

        BX.CHint.prototype.enable = function(){this.disabled = false;};
        BX.CHint.prototype.disable = function(){this.__hide_immediately(); this.disabled = true;};


        function _adjustWait()
        {
            if (!this.bxmsg) return;

            var arContainerPos = BX.pos(this),
                div_top = arContainerPos.top;

            if (div_top < BX.GetDocElement().scrollTop)
                div_top = BX.GetDocElement().scrollTop + 5;

            this.bxmsg.style.top = (div_top + 5) + 'px';

            if (this == BX.GetDocElement())
            {
                this.bxmsg.style.right = '5px';
            }
            else
            {
                this.bxmsg.style.left = (arContainerPos.right - this.bxmsg.offsetWidth - 5) + 'px';
            }
        }

        function _processTpl(tplNode, cb, bKillTpl)
        {
            if (tplNode)
            {
                if (bKillTpl)
                    tplNode.parentNode.removeChild(tplNode);

                var res = {}, nodes = BX.findChildren(tplNode, {attribute: 'data-role'}, true);

                for (var i = 0, l = nodes.length; i < l; i++)
                {
                    res[nodes[i].getAttribute('data-role')] = nodes[i];
                }

                cb.apply(tplNode, [res]);
            }
        }

        function _checkNode(obj, params)
        {
            params = params || {};

            if (BX.type.isFunction(params))
                return params.call(window, obj);

            if (!params.allowTextNodes && !BX.type.isElementNode(obj))
                return false;
            var i,j,len;
            for (i in params)
            {
                if(params.hasOwnProperty(i))
                {
                    switch(i)
                    {
                        case 'tag':
                        case 'tagName':
                            if (BX.type.isString(params[i]))
                            {
                                if (obj.tagName.toUpperCase() != params[i].toUpperCase())
                                    return false;
                            }
                            else if (params[i] instanceof RegExp)
                            {
                                if (!params[i].test(obj.tagName))
                                    return false;
                            }
                            break;

                        case 'class':
                        case 'className':
                            if (BX.type.isString(params[i]))
                            {
                                if (!BX.hasClass(obj, params[i]))
                                    return false;
                            }
                            else if (params[i] instanceof RegExp)
                            {
                                if (!BX.type.isString(obj.className) || !params[i].test(obj.className))
                                    return false;
                            }
                            break;

                        case 'attr':
                        case 'attrs':
                        case 'attribute':
                            if (BX.type.isString(params[i]))
                            {
                                if (!obj.getAttribute(params[i]))
                                    return false;
                            }
                            else if (BX.type.isArray(params[i]))
                            {
                                for (j = 0, len = params[i].length; j < len; j++)
                                {
                                    if (params[i] && !obj.getAttribute(params[i]))
                                        return false;
                                }
                            }
                            else
                            {
                                for (j in params[i])
                                {
                                    if(params[i].hasOwnProperty(j))
                                    {
                                        var q = obj.getAttribute(j);
                                        if (params[i][j] instanceof RegExp)
                                        {
                                            if (!BX.type.isString(q) || !params[i][j].test(q))
                                            {
                                                return false;
                                            }
                                        }
                                        else
                                        {
                                            if (q != '' + params[i][j])
                                            {
                                                return false;
                                            }
                                        }
                                    }
                                }
                            }
                            break;

                        case 'property':
                        case 'props':
                            if (BX.type.isString(params[i]))
                            {
                                if (!obj[params[i]])
                                    return false;
                            }
                            else if (BX.type.isArray(params[i]))
                            {
                                for (j = 0, len = params[i].length; j < len; j++)
                                {
                                    if (params[i] && !obj[params[i]])
                                        return false;
                                }
                            }
                            else
                            {
                                for (j in params[i])
                                {
                                    if (BX.type.isString(params[i][j]))
                                    {
                                        if (obj[j] != params[i][j])
                                            return false;
                                    }
                                    else if (params[i][j] instanceof RegExp)
                                    {
                                        if (!BX.type.isString(obj[j]) || !params[i][j].test(obj[j]))
                                            return false;
                                    }
                                }
                            }
                            break;

                        case 'callback':
                            return params[i](obj);
                    }
                }
            }

            return true;
        }

        /* garbage collector */
        function Trash()
        {
            var i,len;

            for (i = 0, len = garbageCollectors.length; i<len; i++)
            {
                try {
                    garbageCollectors[i].callback.apply(garbageCollectors[i].context || window);
                    delete garbageCollectors[i];
                    garbageCollectors[i] = null;
                } catch (e) {}
            }
        }

        if(window.attachEvent) // IE
            window.attachEvent("onunload", Trash);
        else if(window.addEventListener) // Gecko / W3C
            window.addEventListener('unload', Trash, false);
        else
            window.onunload = Trash;
        /* \garbage collector */

// set empty ready handler
        BX(BX.DoNothing);
        window.BX = BX;

        BX.browser.addGlobalClass();

        /* data storage */
        BX.data = function(node, key, value)
        {
            if(typeof node == 'undefined')
                return undefined;

            if(typeof key == 'undefined')
                return undefined;

            if(typeof value != 'undefined')
            {
                // write to manager
                dataStorage.set(node, key, value);
            }
            else
            {
                var data;

                // from manager
                if((data = dataStorage.get(node, key)) != undefined)
                {
                    return data;
                }
                else
                {
                    // from attribute data-*
                    if('getAttribute' in node)
                    {
                        data = node.getAttribute('data-'+key.toString());
                        if(data === null)
                        {
                            return undefined;
                        }
                        return data;
                    }
                }

                return undefined;
            }
        };

        BX.DataStorage = function()
        {

            this.keyOffset = 1;
            this.data = {};
            this.uniqueTag = 'BX-'+Math.random();

            this.resolve = function(owner, create){
                if(typeof owner[this.uniqueTag] == 'undefined')
                    if(create)
                    {
                        try
                        {
                            Object.defineProperty(owner, this.uniqueTag, {
                                value: this.keyOffset++
                            });
                        }
                        catch(e)
                        {
                            owner[this.uniqueTag] = this.keyOffset++;
                        }
                    }
                    else
                        return undefined;

                return owner[this.uniqueTag];
            };
            this.get = function(owner, key){
                if((owner != document && !BX.type.isElementNode(owner)) || typeof key == 'undefined')
                    return undefined;

                owner = this.resolve(owner, false);

                if(typeof owner == 'undefined' || typeof this.data[owner] == 'undefined')
                    return undefined;

                return this.data[owner][key];
            };
            this.set = function(owner, key, value){

                if((owner != document && !BX.type.isElementNode(owner)) || typeof value == 'undefined')
                    return;

                var o = this.resolve(owner, true);

                if(typeof this.data[o] == 'undefined')
                    this.data[o] = {};

                this.data[o][key] = value;
            };
        };

// some internal variables for new logic
        var dataStorage = new BX.DataStorage();	// manager which BX.data() uses to keep data
    })(window.BX);

    ;(function(window)
    {
        /****************** ATTENTION *******************************
         * Please do not use Bitrix CoreJS in this class.
         * This class can be called on page without Bitrix Framework
         *************************************************************/

        if (!window.BX)
        {
            window.BX = {};
        }

        var BX = window.BX;

        BX.Promise = function(fn, ctx) // fn is future-reserved
        {
            this.state = null;
            this.value = null;
            this.reason = null;
            this.next = null;
            this.ctx = ctx || this;

            this.onFulfilled = [];
            this.onRejected = [];
        };
        BX.Promise.prototype.fulfill = function(value)
        {
            this.checkState();

            this.value = value;
            this.state = true;
            this.execute();
        };
        BX.Promise.prototype.reject = function(reason)
        {
            this.checkState();

            this.reason = reason;
            this.state = false;
            this.execute();
        };
        BX.Promise.prototype.then = function(onFulfilled, onRejected)
        {
            if(typeof (onFulfilled) == "function" || onFulfilled instanceof Function)
            {
                this.onFulfilled.push(onFulfilled);
            }
            if(typeof (onRejected) == "function" || onRejected instanceof Function)
            {
                this.onRejected.push(onRejected);
            }

            if(this.next === null)
            {
                this.next = new BX.Promise(null, this.ctx);
            }

            if(this.state !== null) // if promise was already resolved, execute immediately
            {
                this.execute();
            }

            return this.next;
        };

        BX.Promise.prototype.catch = function(onRejected)
        {
            if(typeof (onRejected) == "function" || onRejected instanceof Function)
            {
                this.onRejected.push(onRejected);
            }

            if(this.next === null)
            {
                this.next = new BX.Promise(null, this.ctx);
            }

            if(this.state !== null) // if promise was already resolved, execute immediately
            {
                this.execute();
            }

            return this.next;
        };

        BX.Promise.prototype.setAutoResolve = function(way, ms)
        {
            this.timer = setTimeout(function(){
                if(this.state === null)
                {
                    this[way ? 'fulfill' : 'reject']();
                }
            }.bind(this), ms || 15);
        };
        BX.Promise.prototype.cancelAutoResolve = function()
        {
            clearTimeout(this.timer);
        };
        /**
         * Resolve function. This function allows promise chaining, like ..then().then()...
         * Typical usage:
         *
         * var p = new Promise();
         *
         * p.then(function(value){
         *  return someValue; // next promise in the chain will be fulfilled with someValue
         * }).then(function(value){
         *
         *  var p1 = new Promise();
         *  *** some async code here, that eventually resolves p1 ***
         *
         *  return p1; // chain will resume when p1 resolved (fulfilled or rejected)
         * }).then(function(value){
         *
         *  // you can also do
         *  var e = new Error();
         *  throw e;
         *  // it will cause next promise to be rejected with e
         *
         *  return someOtherValue;
         * }).then(function(value){
         *  ...
         * }, function(reason){
         *  // promise was rejected with reason
         * })...;
         *
         * p.fulfill('let`s start this chain');
         *
         * @param x
         */
        BX.Promise.prototype.resolve = function(x)
        {
            var this_ = this;

            if(this === x)
            {
                this.reject(new TypeError('Promise cannot fulfill or reject itself')); // avoid recursion
            }
            // allow "pausing" promise chaining until promise x is fulfilled or rejected
            else if(x && x.toString() === "[object BX.Promise]")
            {
                x.then(function(value){
                    this_.fulfill(value);
                }, function(reason){
                    this_.reject(reason);
                });
            }
            else // auto-fulfill this promise
            {
                this.fulfill(x);
            }
        };

        BX.Promise.prototype.toString = function()
        {
            return "[object BX.Promise]";
        };

        BX.Promise.prototype.execute = function()
        {
            if(this.state === null)
            {
                //then() must not be called before BX.Promise resolve() happens
                return;
            }

            var value = undefined;
            var reason = undefined;
            var x = undefined;
            var k;
            if(this.state === true) // promise was fulfill()-ed
            {
                if(this.onFulfilled.length)
                {
                    try
                    {
                        for(k = 0; k < this.onFulfilled.length; k++)
                        {
                            x = this.onFulfilled[k].apply(this.ctx, [this.value]);
                            if(typeof x != 'undefined')
                            {
                                value = x;
                            }
                        }
                    }
                    catch(e)
                    {
                        if('console' in window)
                        {
                            console.dir(e);
                        }

                        if (typeof BX.debug !== 'undefined')
                        {
                            BX.debug(e);
                        }

                        reason = e; // reject next
                    }
                }
                else
                {
                    value = this.value; // resolve next
                }
            }
            else if(this.state === false) // promise was reject()-ed
            {
                if(this.onRejected.length)
                {
                    try
                    {
                        for(k = 0; k < this.onRejected.length; k++)
                        {
                            x = this.onRejected[k].apply(this.ctx, [this.reason]);
                            if(typeof x != 'undefined')
                            {
                                value = x;
                            }
                        }
                    }
                    catch(e)
                    {
                        if('console' in window)
                        {
                            console.dir(e);
                        }

                        if (typeof BX.debug !== 'undefined')
                        {
                            BX.debug(e);
                        }

                        reason = e; // reject next
                    }
                }
                else
                {
                    reason = this.reason; // reject next
                }
            }

            if(this.next !== null)
            {
                if(typeof reason != 'undefined')
                {
                    this.next.reject(reason);
                }
                else if(typeof value != 'undefined')
                {
                    this.next.resolve(value);
                }
            }
        };
        BX.Promise.prototype.checkState = function()
        {
            if(this.state !== null)
            {
                throw new Error('You can not do fulfill() or reject() multiple times');
            }
        };
    })(window);



    ;(function(window){

        if (window.BX.ajax)
            return;

        var
            BX = window.BX,

            tempDefaultConfig = {},
            defaultConfig = {
                method: 'GET', // request method: GET|POST
                dataType: 'html', // type of data loading: html|json|script
                timeout: 0, // request timeout in seconds. 0 for browser-default
                async: true, // whether request is asynchronous or not
                processData: true, // any data processing is disabled if false, only callback call
                scriptsRunFirst: false, // whether to run _all_ found scripts before onsuccess call. script tag can have an attribute "bxrunfirst" to turn  this flag on only for itself
                emulateOnload: true,
                skipAuthCheck: false, // whether to check authorization failure (SHOUD be set to true for CORS requests)
                start: true, // send request immediately (if false, request can be started manually via XMLHttpRequest object returned)
                cache: true, // whether NOT to add random addition to URL
                preparePost: true, // whether set Content-Type x-www-form-urlencoded in POST
                headers: false, // add additional headers, example: [{'name': 'If-Modified-Since', 'value': 'Wed, 15 Aug 2012 08:59:08 GMT'}, {'name': 'If-None-Match', 'value': '0'}]
                lsTimeout: 30, //local storage data TTL. useless without lsId.
                lsForce: false //wheter to force query instead of using localStorage data. useless without lsId.
                /*
other parameters:
	url: url to get/post
	data: data to post
	onsuccess: successful request callback. BX.proxy may be used.
	onfailure: request failure callback. BX.proxy may be used.
	onprogress: request progress callback. BX.proxy may be used.

	lsId: local storage id - for constantly updating queries which can communicate via localStorage. core_ls.js needed

any of the default parameters can be overridden. defaults can be changed by BX.ajax.Setup() - for all further requests!
*/
            },
            ajax_session = null,
            loadedScripts = {},
            loadedScriptsQueue = [],
            r = {
                'url_utf': /[^\034-\254]+/g,
                'script_self': /\/bitrix\/js\/main\/core\/core(_ajax)*.js$/i,
                'script_self_window': /\/bitrix\/js\/main\/core\/core_window.js$/i,
                'script_self_admin': /\/bitrix\/js\/main\/core\/core_admin.js$/i,
                'script_onload': /window.onload/g
            };

// low-level method
        BX.ajax = function(config)
        {
            var status, data;

            if (!config || !config.url || !BX.type.isString(config.url))
            {
                return false;
            }

            for (var i in tempDefaultConfig)
                if (typeof (config[i]) == "undefined") config[i] = tempDefaultConfig[i];

            tempDefaultConfig = {};

            for (i in defaultConfig)
                if (typeof (config[i]) == "undefined") config[i] = defaultConfig[i];

            config.method = config.method.toUpperCase();

            if (!BX.localStorage)
                config.lsId = null;

            if (BX.browser.IsIE())
            {
                var result = r.url_utf.exec(config.url);
                if (result)
                {
                    do
                    {
                        config.url = config.url.replace(result, BX.util.urlencode(result));
                        result = r.url_utf.exec(config.url);
                    } while (result);
                }
            }

            if(config.dataType == 'json')
                config.emulateOnload = false;

            if (!config.cache && config.method == 'GET')
                config.url = BX.ajax._uncache(config.url);

            if (config.method == 'POST')
            {
                if (config.preparePost)
                {
                    config.data = BX.ajax.prepareData(config.data);
                }
                else if (getLastContentTypeHeader(config.headers) === 'application/json')
                {
                    config.data = JSON.stringify(config.data);
                }
            }

            var bXHR = true;
            if (config.lsId && !config.lsForce)
            {
                var v = BX.localStorage.get('ajax-' + config.lsId);
                if (v !== null)
                {
                    bXHR = false;

                    var lsHandler = function(lsData) {
                        if (lsData.key == 'ajax-' + config.lsId && lsData.value != 'BXAJAXWAIT')
                        {
                            var data = lsData.value,
                                bRemove = !!lsData.oldValue && data == null;
                            if (!bRemove)
                                BX.ajax.__run(config, data);
                            else if (config.onfailure)
                                config.onfailure("timeout");

                            BX.removeCustomEvent('onLocalStorageChange', lsHandler);
                        }
                    };

                    if (v == 'BXAJAXWAIT')
                    {
                        BX.addCustomEvent('onLocalStorageChange', lsHandler);
                    }
                    else
                    {
                        setTimeout(function() {lsHandler({key: 'ajax-' + config.lsId, value: v})}, 10);
                    }
                }
            }

            if (bXHR)
            {
                config.xhr = BX.ajax.xhr();
                if (!config.xhr) return;

                if (config.lsId)
                {
                    BX.localStorage.set('ajax-' + config.lsId, 'BXAJAXWAIT', config.lsTimeout);
                }

                config.xhr.open(config.method, config.url, config.async);

                if (!config.skipBxHeader && !BX.ajax.isCrossDomain(config.url))
                {
                    config.xhr.setRequestHeader('Bx-ajax', 'true');
                }

                if (config.method == 'POST' && config.preparePost)
                {
                    config.xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
                }
                if (typeof(config.headers) == "object")
                {
                    for (i = 0; i < config.headers.length; i++)
                        config.xhr.setRequestHeader(config.headers[i].name, config.headers[i].value);
                }

                if(!!config.onprogress)
                {
                    BX.bind(config.xhr, 'progress', config.onprogress);
                }

                var bRequestCompleted = false;
                var onreadystatechange = config.xhr.onreadystatechange = function(additional)
                {
                    if (bRequestCompleted)
                        return;

                    if (additional === 'timeout')
                    {
                        if (config.onfailure)
                        {
                            config.onfailure("timeout");
                        }

                        BX.onCustomEvent(config.xhr, 'onAjaxFailure', ['timeout', '', config]);

                        config.xhr.onreadystatechange = BX.DoNothing;
                        config.xhr.abort();

                        if (config.async)
                        {
                            config.xhr = null;
                        }
                    }
                    else
                    {
                        if (config.xhr.readyState == 4 || additional == 'run')
                        {
                            status = BX.ajax.xhrSuccess(config.xhr) ? "success" : "error";
                            bRequestCompleted = true;
                            config.xhr.onreadystatechange = BX.DoNothing;

                            if (status == 'success')
                            {
                                var authHeader = (!!config.skipAuthCheck || BX.ajax.isCrossDomain(config.url))
                                    ? false
                                    : config.xhr.getResponseHeader('X-Bitrix-Ajax-Status');

                                if(!!authHeader && authHeader == 'Authorize')
                                {
                                    if (config.onfailure)
                                    {
                                        config.onfailure("auth", config.xhr.status);
                                    }

                                    BX.onCustomEvent(config.xhr, 'onAjaxFailure', ['auth', config.xhr.status, config]);
                                }
                                else
                                {
                                    var data = config.xhr.responseText;

                                    if (config.lsId)
                                    {
                                        BX.localStorage.set('ajax-' + config.lsId, data, config.lsTimeout);
                                    }

                                    BX.ajax.__run(config, data);
                                }
                            }
                            else
                            {
                                if (config.onfailure)
                                {
                                    config.onfailure("status", config.xhr.status);
                                }

                                BX.onCustomEvent(config.xhr, 'onAjaxFailure', ['status', config.xhr.status, config]);
                            }

                            if (config.async)
                            {
                                config.xhr = null;
                            }
                        }
                    }
                };

                if (config.async && config.timeout > 0)
                {
                    setTimeout(function() {
                        if (config.xhr && !bRequestCompleted)
                        {
                            onreadystatechange("timeout");
                        }
                    }, config.timeout * 1000);
                }

                if (config.start)
                {
                    config.xhr.send(config.data);

                    if (!config.async)
                    {
                        onreadystatechange('run');
                    }
                }

                return config.xhr;
            }
        };

        BX.ajax.xhr = function()
        {
            if (window.XMLHttpRequest)
            {
                try {return new XMLHttpRequest();} catch(e){}
            }
            else if (window.ActiveXObject)
            {
                try { return new window.ActiveXObject("Msxml2.XMLHTTP.6.0"); }
                catch(e) {}
                try { return new window.ActiveXObject("Msxml2.XMLHTTP.3.0"); }
                catch(e) {}
                try { return new window.ActiveXObject("Msxml2.XMLHTTP"); }
                catch(e) {}
                try { return new window.ActiveXObject("Microsoft.XMLHTTP"); }
                catch(e) {}
                throw new Error("This browser does not support XMLHttpRequest.");
            }

            return null;
        };

        BX.ajax.isCrossDomain = function(url, location)
        {
            location = location || window.location;

            //Relative URL gets a current protocol
            if (url.indexOf("//") === 0)
            {
                url = location.protocol + url;
            }

            //Fast check
            if (url.indexOf("http") !== 0)
            {
                return false;
            }

            var link = window.document.createElement("a");
            link.href = url;

            return  link.protocol !== location.protocol ||
                link.hostname !== location.hostname ||
                BX.ajax.getHostPort(link.protocol, link.host) !== BX.ajax.getHostPort(location.protocol, location.host);
        };

        BX.ajax.getHostPort = function(protocol, host)
        {
            var match = /:(\d+)$/.exec(host);
            if (match)
            {
                return match[1];
            }
            else
            {
                if (protocol === "index.html")
                {
                    return "80";
                }
                else if (protocol === "index.html")
                {
                    return "443";
                }
            }

            return "";
        };

        BX.ajax.__prepareOnload = function(scripts)
        {
            if (scripts.length > 0)
            {
                BX.ajax['onload_' + ajax_session] = null;

                for (var i=0,len=scripts.length;i<len;i++)
                {
                    if (scripts[i].isInternal)
                    {
                        scripts[i].JS = scripts[i].JS.replace(r.script_onload, 'BX.ajax.onload_' + ajax_session);
                    }
                }
            }

            BX.CaptureEventsGet();
            BX.CaptureEvents(window, 'load');
        };

        BX.ajax.__runOnload = function()
        {
            if (null != BX.ajax['onload_' + ajax_session])
            {
                BX.ajax['onload_' + ajax_session].apply(window);
                BX.ajax['onload_' + ajax_session] = null;
            }

            var h = BX.CaptureEventsGet();

            if (h)
            {
                for (var i=0; i<h.length; i++)
                    h[i].apply(window);
            }
        };

        BX.ajax.__run = function(config, data)
        {
            if (!config.processData)
            {
                if (config.onsuccess)
                {
                    config.onsuccess(data);
                }

                BX.onCustomEvent(config.xhr, 'onAjaxSuccess', [data, config]);
            }
            else
            {
                data = BX.ajax.processRequestData(data, config);
            }
        };


        BX.ajax._onParseJSONFailure = function(data)
        {
            this.jsonFailure = true;
            this.jsonResponse = data;
            this.jsonProactive = /^\[WAF\]/.test(data);
        };

        BX.ajax.processRequestData = function(data, config)
        {
            var result, scripts = [], styles = [];
            switch (config.dataType.toUpperCase())
            {
                case 'JSON':

                    var context = config.xhr || {};
                    BX.addCustomEvent(context, 'onParseJSONFailure', BX.proxy(BX.ajax._onParseJSONFailure, config));
                    result = BX.parseJSON(data, context);
                    BX.removeCustomEvent(context, 'onParseJSONFailure', BX.proxy(BX.ajax._onParseJSONFailure, config));

                    if(!!result && BX.type.isArray(result['bxjs']))
                    {
                        for(var i = 0; i < result['bxjs'].length; i++)
                        {
                            if(BX.type.isNotEmptyString(result['bxjs'][i]))
                            {
                                scripts.push({
                                    "isInternal": false,
                                    "JS": result['bxjs'][i],
                                    "bRunFirst": config.scriptsRunFirst
                                });
                            }
                            else
                            {
                                scripts.push(result['bxjs'][i])
                            }
                        }
                    }

                    if(!!result && BX.type.isArray(result['bxcss']))
                    {
                        styles = result['bxcss'];
                    }

                    break;
                case 'SCRIPT':
                    scripts.push({"isInternal": true, "JS": data, "bRunFirst": config.scriptsRunFirst});
                    result = data;
                    break;

                default: // HTML
                    var ob = BX.processHTML(data, config.scriptsRunFirst);
                    result = ob.HTML; scripts = ob.SCRIPT; styles = ob.STYLE;
                    break;
            }

            var bSessionCreated = false;
            if (null == ajax_session)
            {
                ajax_session = parseInt(Math.random() * 1000000);
                bSessionCreated = true;
            }

            if (styles.length > 0)
                BX.loadCSS(styles);

            if (config.emulateOnload)
                BX.ajax.__prepareOnload(scripts);

            var cb = BX.DoNothing;
            if(config.emulateOnload || bSessionCreated)
            {
                cb = BX.defer(function()
                {
                    if (config.emulateOnload)
                        BX.ajax.__runOnload();
                    if (bSessionCreated)
                        ajax_session = null;
                    BX.onCustomEvent(config.xhr, 'onAjaxSuccessFinish', [config]);
                });
            }

            try
            {
                if (!!config.jsonFailure)
                {
                    throw {type: 'json_failure', data: config.jsonResponse, bProactive: config.jsonProactive};
                }

                config.scripts = scripts;

                BX.ajax.processScripts(config.scripts, true);

                if (config.onsuccess)
                {
                    config.onsuccess(result);
                }

                BX.onCustomEvent(config.xhr, 'onAjaxSuccess', [result, config]);

                BX.ajax.processScripts(config.scripts, false, cb);
            }
            catch (e)
            {
                if (config.onfailure)
                    config.onfailure("processing", e);
                BX.onCustomEvent(config.xhr, 'onAjaxFailure', ['processing', e, config]);
            }
        };

        BX.ajax.processScripts = function(scripts, bRunFirst, cb)
        {
            var scriptsExt = [], scriptsInt = '';

            cb = cb || BX.DoNothing;

            for (var i = 0, length = scripts.length; i < length; i++)
            {
                if (typeof bRunFirst != 'undefined' && bRunFirst != !!scripts[i].bRunFirst)
                    continue;

                if (scripts[i].isInternal)
                    scriptsInt += ';' + scripts[i].JS;
                else
                    scriptsExt.push(scripts[i].JS);
            }

            scriptsExt = BX.util.array_unique(scriptsExt);
            var inlineScripts = scriptsInt.length > 0 ? function() { BX.evalGlobal(scriptsInt); } : BX.DoNothing;

            if (scriptsExt.length > 0)
            {
                BX.load(scriptsExt, function() {
                    inlineScripts();
                    cb();
                });
            }
            else
            {
                inlineScripts();
                cb();
            }
        };

// TODO: extend this function to use with any data objects or forms
        BX.ajax.prepareData = function(arData, prefix)
        {
            var data = '';
            if (BX.type.isString(arData))
                data = arData;
            else if (null != arData)
            {
                for(var i in arData)
                {
                    if (arData.hasOwnProperty(i))
                    {
                        if (data.length > 0)
                            data += '&';
                        var name = BX.util.urlencode(i);
                        if(prefix)
                            name = prefix + '[' + name + ']';
                        if(typeof arData[i] == 'object')
                            data += BX.ajax.prepareData(arData[i], name);
                        else
                            data += name + '=' + BX.util.urlencode(arData[i]);
                    }
                }
            }
            return data;
        };

        BX.ajax.xhrSuccess = function(xhr)
        {
            return (xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || xhr.status === 1223 || xhr.status === 0;
        };

        BX.ajax.Setup = function(config, bTemp)
        {
            bTemp = !!bTemp;

            for (var i in config)
            {
                if (bTemp)
                    tempDefaultConfig[i] = config[i];
                else
                    defaultConfig[i] = config[i];
            }
        };

        BX.ajax.replaceLocalStorageValue = function(lsId, data, ttl)
        {
            if (!!BX.localStorage)
                BX.localStorage.set('ajax-' + lsId, data, ttl);
        };


        BX.ajax._uncache = function(url)
        {
            return url + ((url.indexOf('?') !== -1 ? "&" : "?") + '_=' + (new Date()).getTime());
        };

        /* simple interface */
        BX.ajax.get = function(url, data, callback)
        {
            if (BX.type.isFunction(data))
            {
                callback = data;
                data = '';
            }

            data = BX.ajax.prepareData(data);

            if (data)
            {
                url += (url.indexOf('?') !== -1 ? "&" : "?") + data;
                data = '';
            }

            return BX.ajax({
                'method': 'GET',
                'dataType': 'html',
                'url': url,
                'data':  '',
                'onsuccess': callback
            });
        };

        BX.ajax.getCaptcha = function(callback)
        {
            return BX.ajax.loadJSON('bitrix/tools/ajax_captcha.html', callback);
        };

        BX.ajax.insertToNode = function(url, node)
        {
            node = BX(node);
            if (!!node)
            {
                var eventArgs = { cancel: false };
                BX.onCustomEvent('onAjaxInsertToNode', [{ url: url, node: node, eventArgs: eventArgs }]);
                if(eventArgs.cancel === true)
                {
                    return;
                }

                var show = null;
                if (!tempDefaultConfig.denyShowWait)
                {
                    show = BX.showWait(node);
                    delete tempDefaultConfig.denyShowWait;
                }

                return BX.ajax.get(url, function(data) {
                    node.innerHTML = data;
                    BX.closeWait(node, show);
                });
            }
        };

        BX.ajax.post = function(url, data, callback)
        {
            data = BX.ajax.prepareData(data);

            return BX.ajax({
                'method': 'POST',
                'dataType': 'html',
                'url': url,
                'data':  data,
                'onsuccess': callback
            });
        };

        /**
         * BX.ajax with BX.Promise
         *
         * @param config
         * @returns {BX.Promise|false}
         */
        BX.ajax.promise = function(config)
        {
            var result = new BX.Promise();

            config.onsuccess = function(data)
            {
                result.fulfill(data);
            };
            config.onfailure = function(reason, data)
            {
                result.reject({
                    reason: reason,
                    data: data
                });
            };
            config.onprogress = function(data)
            {
                if (data.position == 0 && data.totalSize == 0)
                {
                    result.reject({
                        reason: 'progress',
                        data: data
                    });
                }
            };

            var xhr = BX.ajax(config);
            if (xhr)
            {
                if (typeof config.onrequeststart === 'function')
                {
                    config.onrequeststart(xhr);
                }
            }
            else
            {
                result.reject({
                    reason: "init",
                    data: false
                });
            }

            return result;
        };

        /* load and execute external file script with onload emulation */
        BX.ajax.loadScriptAjax = function(script_src, callback, bPreload)
        {
            if (BX.type.isArray(script_src))
            {
                for (var i=0,len=script_src.length;i<len;i++)
                {
                    BX.ajax.loadScriptAjax(script_src[i], callback, bPreload);
                }
            }
            else
            {
                var script_src_test = script_src.replace(/\.js\?.*/, '.js');

                if (r.script_self.test(script_src_test)) return;
                if (r.script_self_window.test(script_src_test) && BX.CWindow) return;
                if (r.script_self_admin.test(script_src_test) && BX.admin) return;

                if (typeof loadedScripts[script_src_test] == 'undefined')
                {
                    if (!!bPreload)
                    {
                        loadedScripts[script_src_test] = '';
                        return BX.loadScript(script_src);
                    }
                    else
                    {
                        return BX.ajax({
                            url: script_src,
                            method: 'GET',
                            dataType: 'script',
                            processData: true,
                            emulateOnload: false,
                            scriptsRunFirst: true,
                            async: false,
                            start: true,
                            onsuccess: function(result) {
                                loadedScripts[script_src_test] = result;
                                if (callback)
                                    callback(result);
                            }
                        });
                    }
                }
                else if (callback)
                {
                    callback(loadedScripts[script_src_test]);
                }
            }
        };

        /* non-xhr loadings */
        BX.ajax.loadJSON = function(url, data, callback, callback_failure)
        {
            if (BX.type.isFunction(data))
            {
                callback_failure = callback;
                callback = data;
                data = '';
            }

            data = BX.ajax.prepareData(data);

            if (data)
            {
                url += (url.indexOf('?') !== -1 ? "&" : "?") + data;
                data = '';
            }

            return BX.ajax({
                'method': 'GET',
                'dataType': 'json',
                'url': url,
                'onsuccess': callback,
                'onfailure': callback_failure
            });
        };

        var getLastContentTypeHeader = function (headers) {
            if (!BX.Type.isArray(headers))
            {
                return null;
            }
            var lastHeader = headers
                .filter(function (header) {
                    return header.name === 'Content-Type';
                })
                .pop();

            return lastHeader ? lastHeader.value : null;
        };

        var prepareAjaxGetParameters = function(config)
        {
            var getParameters = config.getParameters || {};
            if (BX.type.isNotEmptyString(config.analyticsLabel))
            {
                getParameters.analyticsLabel = config.analyticsLabel;
            }
            else if (BX.type.isNotEmptyObject(config.analyticsLabel))
            {
                getParameters.analyticsLabel = config.analyticsLabel;
            }
            if (typeof config.mode !== 'undefined')
            {
                getParameters.mode = config.mode;
            }
            if (config.navigation)
            {
                if(config.navigation.page)
                {
                    getParameters.nav = 'page-' + config.navigation.page;
                }
                if(config.navigation.size)
                {
                    if(getParameters.nav)
                    {
                        getParameters.nav += '-';
                    }
                    else
                    {
                        getParameters.nav = '';
                    }
                    getParameters.nav += 'size-' + config.navigation.size;
                }
            }

            return getParameters;
        };

        var prepareAjaxConfig = function(config)
        {
            config = BX.type.isPlainObject(config) ? config : {};

            if (typeof config.json !== 'undefined')
            {
                if (!BX.type.isPlainObject(config.json))
                {
                    throw new Error('Wrong `config.json`, plain object expected.')
                }

                config.headers = config.headers || [];
                config.headers.push({name: 'Content-Type', value: 'application/json'});
                config.headers.push({name: 'X-Bitrix-Csrf-Token', value: BX.bitrix_sessid()});
                if (BX.message.SITE_ID)
                {
                    config.headers.push({name: 'X-Bitrix-Site-Id', value: BX.message.SITE_ID});
                }

                config.data = config.json;
                config.preparePost = false;
            }
            else if (config.data instanceof FormData)
            {
                config.preparePost = false;

                config.data.append('sessid', BX.bitrix_sessid());
                if (BX.message.SITE_ID)
                {
                    config.data.append('SITE_ID', BX.message.SITE_ID);
                }
                if (typeof config.signedParameters !== 'undefined')
                {
                    config.data.append('signedParameters', config.signedParameters);
                }
            }
            else
            {
                config.data = BX.type.isPlainObject(config.data) ? config.data : {};
                if (BX.message.SITE_ID)
                {
                    config.data.SITE_ID = BX.message.SITE_ID;
                }
                config.data.sessid = BX.bitrix_sessid();
                if (typeof config.signedParameters !== 'undefined')
                {
                    config.data.signedParameters = config.signedParameters;
                }
            }

            if (!config.method)
            {
                config.method = 'POST'
            }

            return config;
        };

        var buildAjaxPromiseToRestoreCsrf = function(config, withoutRestoringCsrf)
        {
            withoutRestoringCsrf = withoutRestoringCsrf || false;
            var originalConfig = BX.clone(config);
            var request = null;

            var onrequeststart = config.onrequeststart;
            config.onrequeststart = function(xhr) {
                request = xhr;
                if (BX.type.isFunction(onrequeststart))
                {
                    onrequeststart(xhr);
                }
            };
            var onrequeststartOrig = originalConfig.onrequeststart;
            originalConfig.onrequeststart = function(xhr) {
                request = xhr;
                if (BX.type.isFunction(onrequeststartOrig))
                {
                    onrequeststartOrig(xhr);
                }
            };

            var promise = BX.ajax.promise(config);

            return promise.then(function(response) {
                if (!withoutRestoringCsrf && BX.type.isPlainObject(response) && BX.type.isArray(response.errors))
                {
                    var csrfProblem = false;
                    response.errors.forEach(function(error) {
                        if (error.code === 'invalid_csrf' && error.customData.csrf)
                        {
                            BX.message({'bitrix_sessid': error.customData.csrf});
                            originalConfig.data.sessid = BX.bitrix_sessid();

                            csrfProblem = true;
                        }
                    });

                    if (csrfProblem)
                    {
                        return buildAjaxPromiseToRestoreCsrf(originalConfig, true);
                    }
                }

                if (!BX.type.isPlainObject(response) || response.status !== 'success')
                {
                    var errorPromise = new BX.Promise();
                    errorPromise.reject(response);

                    return errorPromise;
                }

                return response;
            }).catch(function(data) {
                var ajaxReject = new BX.Promise();

                if (BX.type.isPlainObject(data) && data.status && data.hasOwnProperty('data'))
                {
                    ajaxReject.reject(data);
                }
                else
                {
                    ajaxReject.reject({
                        status: 'error',
                        data: {
                            ajaxRejectData: data
                        },
                        errors: [
                            {
                                code: 'NETWORK_ERROR',
                                message: 'Network error'
                            }
                        ]
                    });
                }

                return ajaxReject;
            }).then(function(response){

                var assetsLoaded = new BX.Promise();

                var headers = request.getAllResponseHeaders().trim().split(/[\r\n]+/);
                var headerMap = {};
                headers.forEach(function (line) {
                    var parts = line.split(': ');
                    var header = parts.shift().toLowerCase();
                    headerMap[header] = parts.join(': ');
                });

                if (!headerMap['x-process-assets'])
                {
                    assetsLoaded.fulfill(response);

                    return assetsLoaded;
                }

                var assets = BX.prop.getObject(BX.prop.getObject(response, "data", {}), "assets", {});
                var promise = new Promise(function(resolve, reject) {
                    var css = BX.prop.getArray(assets, "css", []);
                    BX.load(css, function(){
                        BX.loadScript(
                            BX.prop.getArray(assets, "js", []),
                            resolve
                        );
                    });
                });
                promise.then(function(){
                    var strings = BX.prop.getArray(assets, "string", []);
                    var stringAsset = strings.join('\n');
                    BX.html(null, stringAsset).then(function(){
                        assetsLoaded.fulfill(response);
                    });
                });

                return assetsLoaded;
            });
        };

        /**
         *
         * @param {string} action
         * @param {Object} config
         * @param {?string|?Object} [config.analyticsLabel]
         * @param {string} [config.method='POST']
         * @param {Object} [config.data]
         * @param {?Object} [config.getParameters]
         * @param {?Object} [config.headers]
         * @param {?Object} [config.timeout]
         * @param {Object} [config.navigation]
         * @param {number} [config.navigation.page]
         */
        BX.ajax.runAction = function(action, config)
        {
            config = prepareAjaxConfig(config);
            var getParameters = prepareAjaxGetParameters(config);
            getParameters.action = action;

            var url = 'bitrix/services/main/ajaxd41d.json?' + BX.ajax.prepareData(getParameters);
            return buildAjaxPromiseToRestoreCsrf({
                method: config.method,
                dataType: 'json',
                url: url,
                data: config.data,
                timeout: config.timeout,
                preparePost: config.preparePost,
                headers: config.headers,
                onrequeststart: config.onrequeststart
            });
        };

        /**
         *
         * @param {string} component
         * @param {string} action
         * @param {Object} config
         * @param {?string|?Object} [config.analyticsLabel]
         * @param {?string} [config.signedParameters]
         * @param {string} [config.method='POST']
         * @param {string} [config.mode='ajax'] Ajax or class.
         * @param {Object} [config.data]
         * @param {?Object} [config.getParameters]
         * @param {?array} [config.headers]
         * @param {?number} [config.timeout]
         * @param {Object} [config.navigation]
         */
        BX.ajax.runComponentAction = function (component, action, config)
        {
            config = prepareAjaxConfig(config);
            config.mode = config.mode || 'ajax';

            var getParameters = prepareAjaxGetParameters(config);
            getParameters.c = component;
            getParameters.action = action;

            var url = 'bitrix/services/main/ajaxd41d.json?' + BX.ajax.prepareData(getParameters);

            return buildAjaxPromiseToRestoreCsrf({
                method: config.method,
                dataType: 'json',
                url: url,
                data: config.data,
                timeout: config.timeout,
                preparePost: config.preparePost,
                headers: config.headers,
                onrequeststart: (config.onrequeststart ? config.onrequeststart : null)
            });
        };

        /*
arObs = [{
	url: url,
	type: html|script|json|css,
	callback: function
}]
*/
        BX.ajax.load = function(arObs, callback)
        {
            if (!BX.type.isArray(arObs))
                arObs = [arObs];

            var cnt = 0;

            if (!BX.type.isFunction(callback))
                callback = BX.DoNothing;

            var handler = function(data)
            {
                if (BX.type.isFunction(this.callback))
                    this.callback(data);

                if (++cnt >= len)
                    callback();
            };

            for (var i = 0, len = arObs.length; i<len; i++)
            {
                switch(arObs[i].type.toUpperCase())
                {
                    case 'SCRIPT':
                        BX.loadScript([arObs[i].url], BX.proxy(handler, arObs[i]));
                        break;
                    case 'CSS':
                        BX.loadCSS([arObs[i].url]);

                        if (++cnt >= len)
                            callback();
                        break;
                    case 'JSON':
                        BX.ajax.loadJSON(arObs[i].url, BX.proxy(handler, arObs[i]));
                        break;

                    default:
                        BX.ajax.get(arObs[i].url, '', BX.proxy(handler, arObs[i]));
                        break;
                }
            }
        };

        /* ajax form sending */
        BX.ajax.submit = function(obForm, callback)
        {
            if (!obForm.target)
            {
                if (null == obForm.BXFormTarget)
                {
                    var frame_name = 'formTarget_' + Math.random();
                    obForm.BXFormTarget = document.body.appendChild(BX.create('IFRAME', {
                        props: {
                            name: frame_name,
                            id: frame_name,
                            src: 'javascript:void(0)'
                        },
                        style: {
                            display: 'none'
                        }
                    }));
                }

                obForm.target = obForm.BXFormTarget.name;
            }

            obForm.BXFormCallback = callback;
            BX.bind(obForm.BXFormTarget, 'load', BX.proxy(BX.ajax._submit_callback, obForm));

            BX.submit(obForm);

            return false;
        };

        BX.ajax.submitComponentForm = function(obForm, container, bWait)
        {
            if (!obForm.target)
            {
                if (null == obForm.BXFormTarget)
                {
                    var frame_name = 'formTarget_' + Math.random();
                    obForm.BXFormTarget = document.body.appendChild(BX.create('IFRAME', {
                        props: {
                            name: frame_name,
                            id: frame_name,
                            src: 'javascript:void(0)'
                        },
                        style: {
                            display: 'none'
                        }
                    }));
                }

                obForm.target = obForm.BXFormTarget.name;
            }

            if (!!bWait)
                var w = BX.showWait(container);

            obForm.BXFormCallback = function(d) {
                if (!!bWait)
                    BX.closeWait(w);

                var callOnload = function(){
                    if(!!window.bxcompajaxframeonload)
                    {
                        setTimeout(function(){window.bxcompajaxframeonload();window.bxcompajaxframeonload=null;}, 10);
                    }
                };

                BX(container).innerHTML = d;
                BX.onCustomEvent('onAjaxSuccess', [null,null,callOnload]);
            };

            BX.bind(obForm.BXFormTarget, 'load', BX.proxy(BX.ajax._submit_callback, obForm));

            return true;
        };

// func will be executed in form context
        BX.ajax._submit_callback = function()
        {
            //opera and IE8 triggers onload event even on empty iframe
            try
            {
                if(this.BXFormTarget.contentWindow.location.href.indexOf('http') != 0)
                    return;
            } catch (e) {
                return;
            }

            if (this.BXFormCallback)
                this.BXFormCallback.apply(this, [this.BXFormTarget.contentWindow.document.body.innerHTML]);

            BX.unbindAll(this.BXFormTarget);
        };

        BX.ajax.prepareForm = function(obForm, data)
        {
            data = (!!data ? data : {});
            var i, ii, el,
                _data = [],
                n = obForm.elements.length,
                files = 0, length = 0;
            if(!!obForm)
            {
                for (i = 0; i < n; i++)
                {
                    el = obForm.elements[i];
                    if (el.disabled)
                        continue;

                    if(!el.type)
                        continue;

                    switch(el.type.toLowerCase())
                    {
                        case 'text':
                        case 'textarea':
                        case 'password':
                        case 'number':
                        case 'hidden':
                        case 'select-one':
                            _data.push({name: el.name, value: el.value});
                            length += (el.name.length + el.value.length);
                            break;
                        case 'file':
                            if (!!el.files)
                            {
                                for (ii = 0; ii < el.files.length; ii++)
                                {
                                    files++;
                                    _data.push({name: el.name, value: el.files[ii], file : true});
                                    length += el.files[ii].size;
                                }
                            }
                            break;
                        case 'radio':
                        case 'checkbox':
                            if(el.checked)
                            {
                                _data.push({name: el.name, value: el.value});
                                length += (el.name.length + el.value.length);
                            }
                            break;
                        case 'select-multiple':
                            for (var j = 0; j < el.options.length; j++)
                            {
                                if (el.options[j].selected)
                                {
                                    _data.push({name : el.name, value : el.options[j].value});
                                    length += (el.name.length + el.options[j].length);
                                }
                            }
                            break;
                        default:
                            break;
                    }
                }

                i = 0; length = 0;
                var current = data, name, rest, pp, tmpKey;

                while(i < _data.length)
                {
                    var p = _data[i].name.indexOf('[');
                    if (tmpKey)
                    {
                        current[_data[i].name] = {};
                        current[_data[i].name][tmpKey.replace(/\[|\]/gi, '')] = _data[i].value;
                        current = data;
                        tmpKey = null;
                        i++;
                    }
                    else if (p == -1)
                    {
                        current[_data[i].name] = _data[i].value;
                        current = data;
                        i++;
                    }
                    else
                    {
                        name = _data[i].name.substring(0, p);
                        rest = _data[i].name.substring(p+1);
                        pp = rest.indexOf(']');

                        if(pp == -1)
                        {
                            if (!current[name])
                                current[name] = [];
                            current = data;
                            i++;
                        }
                        else if(pp == 0)
                        {
                            if (!current[name])
                                current[name] = [];
                            //No index specified - so take the next integer
                            current = current[name];
                            _data[i].name = '' + current.length;
                            if (rest.substring(pp+1).indexOf('[') === 0)
                                tmpKey = rest.substring(0, pp) + rest.substring(pp+1);
                        }
                        else
                        {
                            if (!current[name])
                                current[name] = {};
                            //Now index name becomes and name and we go deeper into the array
                            current = current[name];
                            _data[i].name = rest.substring(0, pp) + rest.substring(pp+1);
                        }
                    }
                }
            }
            return {data : data, filesCount : files, roughSize : length};
        };
        BX.ajax.submitAjax = function(obForm, config)
        {
            config = (config !== null && typeof config == "object" ? config : {});
            config.url = (config["url"] || obForm.getAttribute("action"));

            var additionalData = (config["data"] || {});
            config.data = BX.ajax.prepareForm(obForm).data;
            for (var ii in additionalData)
            {
                if (additionalData.hasOwnProperty(ii))
                {
                    config.data[ii] = additionalData[ii];
                }
            }

            if (!window["FormData"])
            {
                BX.ajax(config);
            }
            else
            {
                var isFile = function(item)
                    {
                        var res = Object.prototype.toString.call(item);
                        return (res == '[object File]' || res == '[object Blob]');
                    },
                    appendToForm = function(fd, key, val)
                    {
                        if (!!val && typeof val == "object" && !isFile(val))
                        {
                            for (var ii in val)
                            {
                                if (val.hasOwnProperty(ii))
                                {
                                    appendToForm(fd, (key == '' ? ii : key + '[' + ii + ']'), val[ii]);
                                }
                            }
                        }
                        else
                            fd.append(key, (!!val ? val : ''));
                    },
                    prepareData = function(arData)
                    {
                        var data = {};
                        if (null != arData)
                        {
                            if(typeof arData == 'object')
                            {
                                for(var i in arData)
                                {
                                    if (arData.hasOwnProperty(i))
                                    {
                                        var name = BX.util.urlencode(i);
                                        if(typeof arData[i] == 'object' && arData[i]["file"] !== true)
                                            data[name] = prepareData(arData[i]);
                                        else if (arData[i]["file"] === true)
                                            data[name] = arData[i]["value"];
                                        else
                                            data[name] = BX.util.urlencode(arData[i]);
                                    }
                                }
                            }
                            else
                                data = BX.util.urlencode(arData);
                        }
                        return data;
                    },
                    fd = new window.FormData();

                if (config.method !== 'POST')
                {
                    config.data = BX.ajax.prepareData(config.data);
                    if (config.data)
                    {
                        config.url += (config.url.indexOf('?') !== -1 ? "&" : "?") + config.data;
                        config.data = '';
                    }
                }
                else
                {
                    if (config.preparePost === true)
                        config.data = prepareData(config.data);
                    appendToForm(fd, '', config.data);
                    config.data = fd;
                }

                config.preparePost = false;
                config.start = false;

                var xhr = BX.ajax(config);
                if (!!config["onprogress"])
                    xhr.upload.addEventListener(
                        'progress',
                        function(e){
                            var percent = null;
                            if(e.lengthComputable && (e.total || e["totalSize"])) {
                                percent = e.loaded * 100 / (e.total || e["totalSize"]);
                            }
                            config["onprogress"](e, percent);
                        }
                    );
                xhr.send(fd);
            }
        };

        BX.ajax.UpdatePageData = function (arData)
        {
            if (arData.TITLE)
                BX.ajax.UpdatePageTitle(arData.TITLE);
            if (arData.WINDOW_TITLE || arData.TITLE)
                BX.ajax.UpdateWindowTitle(arData.WINDOW_TITLE || arData.TITLE);
            if (arData.NAV_CHAIN)
                BX.ajax.UpdatePageNavChain(arData.NAV_CHAIN);
            if (arData.CSS && arData.CSS.length > 0)
                BX.loadCSS(arData.CSS);
            if (arData.SCRIPTS && arData.SCRIPTS.length > 0)
            {
                var f = function(result,config,cb){

                    if(!!config && BX.type.isArray(config.scripts))
                    {
                        for(var i=0,l=arData.SCRIPTS.length;i<l;i++)
                        {
                            config.scripts.push({isInternal:false,JS:arData.SCRIPTS[i]});
                        }
                    }
                    else
                    {
                        BX.loadScript(arData.SCRIPTS,cb);
                    }

                    BX.removeCustomEvent('onAjaxSuccess',f);
                };
                BX.addCustomEvent('onAjaxSuccess',f);
            }
            else
            {
                var f1 = function(result,config,cb){
                    if(BX.type.isFunction(cb))
                    {
                        cb();
                    }
                    BX.removeCustomEvent('onAjaxSuccess',f1);
                };
                BX.addCustomEvent('onAjaxSuccess', f1);
            }
        };

        BX.ajax.UpdatePageTitle = function(title)
        {
            var obTitle = BX('pagetitle');
            if (obTitle)
            {
                obTitle.removeChild(obTitle.firstChild);
                if (!obTitle.firstChild)
                    obTitle.appendChild(document.createTextNode(title));
                else
                    obTitle.insertBefore(document.createTextNode(title), obTitle.firstChild);
            }
        };

        BX.ajax.UpdateWindowTitle = function(title)
        {
            document.title = title;
        };

        BX.ajax.UpdatePageNavChain = function(nav_chain)
        {
            var obNavChain = BX('navigation');
            if (obNavChain)
            {
                obNavChain.innerHTML = nav_chain;
            }
        };

        /* user options handling */
        BX.userOptions = {
            options: null,
            bSend: false,
            delay: 5000,
            path: '/bitrix/admin/user_options.php?'
        };

        BX.userOptions.setAjaxPath = function(url)
        {
            BX.userOptions.path = url.indexOf('?') == -1? url+'?': url+'&';
        }
        BX.userOptions.save = function(sCategory, sName, sValName, sVal, bCommon)
        {
            if (null == BX.userOptions.options)
                BX.userOptions.options = {};

            bCommon = !!bCommon;
            BX.userOptions.options[sCategory+'.'+sName+'.'+sValName] = [sCategory, sName, sValName, sVal, bCommon];

            var sParam = BX.userOptions.__get();
            if (sParam != '')
                document.cookie = BX.message('COOKIE_PREFIX')+"_LAST_SETTINGS=" + encodeURIComponent(sParam) + "&sessid="+BX.bitrix_sessid()+"; expires=Thu, 31 Dec 2020 23:59:59 GMT; path=/;";

            if(!BX.userOptions.bSend)
            {
                BX.userOptions.bSend = true;
                setTimeout(function(){BX.userOptions.send(null)}, BX.userOptions.delay);
            }
        };

        BX.userOptions.send = function(callback)
        {
            var sParam = BX.userOptions.__get();
            BX.userOptions.options = null;
            BX.userOptions.bSend = false;

            if (sParam != '')
            {
                document.cookie = BX.message('COOKIE_PREFIX') + "_LAST_SETTINGS=; path=/;";
                BX.ajax({
                    'method': 'GET',
                    'dataType': 'html',
                    'processData': false,
                    'cache': false,
                    'url': BX.userOptions.path+sParam+'&sessid='+BX.bitrix_sessid(),
                    'onsuccess': callback
                });
            }
        };

        BX.userOptions.del = function(sCategory, sName, bCommon, callback)
        {
            BX.ajax.get(BX.userOptions.path+'action=delete&c='+sCategory+'&n='+sName+(bCommon == true? '&common=Y':'')+'&sessid='+BX.bitrix_sessid(), callback);
        };

        BX.userOptions.__get = function()
        {
            if (!BX.userOptions.options) return '';

            var sParam = '', n = -1, prevParam = '', aOpt, i;

            for (i in BX.userOptions.options)
            {
                if(BX.userOptions.options.hasOwnProperty(i))
                {
                    aOpt = BX.userOptions.options[i];

                    if (prevParam != aOpt[0]+'.'+aOpt[1])
                    {
                        n++;
                        sParam += '&p['+n+'][c]='+BX.util.urlencode(aOpt[0]);
                        sParam += '&p['+n+'][n]='+BX.util.urlencode(aOpt[1]);
                        if (aOpt[4] == true)
                            sParam += '&p['+n+'][d]=Y';
                        prevParam = aOpt[0]+'.'+aOpt[1];
                    }

                    var valueName = aOpt[2];
                    var value = aOpt[3];

                    if (valueName === null)
                    {
                        sParam += '&p['+n+'][v]='+BX.util.urlencode(value);
                    }
                    else
                    {
                        sParam += '&p['+n+'][v]['+BX.util.urlencode(valueName)+']='+BX.util.urlencode(value);
                    }
                }
            }

            return sParam.substr(1);
        };

        BX.ajax.history = {
            expected_hash: '',

            obParams: null,

            obFrame: null,
            obImage: null,

            obTimer: null,

            bInited: false,
            bHashCollision: false,
            bPushState: !!(history.pushState && BX.type.isFunction(history.pushState)),

            startState: null,

            init: function(obParams)
            {
                if (BX.ajax.history.bInited)
                    return;

                this.obParams = obParams;
                var obCurrentState = this.obParams.getState();

                if (BX.ajax.history.bPushState)
                {
                    BX.ajax.history.expected_hash = window.location.pathname;
                    if (window.location.search)
                        BX.ajax.history.expected_hash += window.location.search;

                    BX.ajax.history.put(obCurrentState, BX.ajax.history.expected_hash, '', true);
                    // due to some strange thing, chrome calls popstate event on page start. so we should delay it
                    setTimeout(function(){BX.bind(window, 'popstate', BX.ajax.history.__hashListener);}, 500);
                }
                else
                {
                    BX.ajax.history.expected_hash = window.location.hash;

                    if (!BX.ajax.history.expected_hash || BX.ajax.history.expected_hash == '#')
                        BX.ajax.history.expected_hash = '__bx_no_hash__';

                    jsAjaxHistoryContainer.put(BX.ajax.history.expected_hash, obCurrentState);
                    BX.ajax.history.obTimer = setTimeout(BX.ajax.history.__hashListener, 500);

                    if (BX.browser.IsIE())
                    {
                        BX.ajax.history.obFrame = document.createElement('IFRAME');
                        BX.hide_object(BX.ajax.history.obFrame);

                        document.body.appendChild(BX.ajax.history.obFrame);

                        BX.ajax.history.obFrame.contentWindow.document.open();
                        BX.ajax.history.obFrame.contentWindow.document.write(BX.ajax.history.expected_hash);
                        BX.ajax.history.obFrame.contentWindow.document.close();
                    }
                    else if (BX.browser.IsOpera())
                    {
                        BX.ajax.history.obImage = document.createElement('IMG');
                        BX.hide_object(BX.ajax.history.obImage);

                        document.body.appendChild(BX.ajax.history.obImage);

                        BX.ajax.history.obImage.setAttribute('src', 'javascript:location.href = \'javascript:BX.ajax.history.__hashListener();\';');
                    }
                }

                BX.ajax.history.bInited = true;
            },

            __hashListener: function(e)
            {
                e = e || window.event || {state:false};

                if (BX.ajax.history.bPushState)
                {
                    BX.ajax.history.obParams.setState(e.state||BX.ajax.history.startState);
                }
                else
                {
                    if (BX.ajax.history.obTimer)
                    {
                        window.clearTimeout(BX.ajax.history.obTimer);
                        BX.ajax.history.obTimer = null;
                    }

                    var current_hash;
                    if (null != BX.ajax.history.obFrame)
                        current_hash = BX.ajax.history.obFrame.contentWindow.document.body.innerText;
                    else
                        current_hash = window.location.hash;

                    if (!current_hash || current_hash == '#')
                        current_hash = '__bx_no_hash__';

                    if (current_hash.indexOf('#') == 0)
                        current_hash = current_hash.substring(1);

                    if (current_hash != BX.ajax.history.expected_hash)
                    {
                        var state = jsAjaxHistoryContainer.get(current_hash);
                        if (state)
                        {
                            BX.ajax.history.obParams.setState(state);

                            BX.ajax.history.expected_hash = current_hash;
                            if (null != BX.ajax.history.obFrame)
                            {
                                var __hash = current_hash == '__bx_no_hash__' ? '' : current_hash;
                                if (window.location.hash != __hash && window.location.hash != '#' + __hash)
                                    window.location.hash = __hash;
                            }
                        }
                    }

                    BX.ajax.history.obTimer = setTimeout(BX.ajax.history.__hashListener, 500);
                }
            },

            put: function(state, new_hash, new_hash1, bStartState)
            {
                if (this.bPushState)
                {
                    if(!bStartState)
                    {
                        history.pushState(state, '', new_hash);
                    }
                    else
                    {
                        BX.ajax.history.startState = state;
                    }
                }
                else
                {
                    if (typeof new_hash1 != 'undefined')
                        new_hash = new_hash1;
                    else
                        new_hash = 'view' + new_hash;

                    jsAjaxHistoryContainer.put(new_hash, state);
                    BX.ajax.history.expected_hash = new_hash;

                    window.location.hash = BX.util.urlencode(new_hash);

                    if (null != BX.ajax.history.obFrame)
                    {
                        BX.ajax.history.obFrame.contentWindow.document.open();
                        BX.ajax.history.obFrame.contentWindow.document.write(new_hash);
                        BX.ajax.history.obFrame.contentWindow.document.close();
                    }
                }
            },

            checkRedirectStart: function(param_name, param_value)
            {
                var current_hash = window.location.hash;
                if (current_hash.substring(0, 1) == '#') current_hash = current_hash.substring(1);

                var test = current_hash.substring(0, 5);
                if (test == 'view/' || test == 'view%')
                {
                    BX.ajax.history.bHashCollision = true;
                    document.write('<' + 'div id="__ajax_hash_collision_' + param_value + '" style="display: none;">');
                }
            },

            checkRedirectFinish: function(param_name, param_value)
            {
                document.write('</div>');

                var current_hash = window.location.hash;
                if (current_hash.substring(0, 1) == '#') current_hash = current_hash.substring(1);

                BX.ready(function ()
                {
                    var test = current_hash.substring(0, 5);
                    if (test == 'view/' || test == 'view%')
                    {
                        var obColNode = BX('__ajax_hash_collision_' + param_value);
                        var obNode = obColNode.firstChild;
                        BX.cleanNode(obNode);
                        obColNode.style.display = 'block';

                        // IE, Opera and Chrome automatically modifies hash with urlencode, but FF doesn't ;-(
                        if (test != 'view%')
                            current_hash = BX.util.urlencode(current_hash);

                        current_hash += (current_hash.indexOf('%3F') == -1 ? '%3F' : '%26') + param_name + '=' + param_value;

                        var url = 'index.html?hash=' + current_hash;

                        BX.ajax.insertToNode(url, obNode);
                    }
                });
            }
        };

        BX.ajax.component = function(node)
        {
            this.node = node;
        };

        BX.ajax.component.prototype.getState = function()
        {
            var state = {
                'node': this.node,
                'title': window.document.title,
                'data': BX(this.node).innerHTML
            };

            var obNavChain = BX('navigation');
            if (null != obNavChain)
                state.nav_chain = obNavChain.innerHTML;

            BX.onCustomEvent(BX(state.node), "onComponentAjaxHistoryGetState", [state]);

            return state;
        };

        BX.ajax.component.prototype.setState = function(state)
        {
            BX(state.node).innerHTML = state.data;
            BX.ajax.UpdatePageTitle(state.title);

            if (state.nav_chain)
            {
                BX.ajax.UpdatePageNavChain(state.nav_chain);
            }

            BX.onCustomEvent(BX(state.node), "onComponentAjaxHistorySetState", [state]);
        };

        var jsAjaxHistoryContainer = {
            arHistory: {},

            put: function(hash, state)
            {
                this.arHistory[hash] = state;
            },

            get: function(hash)
            {
                return this.arHistory[hash];
            }
        };


        BX.ajax.FormData = function()
        {
            this.elements = [];
            this.files = [];
            this.features = {};
            this.isSupported();
            this.log('BX FormData init');
        };

        BX.ajax.FormData.isSupported = function()
        {
            var f = new BX.ajax.FormData();
            var result = f.features.supported;
            f = null;
            return result;
        };

        BX.ajax.FormData.prototype.log = function(o)
        {
            if (false) {
                try {
                    if (BX.browser.IsIE()) o = JSON.stringify(o);
                    console.log(o);
                } catch(e) {}
            }
        };

        BX.ajax.FormData.prototype.isSupported = function()
        {
            var f = {};
            f.fileReader = (window.FileReader && window.FileReader.prototype.readAsBinaryString);
            f.readFormData = f.sendFormData = !!(window.FormData);
            f.supported = !!(f.readFormData && f.sendFormData);
            this.features = f;
            this.log('features:');
            this.log(f);

            return f.supported;
        };

        BX.ajax.FormData.prototype.append = function(name, value)
        {
            if (typeof(value) === 'object') { // seems to be files element
                this.files.push({'name': name, 'value':value});
            } else {
                this.elements.push({'name': name, 'value':value});
            }
        };

        BX.ajax.FormData.prototype.send = function(url, callbackOk, callbackProgress, callbackError)
        {
            this.log('FD send');
            this.xhr = BX.ajax({
                'method': 'POST',
                'dataType': 'html',
                'url': url,
                'onsuccess': callbackOk,
                'onfailure': callbackError,
                'start': false,
                'preparePost':false
            });

            if (callbackProgress)
            {
                this.xhr.upload.addEventListener(
                    'progress',
                    function(e) {
                        if (e.lengthComputable)
                            callbackProgress(e.loaded / (e.total || e.totalSize));
                    },
                    false
                );
            }

            if (this.features.readFormData && this.features.sendFormData)
            {
                var fd = new FormData();
                this.log('use browser formdata');
                for (var i in this.elements)
                {
                    if(this.elements.hasOwnProperty(i))
                        fd.append(this.elements[i].name,this.elements[i].value);
                }
                for (i in this.files)
                {
                    if(this.files.hasOwnProperty(i))
                        fd.append(this.files[i].name, this.files[i].value);
                }
                this.xhr.send(fd);
            }

            return this.xhr;
        };

        BX.addCustomEvent('onAjaxFailure', BX.debug);
    })(window);



    (function (exports,main_core) {
        'use strict';

        var LazyLoad = {
            observer: null,
            images: {},
            imageStatus: {
                hidden: -2,
                error: -1,
                "undefined": 0,
                inited: 1,
                loaded: 2
            },
            imageTypes: {
                image: 1,
                background: 2
            },
            initObserver: function initObserver() {
                this.observer = new IntersectionObserver(this.onIntersection.bind(this), {
                    rootMargin: '20% 0% 20% 0%',
                    threshold: 0.10
                });
            },
            onIntersection: function onIntersection(entries) {
                entries.forEach(function (entry) {
                    if (entry.isIntersecting) {
                        this.showImage(entry.target);
                    }
                }.bind(this));
            },
            registerImage: function registerImage(id, isImageVisibleCallback, options) {
                if (this.observer === null) {
                    this.initObserver();
                }

                options = options || {};

                if (!main_core.Type.isStringFilled(id)) {
                    return;
                }

                if (main_core.Type.isObject(this.images[id])) {
                    return;
                }

                var element = document.getElementById(id);

                if (!main_core.Type.isDomNode(element)) {
                    return;
                }

                this.observer.observe(element);
                this.images[id] = {
                    id: id,
                    node: null,
                    src: null,
                    dataSrcName: options.dataSrcName || 'src',
                    type: null,
                    func: main_core.Type.isFunction(isImageVisibleCallback) ? isImageVisibleCallback : null,
                    status: this.imageStatus.undefined
                };
            },
            registerImages: function registerImages(ids, isImageVisibleCallback, options) {
                if (main_core.Type.isArray(ids)) {
                    for (var i = 0, length = ids.length; i < length; i++) {
                        this.registerImage(ids[i], isImageVisibleCallback, options);
                    }
                }
            },
            showImage: function showImage(imageNode) {
                var imageNodeId = imageNode.id;

                if (!main_core.Type.isStringFilled(imageNodeId)) {
                    return;
                }

                var image = this.images[imageNodeId];

                if (!main_core.Type.isPlainObject(image)) {
                    return;
                }

                if (image.status == this.imageStatus.undefined) {
                    this.initImage(image);
                }

                if (image.status !== this.imageStatus.inited) {
                    return;
                }

                if (!image.node || !image.node.parentNode) {
                    image.node = null;
                    image.status = this.imageStatus.error;
                    return;
                }

                if (image.type == this.imageTypes.image) {
                    image.node.src = image.src;
                } else {
                    image.node.style.backgroundImage = "url('" + image.src + "')";
                }

                image.node.dataset[image.dataSrcName] = "";
                image.status = this.imageStatus.loaded;
            },
            showImages: function showImages(checkOwnVisibility) {
                checkOwnVisibility = checkOwnVisibility !== false;

                for (var id in this.images) {
                    if (!this.images.hasOwnProperty(id)) {
                        continue;
                    }

                    var image = this.images[id];

                    if (image.status == this.imageStatus.undefined) {
                        this.initImage(image);
                    }

                    if (image.status !== this.imageStatus.inited) {
                        continue;
                    }

                    if (!image.node || !image.node.parentNode) {
                        image.node = null;
                        image.status = this.imageStatus.error;
                        continue;
                    }

                    var isImageVisible = true;

                    if (checkOwnVisibility && main_core.Type.isFunction(image.func)) {
                        isImageVisible = image.func(image);
                    }

                    if (isImageVisible === true && this.isElementVisibleOnScreen(image.node)) {
                        if (image.type == this.imageTypes.image) {
                            image.node.src = image.src;
                        } else {
                            image.node.style.backgroundImage = "url('" + image.src + "')";
                        }

                        image.node.dataset[image.dataSrcName] = "";
                        image.status = this.imageStatus.loaded;
                    }
                }
            },
            initImage: function initImage(image) {
                image.status = this.imageStatus.error;
                var node = document.getElementById(image.id);

                if (!main_core.Type.isDomNode(node)) {
                    return;
                }

                var src = node.dataset[image.dataSrcName];

                if (main_core.Type.isStringFilled(src)) {
                    image.node = node;
                    image.src = src;
                    image.status = this.imageStatus.inited;
                    image.type = image.node.tagName.toLowerCase() == "img" ? this.imageTypes.image : this.imageTypes.background;
                }
            },
            isElementVisibleOnScreen: function isElementVisibleOnScreen(element) {
                var coords = this.getElementCoords(element);
                var windowTop = window.pageYOffset || document.documentElement.scrollTop;
                var windowBottom = windowTop + document.documentElement.clientHeight;
                coords.bottom = coords.top + element.offsetHeight;
                return coords.top > windowTop && coords.top < windowBottom || // topVisible
                    coords.bottom < windowBottom && coords.bottom > windowTop // bottomVisible
                    ;
            },
            isElementVisibleOn2Screens: function isElementVisibleOn2Screens(element) {
                var windowHeight = document.documentElement.clientHeight;
                var windowTop = window.pageYOffset || document.documentElement.scrollTop;
                var windowBottom = windowTop + windowHeight;
                var coords = this.getElementCoords(element);
                coords.bottom = coords.top + element.offsetHeight;
                windowTop -= windowHeight;
                windowBottom += windowHeight;
                return coords.top > windowTop && coords.top < windowBottom || // topVisible
                    coords.bottom < windowBottom && coords.bottom > windowTop // bottomVisible
                    ;
            },
            getElementCoords: function getElementCoords(element) {
                var box = element.getBoundingClientRect();
                return {
                    originTop: box.top,
                    originLeft: box.left,
                    top: box.top + window.pageYOffset,
                    left: box.left + window.pageXOffset
                };
            },
            onScroll: function onScroll() {},
            clearImages: function clearImages() {
                this.images = [];
            }
        };

        exports.LazyLoad = LazyLoad;

    }((this.BX = this.BX || {}),BX));



    (function (exports) {
        'use strict';

        var ParamBag =
            /*#__PURE__*/
            function () {
                function ParamBag() {
                    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                    babelHelpers.classCallCheck(this, ParamBag);

                    if (!!params && babelHelpers.typeof(params) === 'object') {
                        this.params = new Map(Object.entries(params));
                    } else {
                        this.params = new Map();
                    }
                }

                babelHelpers.createClass(ParamBag, [{
                    key: "getParam",
                    value: function getParam(key) {
                        var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

                        if (this.params.has(key)) {
                            return this.params.get(key);
                        }

                        return defaultValue;
                    }
                }, {
                    key: "setParam",
                    value: function setParam(key, value) {
                        this.params.set(key, value);
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        this.params.clear();
                    }
                }], [{
                    key: "create",
                    value: function create() {
                        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                        return new ParamBag(params);
                    }
                }]);
                return ParamBag;
            }();

        exports.ParamBag = ParamBag;

    }((this.BX = this.BX || {})));



    (function() {
        BX.FixFontSize = function(params)
        {
            var widthNode, computedStyles, width;

            this.node = null;
            this.prevWindowSize = 0;
            this.prevWrapperSize = 0;
            this.mainWrapper = null;
            this.textWrapper = null;
            this.objList = params.objList;
            this.minFontSizeList = [];
            this.minFontSize = 0;

            if (params.onresize)
            {
                this.prevWindowSize = window.innerWidth || document.documentElement.clientWidth;
                BX.bind(window, 'resize', BX.throttle(this.onResize, 350, this));
            }

            if (params.onAdaptiveResize)
            {
                widthNode = this.objList[0].scaleBy || this.objList[0].node;
                computedStyles = getComputedStyle(widthNode);
                this.prevWrapperSize = parseInt(computedStyles["width"]) - parseInt(computedStyles["paddingLeft"]) - parseInt(computedStyles["paddingRight"]);
                BX.bind(window, 'resize', BX.throttle(this.onAdaptiveResize, 350, this));
            }

            this.createTestNodes();
            this.decrease();
        };

        BX.FixFontSize.prototype =
            {
                createTestNodes: function()
                {
                    this.textWrapper = BX.create('div',{
                        style : {
                            display : 'inline-block',
                            whiteSpace : 'nowrap'
                        }
                    });

                    this.mainWrapper = BX.create('div',{
                        style : {
                            height : 0,
                            overflow : 'hidden'
                        },
                        children : [this.textWrapper]
                    });

                },
                insertTestNodes: function()
                {
                    document.body.appendChild(this.mainWrapper);
                },
                removeTestNodes: function()
                {
                    document.body.removeChild(this.mainWrapper);
                },
                decrease: function()
                {
                    var width,
                        fontSize,
                        widthNode,
                        computedStyles;

                    this.insertTestNodes();

                    for(var i=this.objList.length-1; i>=0; i--)
                    {
                        widthNode = this.objList[i].scaleBy || this.objList[i].node;
                        computedStyles = getComputedStyle(widthNode);
                        width  = parseInt(computedStyles["width"]) - parseInt(computedStyles["paddingLeft"]) - parseInt(computedStyles["paddingRight"]);
                        fontSize = parseInt(getComputedStyle(this.objList[i].node)["font-size"]);

                        this.textWrapperSetStyle(this.objList[i].node);

                        if(this.textWrapperInsertText(this.objList[i].node))
                        {
                            while(this.textWrapper.offsetWidth > width && fontSize > 0)
                            {
                                this.textWrapper.style.fontSize = --fontSize + 'px';
                            }

                            if(this.objList[i].smallestValue)
                            {
                                this.minFontSize = this.minFontSize ? Math.min(this.minFontSize, fontSize) : fontSize;

                                this.minFontSizeList.push(this.objList[i].node)
                            }
                            else
                            {
                                this.objList[i].node.style.fontSize = fontSize + 'px';
                            }
                        }
                    }

                    if(this.minFontSizeList.length > 0)
                        this.setMinFont();

                    this.removeTestNodes();

                },
                increase: function()
                {
                    this.insertTestNodes();
                    var width,
                        fontSize,
                        widthNode,
                        computedStyles;

                    this.insertTestNodes();

                    for(var i=this.objList.length-1; i>=0; i--)
                    {
                        widthNode = this.objList[i].scaleBy || this.objList[i].node;
                        computedStyles = getComputedStyle(widthNode);
                        width  = parseInt(computedStyles["width"]) - parseInt(computedStyles["paddingLeft"]) - parseInt(computedStyles["paddingRight"]);
                        fontSize = parseInt(getComputedStyle(this.objList[i].node)["font-size"]);

                        this.textWrapperSetStyle(this.objList[i].node);

                        if(this.textWrapperInsertText(this.objList[i].node))
                        {
                            while(this.textWrapper.offsetWidth < width && fontSize < this.objList[i].maxFontSize)
                            {
                                this.textWrapper.style.fontSize = ++fontSize + 'px';
                            }

                            fontSize--;

                            if(this.objList[i].smallestValue)
                            {
                                this.minFontSize = this.minFontSize ? Math.min(this.minFontSize, fontSize) : fontSize;

                                this.minFontSizeList.push(this.objList[i].node)
                            }
                            else
                            {
                                this.objList[i].node.style.fontSize = fontSize + 'px';
                            }
                        }
                    }

                    if(this.minFontSizeList.length > 0)
                        this.setMinFont();

                    this.removeTestNodes();
                },
                setMinFont : function()
                {
                    for(var i = this.minFontSizeList.length-1; i>=0; i--)
                    {
                        this.minFontSizeList[i].style.fontSize = this.minFontSize + 'px';
                    }

                    this.minFontSize = 0;
                },
                onResize : function()
                {
                    var width = window.innerWidth || document.documentElement.clientWidth;

                    if(this.prevWindowSize > width)
                        this.decrease();

                    else if (this.prevWindowSize < width)
                        this.increase();

                    this.prevWindowSize = width;
                },
                onAdaptiveResize : function()
                {
                    var widthNode = this.objList[0].scaleBy || this.objList[0].node,
                        computedStyles = getComputedStyle(widthNode),
                        width = parseInt(computedStyles["width"]) - parseInt(computedStyles["paddingLeft"]) - parseInt(computedStyles["paddingRight"]);

                    if (this.prevWrapperSize > width)
                        this.decrease();
                    else if (this.prevWrapperSize < width)
                        this.increase();

                    this.prevWrapperSize = width;
                },
                textWrapperInsertText : function(node)
                {
                    if(node.textContent){
                        this.textWrapper.textContent = node.textContent;
                        return true;
                    }
                    else if(node.innerText)
                    {
                        this.textWrapper.innerText = node.innerText;
                        return true;
                    }
                    else {
                        return false;
                    }
                },
                textWrapperSetStyle : function(node)
                {
                    this.textWrapper.style.fontFamily = getComputedStyle(node)["font-family"];
                    this.textWrapper.style.fontSize = getComputedStyle(node)["font-size"];
                    this.textWrapper.style.fontStyle = getComputedStyle(node)["font-style"];
                    this.textWrapper.style.fontWeight = getComputedStyle(node)["font-weight"];
                    this.textWrapper.style.lineHeight = getComputedStyle(node)["line-height"];
                }
            };

        BX.FixFontSize.init = function(params)
        {
            return new BX.FixFontSize(params);
        };
    })();

})();

this.BX = this.BX || {};
(function (exports,main_core_events,main_core) {
    'use strict';

    /**
     * @memberOf BX.Main.Popup
     * @deprecated use BX.UI.Button
     */
    var Button = /*#__PURE__*/function () {
        function Button(params) {
            babelHelpers.classCallCheck(this, Button);
            this.popupWindow = null;
            this.params = params || {};
            this.text = this.params.text || '';
            this.id = this.params.id || '';
            this.className = this.params.className || '';
            this.events = this.params.events || {};
            this.contextEvents = {};

            for (var eventName in this.events) {
                if (main_core.Type.isFunction(this.events[eventName])) {
                    this.contextEvents[eventName] = this.events[eventName].bind(this);
                }
            }

            this.buttonNode = main_core.Dom.create('span', {
                props: {
                    className: 'popup-window-button' + (this.className.length > 0 ? ' ' + this.className : ''),
                    id: this.id
                },
                events: this.contextEvents,
                text: this.text
            });
        }

        babelHelpers.createClass(Button, [{
            key: "render",
            value: function render() {
                return this.buttonNode;
            }
        }, {
            key: "getId",
            value: function getId() {
                return this.id;
            }
        }, {
            key: "getContainer",
            value: function getContainer() {
                return this.buttonNode;
            }
        }, {
            key: "getName",
            value: function getName() {
                return this.text;
            }
        }, {
            key: "setName",
            value: function setName(name) {
                this.text = name || '';

                if (this.buttonNode) {
                    main_core.Dom.clean(this.buttonNode);
                    main_core.Dom.adjust(this.buttonNode, {
                        text: this.text
                    });
                }
            }
        }, {
            key: "setClassName",
            value: function setClassName(className) {
                if (this.buttonNode) {
                    if (main_core.Type.isString(this.className) && this.className !== '') {
                        main_core.Dom.removeClass(this.buttonNode, this.className);
                    }

                    main_core.Dom.addClass(this.buttonNode, className);
                }

                this.className = className;
            }
        }, {
            key: "addClassName",
            value: function addClassName(className) {
                if (this.buttonNode) {
                    main_core.Dom.addClass(this.buttonNode, className);
                    this.className = this.buttonNode.className;
                }
            }
        }, {
            key: "removeClassName",
            value: function removeClassName(className) {
                if (this.buttonNode) {
                    main_core.Dom.removeClass(this.buttonNode, className);
                    this.className = this.buttonNode.className;
                }
            }
        }]);
        return Button;
    }();

    function _templateObject8() {
        var data = babelHelpers.taggedTemplateLiteral(["\n\t\t\t\t\t<div class=\"popup-window-overlay\" id=\"popup-window-overlay-", "\"></div>\n\t\t\t\t"]);

        _templateObject8 = function _templateObject8() {
            return data;
        };

        return data;
    }

    function _templateObject7() {
        var data = babelHelpers.taggedTemplateLiteral(["\n\t\t\t\t\t<div class=\"popup-window-resize\" onmousedown=\"", "\"></div>\n\t\t\t\t"]);

        _templateObject7 = function _templateObject7() {
            return data;
        };

        return data;
    }

    function _templateObject6() {
        var data = babelHelpers.taggedTemplateLiteral(["<div class=\"", " ", "-", "\"></div>"]);

        _templateObject6 = function _templateObject6() {
            return data;
        };

        return data;
    }

    function _templateObject5() {
        var data = babelHelpers.taggedTemplateLiteral(["<div class=\"popup-window-buttons\">", "</div>"]);

        _templateObject5 = function _templateObject5() {
            return data;
        };

        return data;
    }

    function _templateObject4() {
        var data = babelHelpers.taggedTemplateLiteral(["<div \n\t\t\t\tclass=\"", "\" \n\t\t\t\tid=\"", "\"\n\t\t\t\tstyle=\"display: none; position: absolute; left: 0; top: 0; z-index: ", "\"\n\t\t\t>", "</div>"]);

        _templateObject4 = function _templateObject4() {
            return data;
        };

        return data;
    }

    function _templateObject3() {
        var data = babelHelpers.taggedTemplateLiteral(["<div id=\"popup-window-content-", "\" class=\"popup-window-content\"></div>"]);

        _templateObject3 = function _templateObject3() {
            return data;
        };

        return data;
    }

    function _templateObject2() {
        var data = babelHelpers.taggedTemplateLiteral(["\n\t\t\t\t<span class=\"", "\" onclick=\"", "\"></span>\n\t\t\t"]);

        _templateObject2 = function _templateObject2() {
            return data;
        };

        return data;
    }

    function _templateObject() {
        var data = babelHelpers.taggedTemplateLiteral(["\n\t\t\t\t<div class=\"popup-window-titlebar\" id=\"popup-window-titlebar-", "\"></div>\n\t\t\t"]);

        _templateObject = function _templateObject() {
            return data;
        };

        return data;
    }
    var aliases = {
        onPopupWindowInit: {
            namespace: 'BX.Main.Popup',
            eventName: 'onInit'
        },
        onPopupWindowIsInitialized: {
            namespace: 'BX.Main.Popup',
            eventName: 'onAfterInit'
        },
        onPopupFirstShow: {
            namespace: 'BX.Main.Popup',
            eventName: 'onFirstShow'
        },
        onPopupShow: {
            namespace: 'BX.Main.Popup',
            eventName: 'onShow'
        },
        onAfterPopupShow: {
            namespace: 'BX.Main.Popup',
            eventName: 'onAfterShow'
        },
        onPopupClose: {
            namespace: 'BX.Main.Popup',
            eventName: 'onClose'
        },
        onPopupAfterClose: {
            namespace: 'BX.Main.Popup',
            eventName: 'onAfterClose'
        },
        onPopupDestroy: {
            namespace: 'BX.Main.Popup',
            eventName: 'onDestroy'
        },
        onPopupFullscreenLeave: {
            namespace: 'BX.Main.Popup',
            eventName: 'onFullscreenLeave'
        },
        onPopupFullscreenEnter: {
            namespace: 'BX.Main.Popup',
            eventName: 'onFullscreenEnter'
        },
        onPopupDragStart: {
            namespace: 'BX.Main.Popup',
            eventName: 'onDragStart'
        },
        onPopupDrag: {
            namespace: 'BX.Main.Popup',
            eventName: 'onDrag'
        },
        onPopupDragEnd: {
            namespace: 'BX.Main.Popup',
            eventName: 'onDragEnd'
        },
        onPopupResizeStart: {
            namespace: 'BX.Main.Popup',
            eventName: 'onResizeStart'
        },
        onPopupResize: {
            namespace: 'BX.Main.Popup',
            eventName: 'onResize'
        },
        onPopupResizeEnd: {
            namespace: 'BX.Main.Popup',
            eventName: 'onResizeEnd'
        }
    };
    main_core_events.EventEmitter.registerAliases(aliases);
    /**
     * @memberof BX.Main
     */

    var Popup = /*#__PURE__*/function (_EventEmitter) {
        babelHelpers.inherits(Popup, _EventEmitter);
        babelHelpers.createClass(Popup, null, [{
            key: "setOptions",

            /**
             * @private
             */

            /**
             * @private
             */
            value: function setOptions(options) {
                if (!main_core.Type.isPlainObject(options)) {
                    return;
                }

                for (var option in options) {
                    this.options[option] = options[option];
                }
            }
        }, {
            key: "getOption",
            value: function getOption(option, defaultValue) {
                if (!main_core.Type.isUndefined(this.options[option])) {
                    return this.options[option];
                } else if (!main_core.Type.isUndefined(defaultValue)) {
                    return defaultValue;
                } else {
                    return this.defaultOptions[option];
                }
            }
        }]);

        function Popup(options) {
            var _this;

            babelHelpers.classCallCheck(this, Popup);
            _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(Popup).call(this));

            _this.setEventNamespace('BX.Main.Popup');

            var _arguments = Array.prototype.slice.call(arguments),
                popupId = _arguments[0],
                bindElement = _arguments[1],
                params = _arguments[2]; //compatible arguments


            _this.compatibleMode = params && main_core.Type.isBoolean(params.compatibleMode) ? params.compatibleMode : true;

            if (main_core.Type.isPlainObject(options) && !bindElement && !params) {
                params = options;
                popupId = options.id;
                bindElement = options.bindElement;
                _this.compatibleMode = false;
            }

            params = params || {};
            _this.params = params;

            if (!main_core.Type.isStringFilled(popupId)) {
                popupId = 'popup-window-' + main_core.Text.getRandom().toLowerCase();
            }

            _this.emit('onInit', new main_core_events.BaseEvent({
                compatData: [popupId, bindElement, params]
            }));
            /**
             * @private
             */


            _this.uniquePopupId = popupId;
            _this.params.zIndex = main_core.Type.isNumber(params.zIndex) ? parseInt(params.zIndex) : 0;
            _this.params.zIndexAbsolute = main_core.Type.isNumber(params.zIndexAbsolute) ? parseInt(params.zIndexAbsolute) : 0;
            _this.buttons = params.buttons && main_core.Type.isArray(params.buttons) ? params.buttons : [];
            _this.offsetTop = Popup.getOption('offsetTop');
            _this.offsetLeft = Popup.getOption('offsetLeft');
            _this.firstShow = false;
            _this.bordersWidth = 20;
            _this.bindElementPos = null;
            _this.closeIcon = null;
            _this.resizeIcon = null;
            _this.angle = null;
            _this.overlay = null;
            _this.titleBar = null;
            _this.bindOptions = babelHelpers.typeof(params.bindOptions) === 'object' ? params.bindOptions : {};
            _this.autoHide = params.autoHide === true;
            _this.autoHideHandler = main_core.Type.isFunction(params.autoHideHandler) ? params.autoHideHandler : null;
            _this.handleAutoHide = _this.handleAutoHide.bind(babelHelpers.assertThisInitialized(_this));
            _this.handleOverlayClick = _this.handleOverlayClick.bind(babelHelpers.assertThisInitialized(_this));
            _this.isAutoHideBinded = false;
            _this.closeByEsc = params.closeByEsc === true;
            _this.isCloseByEscBinded = false;
            _this.cacheable = true;
            _this.destroyed = false;
            _this.width = null;
            _this.height = null;
            _this.minWidth = null;
            _this.minHeight = null;
            _this.maxWidth = null;
            _this.maxHeight = null;
            _this.padding = null;
            _this.contentPadding = null;
            _this.background = null;
            _this.contentBackground = null;
            _this.appendContainer = document.body;
            _this.dragOptions = {
                cursor: '',
                callback: function callback() {},
                eventName: ''
            };
            _this.dragged = false;
            _this.dragPageX = 0;
            _this.dragPageY = 0;
            _this.animationShowClassName = null;
            _this.animationCloseClassName = null;
            _this.animationCloseEventType = null;
            _this.handleDocumentMouseMove = _this.handleDocumentMouseMove.bind(babelHelpers.assertThisInitialized(_this));
            _this.handleDocumentMouseUp = _this.handleDocumentMouseUp.bind(babelHelpers.assertThisInitialized(_this));
            _this.handleDocumentKeyUp = _this.handleDocumentKeyUp.bind(babelHelpers.assertThisInitialized(_this));
            _this.handleResizeWindow = _this.handleResizeWindow.bind(babelHelpers.assertThisInitialized(_this));
            _this.handleResize = _this.handleResize.bind(babelHelpers.assertThisInitialized(_this));
            _this.handleMove = _this.handleMove.bind(babelHelpers.assertThisInitialized(_this));
            _this.onTitleMouseDown = _this.onTitleMouseDown.bind(babelHelpers.assertThisInitialized(_this));
            _this.handleFullScreen = _this.handleFullScreen.bind(babelHelpers.assertThisInitialized(_this));

            _this.subscribeFromOptions(params.events);

            var popupClassName = 'popup-window';

            if (params.contentColor && main_core.Type.isStringFilled(params.contentColor)) {
                popupClassName += ' popup-window-content-' + params.contentColor;
            }

            if (params.titleBar) {
                popupClassName += ' popup-window-with-titlebar';
            }

            if (params.className && main_core.Type.isStringFilled(params.className)) {
                popupClassName += ' ' + params.className;
            }

            if (params.darkMode) {
                popupClassName += ' popup-window-dark';
            }

            if (params.titleBar) {
                _this.titleBar = main_core.Tag.render(_templateObject(), popupId);
            }

            if (params.closeIcon) {
                var className = 'popup-window-close-icon' + (params.titleBar ? ' popup-window-titlebar-close-icon' : '');
                _this.closeIcon = main_core.Tag.render(_templateObject2(), className, _this.handleCloseIconClick.bind(babelHelpers.assertThisInitialized(_this)));

                if (main_core.Type.isPlainObject(params.closeIcon)) {
                    main_core.Dom.style(_this.closeIcon, params.closeIcon);
                }
            }
            /**
             * @private
             */


            _this.contentContainer = main_core.Tag.render(_templateObject3(), popupId);
            /**
             * @private
             */

            _this.popupContainer = main_core.Tag.render(_templateObject4(), popupClassName, popupId, _this.getZindex(), [_this.titleBar, _this.contentContainer, _this.closeIcon]);

            _this.appendContainer.appendChild(_this.popupContainer);

            _this.buttonsContainer = null;

            if (params.angle) {
                _this.setAngle(params.angle);
            }

            if (params.overlay) {
                _this.setOverlay(params.overlay);
            }

            _this.setOffset(params);

            _this.setBindElement(bindElement);

            _this.setTitleBar(params.titleBar);

            _this.setContent(params.content);

            _this.setButtons(params.buttons);

            _this.setWidth(params.width);

            _this.setHeight(params.height);

            _this.setMinWidth(params.minWidth);

            _this.setMinHeight(params.minHeight);

            _this.setMaxWidth(params.maxWidth);

            _this.setMaxHeight(params.maxHeight);

            _this.setResizeMode(params.resizable);

            _this.setPadding(params.padding);

            _this.setContentPadding(params.contentPadding);

            _this.setBackground(params.background);

            _this.setContentBackground(params.contentBackground);

            _this.setAnimation(params.animation);

            _this.setCacheable(params.cacheable); // Compatibility


            if (params.contentNoPaddings) {
                _this.setContentPadding(0);
            }

            if (params.noAllPaddings) {
                _this.setPadding(0);

                _this.setContentPadding(0);
            }

            if (params.bindOnResize !== false) {
                main_core.Event.bind(window, 'resize', _this.handleResizeWindow);
            }

            _this.emit('onAfterInit', new main_core_events.BaseEvent({
                compatData: [popupId, babelHelpers.assertThisInitialized(_this)]
            }));

            return _this;
        }
        /**
         * @private
         */


        babelHelpers.createClass(Popup, [{
            key: "subscribeFromOptions",
            value: function subscribeFromOptions(events) {
                babelHelpers.get(babelHelpers.getPrototypeOf(Popup.prototype), "subscribeFromOptions", this).call(this, events, aliases);
            }
        }, {
            key: "getId",
            value: function getId() {
                return this.uniquePopupId;
            }
        }, {
            key: "isCompatibleMode",
            value: function isCompatibleMode() {
                return this.compatibleMode;
            }
        }, {
            key: "setContent",
            value: function setContent(content) {
                if (!this.contentContainer || !content) {
                    return;
                }

                if (main_core.Type.isElementNode(content)) {
                    main_core.Dom.clean(this.contentContainer);
                    var hasParent = main_core.Type.isDomNode(content.parentNode);
                    this.contentContainer.appendChild(content);

                    if (this.isCompatibleMode() || hasParent) {
                        content.style.display = 'block';
                    }
                } else if (main_core.Type.isString(content)) {
                    this.contentContainer.innerHTML = content;
                } else {
                    this.contentContainer.innerHTML = '&nbsp;';
                }
            }
        }, {
            key: "setButtons",
            value: function setButtons(buttons) {
                this.buttons = buttons && main_core.Type.isArray(buttons) ? buttons : [];

                if (this.buttonsContainer) {
                    main_core.Dom.remove(this.buttonsContainer);
                }

                var ButtonClass = main_core.Reflection.getClass('BX.UI.Button');

                if (this.buttons.length > 0 && this.contentContainer) {
                    var newButtons = [];

                    for (var i = 0; i < this.buttons.length; i++) {
                        var button = this.buttons[i];

                        if (button instanceof Button) {
                            button.popupWindow = this;
                            newButtons.push(button.render());
                        } else if (ButtonClass && button instanceof ButtonClass) {
                            button.setContext(this);
                            newButtons.push(button.render());
                        }
                    }

                    this.buttonsContainer = this.contentContainer.parentNode.appendChild(main_core.Tag.render(_templateObject5(), newButtons));
                }
            }
        }, {
            key: "getButtons",
            value: function getButtons() {
                return this.buttons;
            }
        }, {
            key: "getButton",
            value: function getButton(id) {
                for (var i = 0; i < this.buttons.length; i++) {
                    var button = this.buttons[i];

                    if (button.getId() === id) {
                        return button;
                    }
                }

                return null;
            }
        }, {
            key: "setBindElement",
            value: function setBindElement(bindElement) {
                if (bindElement === null) {
                    this.bindElement = null;
                } else if (babelHelpers.typeof(bindElement) === 'object') {
                    if (main_core.Type.isDomNode(bindElement) || main_core.Type.isNumber(bindElement.top) && main_core.Type.isNumber(bindElement.left)) {
                        this.bindElement = bindElement;
                    } else if (main_core.Type.isNumber(bindElement.clientX) && main_core.Type.isNumber(bindElement.clientY)) {
                        this.bindElement = {
                            left: bindElement.pageX,
                            top: bindElement.pageY,
                            bottom: bindElement.pageY
                        };
                    }
                }
            }
            /**
             * @private
             */

        }, {
            key: "getBindElementPos",
            value: function getBindElementPos(bindElement) {
                if (main_core.Type.isDomNode(bindElement)) {
                    return main_core.Dom.getPosition(bindElement);
                } else if (bindElement && babelHelpers.typeof(bindElement) === 'object') {
                    if (!main_core.Type.isNumber(bindElement.bottom)) {
                        bindElement.bottom = bindElement.top;
                    }

                    return bindElement;
                } else {
                    var windowSize = {
                        innerWidth: window.innerWidth,
                        innerHeight: window.innerHeight
                    };
                    var windowScroll = {
                        scrollLeft: window.pageXOffset,
                        scrollTop: window.pageYOffset
                    };
                    var popupWidth = this.getPopupContainer().offsetWidth;
                    var popupHeight = this.getPopupContainer().offsetHeight;
                    this.bindOptions.forceTop = true;
                    return {
                        left: windowSize.innerWidth / 2 - popupWidth / 2 + windowScroll.scrollLeft,
                        top: windowSize.innerHeight / 2 - popupHeight / 2 + windowScroll.scrollTop,
                        bottom: windowSize.innerHeight / 2 - popupHeight / 2 + windowScroll.scrollTop,
                        //for optimisation purposes
                        windowSize: windowSize,
                        windowScroll: windowScroll,
                        popupWidth: popupWidth,
                        popupHeight: popupHeight
                    };
                }
            }
        }, {
            key: "setAngle",
            value: function setAngle(params) {
                if (params === false) {
                    if (this.angle !== null) {
                        main_core.Dom.remove(this.angle.element);
                    }

                    this.angle = null;
                    return;
                }

                var className = 'popup-window-angly';

                if (this.angle === null) {
                    var position = this.bindOptions.position && this.bindOptions.position === 'top' ? 'bottom' : 'top';
                    var angleMinLeft = Popup.getOption(position === 'top' ? 'angleMinTop' : 'angleMinBottom');
                    var defaultOffset = main_core.Type.isNumber(params.offset) ? params.offset : 0;
                    var angleLeftOffset = Popup.getOption('angleLeftOffset', null);

                    if (defaultOffset > 0 && main_core.Type.isNumber(angleLeftOffset)) {
                        defaultOffset += angleLeftOffset - Popup.defaultOptions.angleLeftOffset;
                    }

                    this.angle = {
                        element: main_core.Tag.render(_templateObject6(), className, className, position),
                        position: position,
                        offset: 0,
                        defaultOffset: Math.max(defaultOffset, angleMinLeft) //Math.max(Type.isNumber(params.offset) ? params.offset : 0, angleMinLeft)

                    };
                    this.getPopupContainer().appendChild(this.angle.element);
                }

                if (babelHelpers.typeof(params) === 'object' && params.position && ['top', 'right', 'bottom', 'left', 'hide'].includes(params.position)) {
                    main_core.Dom.removeClass(this.angle.element, className + '-' + this.angle.position);
                    main_core.Dom.addClass(this.angle.element, className + '-' + params.position);
                    this.angle.position = params.position;
                }

                if (babelHelpers.typeof(params) === 'object' && main_core.Type.isNumber(params.offset)) {
                    var offset = params.offset;
                    var minOffset, maxOffset;

                    if (this.angle.position === 'top') {
                        minOffset = Popup.getOption('angleMinTop');
                        maxOffset = this.getPopupContainer().offsetWidth - Popup.getOption('angleMaxTop');
                        maxOffset = maxOffset < minOffset ? Math.max(minOffset, offset) : maxOffset;
                        this.angle.offset = Math.min(Math.max(minOffset, offset), maxOffset);
                        this.angle.element.style.left = this.angle.offset + 'px';
                        this.angle.element.style.marginLeft = 0;
                        this.angle.element.style.removeProperty('top');
                    } else if (this.angle.position === 'bottom') {
                        minOffset = Popup.getOption('angleMinBottom');
                        maxOffset = this.getPopupContainer().offsetWidth - Popup.getOption('angleMaxBottom');
                        maxOffset = maxOffset < minOffset ? Math.max(minOffset, offset) : maxOffset;
                        this.angle.offset = Math.min(Math.max(minOffset, offset), maxOffset);
                        this.angle.element.style.marginLeft = this.angle.offset + 'px';
                        this.angle.element.style.left = 0;
                        this.angle.element.style.removeProperty('top');
                    } else if (this.angle.position === 'right') {
                        minOffset = Popup.getOption('angleMinRight');
                        maxOffset = this.getPopupContainer().offsetHeight - Popup.getOption('angleMaxRight');
                        maxOffset = maxOffset < minOffset ? Math.max(minOffset, offset) : maxOffset;
                        this.angle.offset = Math.min(Math.max(minOffset, offset), maxOffset);
                        this.angle.element.style.top = this.angle.offset + 'px';
                        this.angle.element.style.removeProperty('left');
                        this.angle.element.style.removeProperty('margin-left');
                    } else if (this.angle.position === 'left') {
                        minOffset = Popup.getOption('angleMinLeft');
                        maxOffset = this.getPopupContainer().offsetHeight - Popup.getOption('angleMaxLeft');
                        maxOffset = maxOffset < minOffset ? Math.max(minOffset, offset) : maxOffset;
                        this.angle.offset = Math.min(Math.max(minOffset, offset), maxOffset);
                        this.angle.element.style.top = this.angle.offset + 'px';
                        this.angle.element.style.removeProperty('left');
                        this.angle.element.style.removeProperty('margin-left');
                    }
                }
            }
        }, {
            key: "getWidth",
            value: function getWidth() {
                return this.width;
            }
        }, {
            key: "setWidth",
            value: function setWidth(width) {
                this.setWidthProperty('width', width);
            }
        }, {
            key: "getHeight",
            value: function getHeight() {
                return this.height;
            }
        }, {
            key: "setHeight",
            value: function setHeight(height) {
                this.setHeightProperty('height', height);
            }
        }, {
            key: "getMinWidth",
            value: function getMinWidth() {
                return this.minWidth;
            }
        }, {
            key: "setMinWidth",
            value: function setMinWidth(width) {
                this.setWidthProperty('minWidth', width);
            }
        }, {
            key: "getMinHeight",
            value: function getMinHeight() {
                return this.minHeight;
            }
        }, {
            key: "setMinHeight",
            value: function setMinHeight(height) {
                this.setHeightProperty('minHeight', height);
            }
        }, {
            key: "getMaxWidth",
            value: function getMaxWidth() {
                return this.maxWidth;
            }
        }, {
            key: "setMaxWidth",
            value: function setMaxWidth(width) {
                this.setWidthProperty('maxWidth', width);
            }
        }, {
            key: "getMaxHeight",
            value: function getMaxHeight() {
                return this.maxHeight;
            }
        }, {
            key: "setMaxHeight",
            value: function setMaxHeight(height) {
                this.setHeightProperty('maxHeight', height);
            }
            /**
             * @private
             */

        }, {
            key: "setWidthProperty",
            value: function setWidthProperty(property, width) {
                var props = ['width', 'minWidth', 'maxWidth'];

                if (props.indexOf(property) === -1) {
                    return;
                }

                if (main_core.Type.isNumber(width) && width >= 0) {
                    this[property] = width;
                    this.getResizableContainer().style[property] = width + 'px';
                    this.getContentContainer().style.overflowX = 'auto';
                    this.getPopupContainer().classList.add('popup-window-fixed-width');

                    if (this.getTitleContainer() && main_core.Browser.isIE11()) {
                        this.getTitleContainer().style[property] = width + 'px';
                    }
                } else if (width === null || width === false) {
                    this[property] = null;
                    this.getResizableContainer().style.removeProperty(main_core.Text.toKebabCase(property));
                    var hasOtherProps = props.some(function (prop) {
                        return this.getResizableContainer().style.getPropertyValue(main_core.Text.toKebabCase(prop)) !== '';
                    }, this);

                    if (!hasOtherProps) {
                        this.getContentContainer().style.removeProperty('overflow-x');
                        this.getPopupContainer().classList.remove('popup-window-fixed-width');
                    }

                    if (this.getTitleContainer() && main_core.Browser.isIE11()) {
                        this.getTitleContainer().style.removeProperty(main_core.Text.toKebabCase(property));
                    }
                }
            }
            /**
             * @private
             */

        }, {
            key: "setHeightProperty",
            value: function setHeightProperty(property, height) {
                var props = ['height', 'minHeight', 'maxHeight'];

                if (props.indexOf(property) === -1) {
                    return;
                }

                if (main_core.Type.isNumber(height) && height >= 0) {
                    this[property] = height;
                    this.getResizableContainer().style[property] = height + 'px';
                    this.getContentContainer().style.overflowY = 'auto';
                    this.getPopupContainer().classList.add('popup-window-fixed-height');
                } else if (height === null || height === false) {
                    this[property] = null;
                    this.getResizableContainer().style.removeProperty(main_core.Text.toKebabCase(property));
                    var hasOtherProps = props.some(function (prop) {
                        return this.getResizableContainer().style.getPropertyValue(main_core.Text.toKebabCase(prop)) !== '';
                    }, this);

                    if (!hasOtherProps) {
                        this.getContentContainer().style.removeProperty('overflow-y');
                        this.getPopupContainer().classList.remove('popup-window-fixed-height');
                    }
                }
            }
        }, {
            key: "setPadding",
            value: function setPadding(padding) {
                if (main_core.Type.isNumber(padding) && padding >= 0) {
                    this.padding = padding;
                    this.getPopupContainer().style.padding = padding + 'px';
                } else if (padding === null) {
                    this.padding = null;
                    this.getPopupContainer().style.removeProperty('padding');
                }
            }
        }, {
            key: "getPadding",
            value: function getPadding() {
                return this.padding;
            }
        }, {
            key: "setContentPadding",
            value: function setContentPadding(padding) {
                if (main_core.Type.isNumber(padding) && padding >= 0) {
                    this.contentPadding = padding;
                    this.getContentContainer().style.padding = padding + 'px';
                } else if (padding === null) {
                    this.contentPadding = null;
                    this.getContentContainer().style.removeProperty('padding');
                }
            }
        }, {
            key: "getContentPadding",
            value: function getContentPadding() {
                return this.contentPadding;
            }
        }, {
            key: "setBackground",
            value: function setBackground(background) {
                if (main_core.Type.isStringFilled(background)) {
                    this.background = background;
                    this.getPopupContainer().style.background = background;
                } else if (background === null) {
                    this.background = null;
                    this.getPopupContainer().style.removeProperty('background');
                }
            }
        }, {
            key: "getBackground",
            value: function getBackground() {
                return this.background;
            }
        }, {
            key: "setContentBackground",
            value: function setContentBackground(background) {
                if (main_core.Type.isStringFilled(background)) {
                    this.contentBackground = background;
                    this.getContentContainer().style.background = background;
                } else if (background === null) {
                    this.contentBackground = null;
                    this.getContentContainer().style.removeProperty('background');
                }
            }
        }, {
            key: "getContentBackground",
            value: function getContentBackground() {
                return this.contentBackground;
            }
        }, {
            key: "isDestroyed",
            value: function isDestroyed() {
                return this.destroyed;
            }
        }, {
            key: "setCacheable",
            value: function setCacheable(cacheable) {
                this.cacheable = cacheable !== false;
            }
        }, {
            key: "isCacheable",
            value: function isCacheable() {
                return this.cacheable;
            }
        }, {
            key: "setResizeMode",
            value: function setResizeMode(mode) {
                if (mode === true || main_core.Type.isPlainObject(mode)) {
                    if (!this.resizeIcon) {
                        this.resizeIcon = main_core.Tag.render(_templateObject7(), this.handleResizeMouseDown.bind(this));
                        this.getPopupContainer().appendChild(this.resizeIcon);
                    } //Compatibility


                    this.setMinWidth(mode.minWidth);
                    this.setMinHeight(mode.minHeight);
                } else if (mode === false && this.resizeIcon) {
                    main_core.Dom.remove(this.resizeIcon);
                    this.resizeIcon = null;
                }
            }
        }, {
            key: "getPopupContainer",
            value: function getPopupContainer() {
                return this.popupContainer;
            }
        }, {
            key: "getContentContainer",
            value: function getContentContainer() {
                return this.contentContainer;
            }
        }, {
            key: "getResizableContainer",
            value: function getResizableContainer() {
                return main_core.Browser.isIE11() ? this.getContentContainer() : this.getPopupContainer();
            }
        }, {
            key: "getTitleContainer",
            value: function getTitleContainer() {
                return this.titleBar;
            }
            /**
             * @private
             */

        }, {
            key: "onTitleMouseDown",
            value: function onTitleMouseDown(event) {
                this._startDrag(event, {
                    cursor: 'move',
                    callback: this.handleMove,
                    eventName: 'Drag'
                });
            }
            /**
             * @private
             */

        }, {
            key: "handleResizeMouseDown",
            value: function handleResizeMouseDown(event) {
                this._startDrag(event, {
                    cursor: 'nwse-resize',
                    eventName: 'Resize',
                    callback: this.handleResize
                });

                this.resizeContentPos = main_core.Dom.getPosition(this.getResizableContainer());
                this.resizeContentOffset = this.resizeContentPos.left - main_core.Dom.getPosition(this.getPopupContainer()).left;
            }
            /**
             * @private
             */

        }, {
            key: "handleResize",
            value: function handleResize(offsetX, offsetY, pageX, pageY) {
                var width = pageX - this.resizeContentPos.left;
                var height = pageY - this.resizeContentPos.top;
                var scrollWidth = document.documentElement.scrollWidth;

                if (this.resizeContentPos.left + width + this.resizeContentOffset >= scrollWidth) {
                    width = scrollWidth - this.resizeContentPos.left - this.resizeContentOffset;
                }

                width = Math.max(width, this.getMinWidth());
                height = Math.max(height, this.getMinHeight());

                if (this.getMaxWidth() !== null) {
                    width = Math.min(width, this.getMaxWidth());
                }

                if (this.getMaxHeight() !== null) {
                    height = Math.min(height, this.getMaxHeight());
                }

                this.setWidth(width);
                this.setHeight(height);
            }
        }, {
            key: "isTopAngle",
            value: function isTopAngle() {
                return this.angle !== null && this.angle.position === 'top';
            }
        }, {
            key: "isBottomAngle",
            value: function isBottomAngle() {
                return this.angle !== null && this.angle.position === 'bottom';
            }
        }, {
            key: "isTopOrBottomAngle",
            value: function isTopOrBottomAngle() {
                return this.angle !== null && (this.angle.position === 'top' || this.angle.position === 'bottom');
            }
            /**
             * @private
             */

        }, {
            key: "getAngleHeight",
            value: function getAngleHeight() {
                return this.isTopOrBottomAngle() ? Popup.getOption('angleTopOffset') : 0;
            }
        }, {
            key: "setOffset",
            value: function setOffset(params) {
                if (!main_core.Type.isPlainObject(params)) {
                    return;
                }

                if (main_core.Type.isNumber(params.offsetLeft)) {
                    this.offsetLeft = params.offsetLeft + Popup.getOption('offsetLeft');
                }

                if (main_core.Type.isNumber(params.offsetTop)) {
                    this.offsetTop = params.offsetTop + Popup.getOption('offsetTop');
                }
            }
        }, {
            key: "setTitleBar",
            value: function setTitleBar(params) {
                if (!this.titleBar) {
                    return;
                }

                if (babelHelpers.typeof(params) === 'object' && main_core.Type.isDomNode(params.content)) {
                    this.titleBar.innerHTML = '';
                    this.titleBar.appendChild(params.content);
                } else if (typeof params === 'string') {
                    this.titleBar.innerHTML = '';
                    this.titleBar.appendChild(main_core.Dom.create('span', {
                        props: {
                            className: 'popup-window-titlebar-text'
                        },
                        text: params
                    }));
                }

                if (this.params.draggable) {
                    this.titleBar.style.cursor = 'move';
                    main_core.Event.bind(this.titleBar, 'mousedown', this.onTitleMouseDown);
                }
            }
        }, {
            key: "setClosingByEsc",
            value: function setClosingByEsc(enable) {
                enable = main_core.Type.isBoolean(enable) ? enable : true;

                if (enable) {
                    this.closeByEsc = true;
                    this.bindClosingByEsc();
                } else {
                    this.closeByEsc = false;
                    this.unbindClosingByEsc();
                }
            }
            /**
             * @private
             */

        }, {
            key: "bindClosingByEsc",
            value: function bindClosingByEsc() {
                if (this.closeByEsc && !this.isCloseByEscBinded) {
                    main_core.Event.bind(document, 'keyup', this.handleDocumentKeyUp);
                    this.isCloseByEscBinded = true;
                }
            }
            /**
             * @private
             */

        }, {
            key: "unbindClosingByEsc",
            value: function unbindClosingByEsc() {
                if (this.isCloseByEscBinded) {
                    main_core.Event.unbind(document, 'keyup', this.handleDocumentKeyUp);
                    this.isCloseByEscBinded = false;
                }
            }
        }, {
            key: "setAutoHide",
            value: function setAutoHide(enable) {
                enable = main_core.Type.isBoolean(enable) ? enable : true;

                if (enable) {
                    this.autoHide = true;
                    this.bindAutoHide();
                } else {
                    this.autoHide = false;
                    this.unbindAutoHide();
                }
            }
            /**
             * @private
             */

        }, {
            key: "bindAutoHide",
            value: function bindAutoHide() {
                if (this.autoHide && !this.isAutoHideBinded && this.isShown()) {
                    this.isAutoHideBinded = true;

                    if (this.isCompatibleMode()) {
                        main_core.Event.bind(this.getPopupContainer(), 'click', this.handleContainerClick);
                    }

                    if (this.overlay && this.overlay.element) {
                        main_core.Event.bind(this.overlay.element, 'click', this.handleOverlayClick);
                    } else {
                        if (this.isCompatibleMode()) {
                            main_core.Event.bind(document, 'click', this.handleAutoHide);
                        } else {
                            document.addEventListener('click', this.handleAutoHide, true);
                        }
                    }
                }
            }
            /**
             * @private
             */

        }, {
            key: "unbindAutoHide",
            value: function unbindAutoHide() {
                if (this.isAutoHideBinded) {
                    this.isAutoHideBinded = false;

                    if (this.isCompatibleMode()) {
                        main_core.Event.unbind(this.getPopupContainer(), 'click', this.handleContainerClick);
                    }

                    if (this.overlay && this.overlay.element) {
                        main_core.Event.unbind(this.overlay.element, 'click', this.handleOverlayClick);
                    } else {
                        if (this.isCompatibleMode()) {
                            main_core.Event.unbind(document, 'click', this.handleAutoHide);
                        } else {
                            document.removeEventListener('click', this.handleAutoHide, true);
                        }
                    }
                }
            }
            /**
             * @private
             */

        }, {
            key: "handleAutoHide",
            value: function handleAutoHide(event) {
                if (this.isDestroyed()) {
                    return;
                }

                if (this.autoHideHandler !== null) {
                    if (this.autoHideHandler(event)) {
                        this._tryCloseByEvent(event);
                    }
                } else if (event.target !== this.getPopupContainer() && !this.getPopupContainer().contains(event.target)) {
                    this._tryCloseByEvent(event);
                }
            }
            /**
             * @private
             */

        }, {
            key: "_tryCloseByEvent",
            value: function _tryCloseByEvent(event) {
                var _this2 = this;

                if (this.isCompatibleMode()) {
                    this.tryCloseByEvent(event);
                } else {
                    setTimeout(function () {
                        _this2.tryCloseByEvent(event);
                    }, 0);
                }
            }
            /**
             * @private
             */

        }, {
            key: "tryCloseByEvent",
            value: function tryCloseByEvent(event) {
                if (event.button === 0) {
                    this.close();
                }
            }
            /**
             * @private
             */

        }, {
            key: "handleOverlayClick",
            value: function handleOverlayClick(event) {
                this.tryCloseByEvent(event);
                event.stopPropagation();
            }
        }, {
            key: "setOverlay",
            value: function setOverlay(params) {
                if (this.overlay === null) {
                    this.overlay = {
                        element: main_core.Tag.render(_templateObject8(), this.getId())
                    };
                    this.adjustOverlayZindex();
                    this.resizeOverlay();
                    this.appendContainer.appendChild(this.overlay.element);
                }

                if (params && main_core.Type.isNumber(params.opacity) && params.opacity >= 0 && params.opacity <= 100) {
                    this.overlay.element.style.opacity = parseFloat(params.opacity / 100).toPrecision(3);
                }

                if (params && params.backgroundColor) {
                    this.overlay.element.style.backgroundColor = params.backgroundColor;
                }
            }
        }, {
            key: "removeOverlay",
            value: function removeOverlay() {
                if (this.overlay !== null && this.overlay.element !== null) {
                    main_core.Dom.remove(this.overlay.element);
                }

                if (this.overlayTimeout) {
                    clearInterval(this.overlayTimeout);
                    this.overlayTimeout = null;
                }

                this.overlay = null;
            }
        }, {
            key: "hideOverlay",
            value: function hideOverlay() {
                if (this.overlay !== null && this.overlay.element !== null) {
                    if (this.overlayTimeout) {
                        clearInterval(this.overlayTimeout);
                        this.overlayTimeout = null;
                    }

                    this.overlay.element.style.display = 'none';
                }
            }
        }, {
            key: "showOverlay",
            value: function showOverlay() {
                var _this3 = this;

                if (this.overlay !== null && this.overlay.element !== null) {
                    this.overlay.element.style.display = 'block';
                    var popupHeight = this.getPopupContainer().offsetHeight;
                    this.overlayTimeout = setInterval(function () {
                        if (popupHeight !== _this3.getPopupContainer().offsetHeight) {
                            _this3.resizeOverlay();

                            popupHeight = _this3.getPopupContainer().offsetHeight;
                        }
                    }, 1000);
                }
            }
        }, {
            key: "resizeOverlay",
            value: function resizeOverlay() {
                if (this.overlay !== null && this.overlay.element !== null) {
                    var scrollHeight = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight);
                    this.overlay.element.style.width = document.documentElement.scrollWidth + 'px';
                    this.overlay.element.style.height = scrollHeight + 'px';
                }
            }
        }, {
            key: "getZindex",
            value: function getZindex() {
                if (this.overlay !== null) {
                    return this.params.zIndexAbsolute > 0 ? this.params.zIndexAbsolute : Popup.getOption('popupOverlayZindex') + this.params.zIndex;
                } else {
                    return this.params.zIndexAbsolute > 0 ? this.params.zIndexAbsolute : Popup.getOption('popupZindex') + this.params.zIndex;
                }
            }
            /**
             * @private
             */

        }, {
            key: "adjustOverlayZindex",
            value: function adjustOverlayZindex() {
                if (this.overlay !== null && this.overlay.element !== null) {
                    this.overlay.element.style.zIndex = parseInt(this.getPopupContainer().style.zIndex) - 1;
                }
            }
        }, {
            key: "show",
            value: function show() {
                var _this4 = this;

                if (this.isShown() || this.isDestroyed()) {
                    return;
                }

                if (!this.firstShow) {
                    this.emit('onFirstShow', new main_core_events.BaseEvent({
                        compatData: [this]
                    }));
                    this.firstShow = true;
                }

                this.emit('onShow', new main_core_events.BaseEvent({
                    compatData: [this]
                }));
                this.showOverlay();
                this.getPopupContainer().style.display = 'block';
                this.adjustPosition();
                this.animateOpening(function () {
                    if (_this4.isDestroyed()) {
                        return;
                    }

                    main_core.Dom.removeClass(_this4.getPopupContainer(), _this4.animationShowClassName);

                    _this4.emit('onAfterShow', new main_core_events.BaseEvent({
                        compatData: [_this4]
                    }));
                });
                this.bindClosingByEsc();

                if (this.isCompatibleMode()) {
                    setTimeout(function () {
                        _this4.bindAutoHide();
                    }, 100);
                } else {
                    this.bindAutoHide();
                }
            }
        }, {
            key: "close",
            value: function close() {
                var _this5 = this;

                if (this.isDestroyed() || !this.isShown()) {
                    return;
                }

                this.emit('onClose', new main_core_events.BaseEvent({
                    compatData: [this]
                }));

                if (this.isDestroyed()) {
                    return;
                }

                this.animateClosing(function () {
                    if (_this5.isDestroyed()) {
                        return;
                    }

                    _this5.hideOverlay();

                    _this5.getPopupContainer().style.display = 'none';
                    main_core.Dom.removeClass(_this5.getPopupContainer(), _this5.animationCloseClassName);

                    _this5.unbindClosingByEsc();

                    if (_this5.isCompatibleMode()) {
                        setTimeout(function () {
                            _this5.unbindAutoHide();
                        }, 0);
                    } else {
                        _this5.unbindAutoHide();
                    }

                    _this5.emit('onAfterClose', new main_core_events.BaseEvent({
                        compatData: [_this5]
                    }));

                    if (!_this5.isCacheable()) {
                        _this5.destroy();
                    }
                });
            }
        }, {
            key: "toggle",
            value: function toggle() {
                this.isShown() ? this.close() : this.show();
            }
            /**
             *
             * @private
             */

        }, {
            key: "animateOpening",
            value: function animateOpening(callback) {
                main_core.Dom.removeClass(this.getPopupContainer(), this.animationCloseClassName);

                if (this.animationShowClassName !== null) {
                    main_core.Dom.addClass(this.getPopupContainer(), this.animationShowClassName);

                    if (this.animationCloseEventType !== null) {
                        var eventName = this.animationCloseEventType + 'end';
                        this.getPopupContainer().addEventListener(eventName, function handleTransitionEnd() {
                            this.removeEventListener(eventName, handleTransitionEnd);
                            callback();
                        });
                    } else {
                        callback();
                    }
                } else {
                    callback();
                }
            }
            /**
             * @private
             */

        }, {
            key: "animateClosing",
            value: function animateClosing(callback) {
                main_core.Dom.removeClass(this.getPopupContainer(), this.animationShowClassName);

                if (this.animationCloseClassName !== null) {
                    main_core.Dom.addClass(this.getPopupContainer(), this.animationCloseClassName);

                    if (this.animationCloseEventType !== null) {
                        var eventName = this.animationCloseEventType + 'end';
                        this.getPopupContainer().addEventListener(eventName, function handleTransitionEnd() {
                            this.removeEventListener(eventName, handleTransitionEnd);
                            callback();
                        });
                    } else {
                        callback();
                    }
                } else {
                    callback();
                }
            }
        }, {
            key: "setAnimation",
            value: function setAnimation(options) {
                if (main_core.Type.isPlainObject(options)) {
                    this.animationShowClassName = main_core.Type.isStringFilled(options.showClassName) ? options.showClassName : null;
                    this.animationCloseClassName = main_core.Type.isStringFilled(options.closeClassName) ? options.closeClassName : null;
                    this.animationCloseEventType = options.closeAnimationType === 'animation' || options.closeAnimationType === 'transition' ? options.closeAnimationType : null;
                } else if (main_core.Type.isStringFilled(options)) {
                    var animationName = options;

                    if (animationName === 'fading') {
                        this.animationShowClassName = 'popup-window-show-animation-opacity';
                        this.animationCloseClassName = 'popup-window-close-animation-opacity';
                        this.animationCloseEventType = 'animation';
                    } else if (animationName === 'fading-slide') {
                        this.animationShowClassName = 'popup-window-show-animation-opacity-transform';
                        this.animationCloseClassName = 'popup-window-close-animation-opacity';
                        this.animationCloseEventType = 'animation';
                    } else if (animationName === 'scale') {
                        this.animationShowClassName = 'popup-window-show-animation-scale';
                        this.animationCloseClassName = 'popup-window-close-animation-opacity';
                        this.animationCloseEventType = 'animation';
                    }
                } else if (options === false || options === null) {
                    this.animationShowClassName = null;
                    this.animationCloseClassName = null;
                    this.animationCloseEventType = null;
                }
            }
        }, {
            key: "isShown",
            value: function isShown() {
                return !this.isDestroyed() && this.getPopupContainer().style.display === 'block';
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var _this6 = this;

                if (this.destroyed) {
                    return;
                }

                this.destroyed = true;
                this.emit('onDestroy', new main_core_events.BaseEvent({
                    compatData: [this]
                }));
                this.unbindClosingByEsc();

                if (this.isCompatibleMode()) {
                    setTimeout(function () {
                        _this6.unbindAutoHide();
                    }, 0);
                } else {
                    this.unbindAutoHide();
                }

                main_core.Event.unbindAll(this);
                main_core.Event.unbind(document, 'mousemove', this.handleDocumentMouseMove);
                main_core.Event.unbind(document, 'mouseup', this.handleDocumentMouseUp);
                main_core.Event.unbind(window, 'resize', this.handleResizeWindow);
                main_core.Dom.remove(this.popupContainer);
                this.removeOverlay();
                this.popupContainer = null;
                this.contentContainer = null;
                this.closeIcon = null;
                this.titleBar = null;
                this.buttonsContainer = null;
                this.angle = null;
                this.resizeIcon = null;
            }
        }, {
            key: "adjustPosition",
            value: function adjustPosition(bindOptions) {
                if (bindOptions && babelHelpers.typeof(bindOptions) === 'object') {
                    this.bindOptions = bindOptions;
                }

                var bindElementPos = this.getBindElementPos(this.bindElement);

                if (!this.bindOptions.forceBindPosition && this.bindElementPos !== null && bindElementPos.top === this.bindElementPos.top && bindElementPos.left === this.bindElementPos.left) {
                    return;
                }

                this.bindElementPos = bindElementPos;
                var windowSize = bindElementPos.windowSize ? bindElementPos.windowSize : {
                    innerWidth: window.innerWidth,
                    innerHeight: window.innerHeight
                };
                var windowScroll = bindElementPos.windowScroll ? bindElementPos.windowScroll : {
                    scrollLeft: window.pageXOffset,
                    scrollTop: window.pageYOffset
                };
                var popupWidth = bindElementPos.popupWidth ? bindElementPos.popupWidth : this.popupContainer.offsetWidth;
                var popupHeight = bindElementPos.popupHeight ? bindElementPos.popupHeight : this.popupContainer.offsetHeight;
                var angleTopOffset = Popup.getOption('angleTopOffset');
                var left = this.bindElementPos.left + this.offsetLeft - (this.isTopOrBottomAngle() ? Popup.getOption('angleLeftOffset') : 0);

                if (!this.bindOptions.forceLeft && left + popupWidth + this.bordersWidth >= windowSize.innerWidth + windowScroll.scrollLeft && windowSize.innerWidth + windowScroll.scrollLeft - popupWidth - this.bordersWidth > 0) {
                    var bindLeft = left;
                    left = windowSize.innerWidth + windowScroll.scrollLeft - popupWidth - this.bordersWidth;

                    if (this.isTopOrBottomAngle()) {
                        this.setAngle({
                            offset: bindLeft - left + this.angle.defaultOffset
                        });
                    }
                } else if (this.isTopOrBottomAngle()) {
                    this.setAngle({
                        offset: this.angle.defaultOffset + (left < 0 ? left : 0)
                    });
                }

                if (left < 0) {
                    left = 0;
                }

                var top = 0;

                if (this.bindOptions.position && this.bindOptions.position === 'top') {
                    top = this.bindElementPos.top - popupHeight - this.offsetTop - (this.isBottomAngle() ? angleTopOffset : 0);

                    if (top < 0 || !this.bindOptions.forceTop && top < windowScroll.scrollTop) {
                        top = this.bindElementPos.bottom + this.offsetTop;

                        if (this.angle !== null) {
                            top += angleTopOffset;
                            this.setAngle({
                                position: 'top'
                            });
                        }
                    } else if (this.isTopAngle()) {
                        top = top - angleTopOffset + Popup.getOption('positionTopXOffset');
                        this.setAngle({
                            position: 'bottom'
                        });
                    } else {
                        top += Popup.getOption('positionTopXOffset');
                    }
                } else {
                    top = this.bindElementPos.bottom + this.offsetTop + this.getAngleHeight();

                    if (!this.bindOptions.forceTop && top + popupHeight > windowSize.innerHeight + windowScroll.scrollTop && this.bindElementPos.top - popupHeight - this.getAngleHeight() >= 0) //Can we place the PopupWindow above the bindElement?
                    {
                        //The PopupWindow doesn't place below the bindElement. We should place it above.
                        top = this.bindElementPos.top - popupHeight;

                        if (this.isTopOrBottomAngle()) {
                            top -= angleTopOffset;
                            this.setAngle({
                                position: 'bottom'
                            });
                        }

                        top += Popup.getOption('positionTopXOffset');
                    } else if (this.isBottomAngle()) {
                        top += angleTopOffset;
                        this.setAngle({
                            position: 'top'
                        });
                    }
                }

                if (top < 0) {
                    top = 0;
                }

                main_core.Dom.adjust(this.popupContainer, {
                    style: {
                        top: top + 'px',
                        left: left + 'px',
                        zIndex: this.getZindex()
                    }
                });
                this.adjustOverlayZindex();
            }
        }, {
            key: "enterFullScreen",
            value: function enterFullScreen() {
                if (Popup.fullscreenStatus) {
                    if (document.cancelFullScreen) {
                        document.cancelFullScreen();
                    } else if (document.mozCancelFullScreen) {
                        document.mozCancelFullScreen();
                    } else if (document.webkitCancelFullScreen) {
                        document.webkitCancelFullScreen();
                    }
                } else {
                    if (this.contentContainer.requestFullScreen) {
                        this.contentContainer.requestFullScreen();
                        main_core.Event.bind(window, 'fullscreenchange', this.handleFullScreen);
                    } else if (this.contentContainer.mozRequestFullScreen) {
                        this.contentContainer.mozRequestFullScreen();
                        main_core.Event.bind(window, 'mozfullscreenchange', this.handleFullScreen);
                    } else if (this.contentContainer.webkitRequestFullScreen) {
                        this.contentContainer.webkitRequestFullScreen();
                        main_core.Event.bind(window, 'webkitfullscreenchange', this.handleFullScreen);
                    } else {
                        console.log('fullscreen mode is not supported');
                    }
                }
            }
            /**
             * @private
             */

        }, {
            key: "handleFullScreen",
            value: function handleFullScreen(event) {
                if (Popup.fullscreenStatus) {
                    main_core.Event.unbind(window, 'fullscreenchange', this.handleFullScreen);
                    main_core.Event.unbind(window, 'webkitfullscreenchange', this.handleFullScreen);
                    main_core.Event.unbind(window, 'mozfullscreenchange', this.handleFullScreen);
                    Popup.fullscreenStatus = false;

                    if (!this.isDestroyed()) {
                        main_core.Dom.removeClass(this.contentContainer, 'popup-window-fullscreen');
                        this.emit('onFullscreenLeave');
                        this.adjustPosition();
                    }
                } else {
                    Popup.fullscreenStatus = true;

                    if (!this.isDestroyed()) {
                        main_core.Dom.addClass(this.contentContainer, 'popup-window-fullscreen');
                        this.emit('onFullscreenEnter');
                        this.adjustPosition();
                    }
                }
            }
            /**
             * @private
             */

        }, {
            key: "handleCloseIconClick",
            value: function handleCloseIconClick(event) {
                this.tryCloseByEvent(event);
                event.stopPropagation();
            }
            /**
             * @private
             */

        }, {
            key: "handleContainerClick",
            value: function handleContainerClick(event) {
                event.stopPropagation();
            }
            /**
             * @private
             */

        }, {
            key: "handleDocumentKeyUp",
            value: function handleDocumentKeyUp(event) {
                var _this7 = this;

                if (event.keyCode === 27) {
                    checkEscPressed(this.getZindex(), function () {
                        _this7.close();
                    });
                }
            }
            /**
             * @private
             */

        }, {
            key: "handleResizeWindow",
            value: function handleResizeWindow() {
                if (this.isShown()) {
                    this.adjustPosition();

                    if (this.overlay !== null) {
                        this.resizeOverlay();
                    }
                }
            }
            /**
             * @private
             */

        }, {
            key: "handleMove",
            value: function handleMove(offsetX, offsetY, pageX, pageY) {
                var left = parseInt(this.popupContainer.style.left) + offsetX;
                var top = parseInt(this.popupContainer.style.top) + offsetY;

                if (babelHelpers.typeof(this.params.draggable) === 'object' && this.params.draggable.restrict) {
                    //Left side
                    if (left < 0) {
                        left = 0;
                    } //Right side


                    var scrollWidth = document.documentElement.scrollWidth;
                    var scrollHeight = document.documentElement.scrollHeight;
                    var floatWidth = this.popupContainer.offsetWidth;
                    var floatHeight = this.popupContainer.offsetHeight;

                    if (left > scrollWidth - floatWidth) {
                        left = scrollWidth - floatWidth;
                    }

                    if (top > scrollHeight - floatHeight) {
                        top = scrollHeight - floatHeight;
                    } //Top side


                    if (top < 0) {
                        top = 0;
                    }
                }

                this.popupContainer.style.left = left + 'px';
                this.popupContainer.style.top = top + 'px';
            }
            /**
             * @private
             */

        }, {
            key: "_startDrag",
            value: function _startDrag(event, options) {
                options = options || {};

                if (main_core.Type.isStringFilled(options.cursor)) {
                    this.dragOptions.cursor = options.cursor;
                }

                if (main_core.Type.isStringFilled(options.eventName)) {
                    this.dragOptions.eventName = options.eventName;
                }

                if (main_core.Type.isFunction(options.callback)) {
                    this.dragOptions.callback = options.callback;
                }

                this.dragPageX = event.pageX;
                this.dragPageY = event.pageY;
                this.dragged = false;
                main_core.Event.bind(document, 'mousemove', this.handleDocumentMouseMove);
                main_core.Event.bind(document, 'mouseup', this.handleDocumentMouseUp);

                if (document.body.setCapture) {
                    document.body.setCapture();
                }

                document.body.ondrag = function () {
                    return false;
                };

                document.body.onselectstart = function () {
                    return false;
                };

                document.body.style.cursor = this.dragOptions.cursor;
                document.body.style.MozUserSelect = 'none';
                this.popupContainer.style.MozUserSelect = 'none';
                event.preventDefault();
            }
            /**
             * @private
             */

        }, {
            key: "handleDocumentMouseMove",
            value: function handleDocumentMouseMove(event) {
                if (this.dragPageX === event.pageX && this.dragPageY === event.pageY) {
                    return;
                }

                this.dragOptions.callback(event.pageX - this.dragPageX, event.pageY - this.dragPageY, event.pageX, event.pageY);
                this.dragPageX = event.pageX;
                this.dragPageY = event.pageY;

                if (!this.dragged) {
                    this.emit("on".concat(this.dragOptions.eventName, "Start"), new main_core_events.BaseEvent({
                        compatData: [this]
                    }));
                    this.dragged = true;
                }

                this.emit("on".concat(this.dragOptions.eventName), new main_core_events.BaseEvent({
                    compatData: [this]
                }));
            }
            /**
             * @private
             */

        }, {
            key: "handleDocumentMouseUp",
            value: function handleDocumentMouseUp(event) {
                if (document.body.releaseCapture) {
                    document.body.releaseCapture();
                }

                main_core.Event.unbind(document, 'mousemove', this.handleDocumentMouseMove);
                main_core.Event.unbind(document, 'mouseup', this.handleDocumentMouseUp);
                document.body.ondrag = null;
                document.body.onselectstart = null;
                document.body.style.cursor = '';
                document.body.style.MozUserSelect = '';
                this.popupContainer.style.MozUserSelect = '';
                this.emit("on".concat(this.dragOptions.eventName, "End"), new main_core_events.BaseEvent({
                    compatData: [this]
                }));
                this.dragged = false;
                event.preventDefault();
            }
        }]);
        return Popup;
    }(main_core_events.EventEmitter);

    babelHelpers.defineProperty(Popup, "options", {});
    babelHelpers.defineProperty(Popup, "defaultOptions", {
        //left offset for popup about target
        angleLeftOffset: 40,
        //when popup position is 'top' offset distance between popup body and target node
        positionTopXOffset: -11,
        //offset distance between popup body and target node if use angle, sum with positionTopXOffset
        angleTopOffset: 10,
        popupZindex: 1000,
        popupOverlayZindex: 1100,
        angleMinLeft: 10,
        angleMaxLeft: 30,
        angleMinRight: 10,
        angleMaxRight: 30,
        angleMinBottom: 23,
        angleMaxBottom: 25,
        angleMinTop: 23,
        angleMaxTop: 25,
        offsetLeft: 0,
        offsetTop: 0
    });
    var escCallbackIndex = -1;
    var escCallback = null;

    function checkEscPressed(zIndex, callback) {
        if (zIndex === false) {
            if (escCallback && escCallback.length > 0) {
                for (var i = 0; i < escCallback.length; i++) {
                    escCallback[i]();
                }

                escCallback = null;
                escCallbackIndex = -1;
            }
        } else {
            if (escCallback === null) {
                escCallback = [];
                escCallbackIndex = -1;
                setTimeout(function () {
                    checkEscPressed(false);
                }, 10);
            }

            if (zIndex > escCallbackIndex) {
                escCallbackIndex = zIndex;
                escCallback = [callback];
            } else if (zIndex === escCallbackIndex) {
                escCallback.push(callback);
            }
        }
    }

    var PopupManager = /*#__PURE__*/function () {
        function PopupManager() {
            babelHelpers.classCallCheck(this, PopupManager);
            throw new Error('You cannot make an instance of PopupManager.');
        }

        babelHelpers.createClass(PopupManager, null, [{
            key: "create",
            value: function create(options) {
                var _arguments = Array.prototype.slice.call(arguments),
                    popupId = _arguments[0],
                    bindElement = _arguments[1],
                    params = _arguments[2]; //compatible arguments


                var id = popupId;
                var compatMode = true;

                if (main_core.Type.isPlainObject(popupId) && !bindElement && !params) {
                    compatMode = false;
                    id = popupId.id;

                    if (!main_core.Type.isStringFilled(id)) {
                        throw new Error('BX.Main.Popup.Manager: "id" parameter is required.');
                    }
                }

                var popupWindow = this.getPopupById(id);

                if (popupWindow === null) {
                    popupWindow = compatMode ? new Popup(popupId, bindElement, params) : new Popup(options);
                    popupWindow.subscribe('onShow', this.handlePopupShow);
                    popupWindow.subscribe('onClose', this.handlePopupClose);
                }

                return popupWindow;
            }
            /**
             * @private
             */

        }, {
            key: "handleOnAfterInit",
            value: function handleOnAfterInit(event) {
                event.getTarget().subscribeOnce('onDestroy', this.handlePopupDestroy);

                this._popups.forEach(function (popup) {
                    if (popup.getId() === event.getTarget().getId()) {
                        console.error("Duplicate id (".concat(popup.getId(), ") for the BX.Main.Popup instance."));
                    }
                });

                this._popups.push(event.getTarget());
            }
            /**
             * @private
             */

        }, {
            key: "handlePopupDestroy",
            value: function handlePopupDestroy(event) {
                this._popups = this._popups.filter(function (popup) {
                    return popup !== event.getTarget();
                });
            }
            /**
             * @private
             */

        }, {
            key: "handlePopupShow",
            value: function handlePopupShow(event) {
                if (this._currentPopup !== null) {
                    this._currentPopup.close();
                }

                this._currentPopup = event.getTarget();
            }
            /**
             * @private
             */

        }, {
            key: "handlePopupClose",
            value: function handlePopupClose() {
                this._currentPopup = null;
            }
        }, {
            key: "getCurrentPopup",
            value: function getCurrentPopup() {
                return this._currentPopup;
            }
        }, {
            key: "isPopupExists",
            value: function isPopupExists(id) {
                return this.getPopupById(id) !== null;
            }
        }, {
            key: "isAnyPopupShown",
            value: function isAnyPopupShown() {
                for (var i = 0, length = this._popups.length; i < length; i++) {
                    if (this._popups[i].isShown()) {
                        return true;
                    }
                }

                return false;
            }
        }, {
            key: "getPopupById",
            value: function getPopupById(id) {
                for (var i = 0; i < this._popups.length; i++) {
                    if (this._popups[i].getId() === id) {
                        return this._popups[i];
                    }
                }

                return null;
            }
        }, {
            key: "getMaxZIndex",
            value: function getMaxZIndex() {
                var zIndex = 0;

                for (var i = 0; i < this._popups.length; i++) {
                    zIndex = Math.max(zIndex, this._popups[i].params.zIndex);
                }

                return zIndex;
            }
        }]);
        return PopupManager;
    }();

    babelHelpers.defineProperty(PopupManager, "_popups", []);
    babelHelpers.defineProperty(PopupManager, "_currentPopup", null);
    PopupManager.handlePopupDestroy = PopupManager.handlePopupDestroy.bind(PopupManager);
    PopupManager.handlePopupShow = PopupManager.handlePopupShow.bind(PopupManager);
    PopupManager.handlePopupClose = PopupManager.handlePopupClose.bind(PopupManager);
    PopupManager.handleOnAfterInit = PopupManager.handleOnAfterInit.bind(PopupManager);
    main_core_events.EventEmitter.subscribe('BX.Main.Popup:onAfterInit', PopupManager.handleOnAfterInit);

    function _templateObject$1() {
        var data = babelHelpers.taggedTemplateLiteral(["<span class=\"popup-window-delimiter\">"]);

        _templateObject$1 = function _templateObject() {
            return data;
        };

        return data;
    }
    var aliases$1 = {
        onSubMenuShow: {
            namespace: 'BX.Main.Menu.Item',
            eventName: 'SubMenu:onShow'
        },
        onSubMenuClose: {
            namespace: 'BX.Main.Menu.Item',
            eventName: 'SubMenu:onClose'
        }
    };
    main_core_events.EventEmitter.registerAliases(aliases$1);

    var MenuItem = /*#__PURE__*/function (_EventEmitter) {
        babelHelpers.inherits(MenuItem, _EventEmitter);

        function MenuItem(options) {
            var _this;

            babelHelpers.classCallCheck(this, MenuItem);
            _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(MenuItem).call(this));

            _this.setEventNamespace('BX.Main.Menu.Item');

            options = options || {};
            _this.options = options;
            _this.id = options.id || main_core.Text.getRandom();
            _this.text = main_core.Type.isStringFilled(options.text) ? options.text : '';
            _this.title = main_core.Type.isStringFilled(options.title) ? options.title : '';
            _this.delimiter = options.delimiter === true;
            _this.href = main_core.Type.isStringFilled(options.href) ? options.href : null;
            _this.target = main_core.Type.isStringFilled(options.target) ? options.target : null;
            _this.dataset = main_core.Type.isPlainObject(options.dataset) ? options.dataset : null;
            _this.className = main_core.Type.isStringFilled(options.className) ? options.className : null;
            _this.menuShowDelay = main_core.Type.isNumber(options.menuShowDelay) ? options.menuShowDelay : 300;
            _this.subMenuOffsetX = main_core.Type.isNumber(options.subMenuOffsetX) ? options.subMenuOffsetX : 4;
            _this._items = main_core.Type.isArray(options.items) ? options.items : [];
            _this.disabled = options.disabled === true;
            _this.cacheable = options.cacheable === true;
            /**
             *
             * @type {function|string}
             */

            _this.onclick = main_core.Type.isStringFilled(options.onclick) || main_core.Type.isFunction(options.onclick) ? options.onclick : null;

            _this.subscribeFromOptions(options.events, aliases$1);
            /**
             *
             * @type {Menu}
             */


            _this.menuWindow = null;
            /**
             *
             * @type {Menu}
             */

            _this.subMenuWindow = null;
            /**
             *
             * @type {{item: Element, text: Element}}
             */

            _this.layout = {
                item: null,
                text: null
            };

            _this.getLayout(); //compatibility
            //compatibility
            //now use this.options


            _this.events = {};
            _this.items = [];

            for (var property in options) {
                if (options.hasOwnProperty(property) && typeof _this[property] === 'undefined') {
                    _this[property] = options[property];
                }
            }

            return _this;
        }

        babelHelpers.createClass(MenuItem, [{
            key: "getLayout",
            value: function getLayout() {
                if (this.layout.item) {
                    return this.layout;
                }

                if (this.delimiter) {
                    if (main_core.Type.isStringFilled(this.text)) {
                        this.layout.item = main_core.Dom.create('span', {
                            props: {
                                className: 'popup-window-delimiter-section'
                            },
                            children: [this.layout.text = main_core.Dom.create('span', {
                                props: {
                                    className: 'popup-window-delimiter-text'
                                },
                                html: this.text
                            })]
                        });
                    } else {
                        this.layout.item = main_core.Tag.render(_templateObject$1());
                    }
                } else {
                    this.layout.item = main_core.Dom.create(this.href ? 'a' : 'span', {
                        props: {
                            className: ['menu-popup-item', this.className ? this.className : 'menu-popup-no-icon', this.hasSubMenu() ? 'menu-popup-item-submenu' : ''].join(' ')
                        },
                        attrs: {
                            title: this.title,
                            onclick: main_core.Type.isString(this.onclick) ? this.onclick : '',
                            // compatibility
                            target: this.target ? this.target : ''
                        },
                        dataset: this.dataset,
                        events: main_core.Type.isFunction(this.onclick) ? {
                            click: this.onItemClick.bind(this)
                        } : null,
                        children: [main_core.Dom.create('span', {
                            props: {
                                className: 'menu-popup-item-icon'
                            }
                        }), this.layout.text = main_core.Dom.create('span', {
                            props: {
                                className: 'menu-popup-item-text'
                            },
                            html: this.text
                        })]
                    });

                    if (this.href) {
                        this.layout.item.href = this.href;
                    }

                    if (this.isDisabled()) {
                        this.disable();
                    }

                    main_core.Event.bind(this.layout.item, 'mouseenter', this.onItemMouseEnter.bind(this));
                    main_core.Event.bind(this.layout.item, 'mouseleave', this.onItemMouseLeave.bind(this));
                }

                return this.layout;
            }
        }, {
            key: "getContainer",
            value: function getContainer() {
                return this.getLayout().item;
            }
        }, {
            key: "getTextContainer",
            value: function getTextContainer() {
                return this.getLayout().text;
            }
        }, {
            key: "getText",
            value: function getText() {
                return this.text;
            }
        }, {
            key: "setText",
            value: function setText(text) {
                if (main_core.Type.isString(text)) {
                    this.text = text;
                    this.getTextContainer().innerHTML = text;
                }
            }
        }, {
            key: "hasSubMenu",
            value: function hasSubMenu() {
                return this.subMenuWindow !== null || this._items.length;
            }
        }, {
            key: "showSubMenu",
            value: function showSubMenu() {
                this.addSubMenu(this._items);

                if (this.subMenuWindow) {
                    main_core.Dom.addClass(this.layout.item, 'menu-popup-item-open');
                    this.closeSiblings();
                    this.closeChildren();
                    var popupWindow = this.subMenuWindow.getPopupWindow();

                    if (!popupWindow.isShown()) {
                        this.emit('SubMenu:onShow');
                        popupWindow.show();
                    }

                    this.adjustSubMenu();
                }
            }
        }, {
            key: "addSubMenu",
            value: function addSubMenu(items) {
                if (this.subMenuWindow !== null || !main_core.Type.isArray(items) || !items.length) {
                    return;
                }

                var rootMenuWindow = this.getMenuWindow().getRootMenuWindow() || this.getMenuWindow();
                var options = rootMenuWindow.params; //Override root menu options

                options.autoHide = false;
                options.menuShowDelay = this.menuShowDelay;
                options.cacheable = this.isCacheable();
                options.zIndexAbsolute = this.getMenuWindow().getPopupWindow().getZindex() + 2;
                options.bindOptions = {
                    forceTop: true,
                    forceLeft: true,
                    forceBindPosition: true
                };
                delete options.zIndex;
                delete options.events;
                delete options.angle;
                delete options.overlay;
                this.subMenuWindow = new Menu('popup-submenu-' + this.id, this.layout.item, items, options);
                this.subMenuWindow.setParentMenuWindow(this.getMenuWindow());
                this.subMenuWindow.setParentMenuItem(this);
                this.subMenuWindow.getPopupWindow().subscribe('onDestroy', this.handleSubMenuDestroy.bind(this));
                main_core.Dom.addClass(this.layout.item, 'menu-popup-item-submenu');
                return this.subMenuWindow;
            }
        }, {
            key: "closeSubMenu",
            value: function closeSubMenu() {
                this.clearSubMenuTimeout();

                if (this.subMenuWindow) {
                    main_core.Dom.removeClass(this.layout.item, 'menu-popup-item-open');
                    this.closeChildren();
                    var popup = this.subMenuWindow.getPopupWindow();

                    if (popup.isShown()) {
                        this.emit('SubMenu:onClose');
                    }

                    this.subMenuWindow.close();
                }
            }
        }, {
            key: "closeSiblings",
            value: function closeSiblings() {
                var siblings = this.menuWindow.getMenuItems();

                for (var i = 0; i < siblings.length; i++) {
                    if (siblings[i] !== this) {
                        siblings[i].closeSubMenu();
                    }
                }
            }
        }, {
            key: "closeChildren",
            value: function closeChildren() {
                if (this.subMenuWindow) {
                    var children = this.subMenuWindow.getMenuItems();

                    for (var i = 0; i < children.length; i++) {
                        children[i].closeSubMenu();
                    }
                }
            }
        }, {
            key: "destroySubMenu",
            value: function destroySubMenu() {
                if (this.subMenuWindow) {
                    main_core.Dom.removeClass(this.layout.item, 'menu-popup-item-open menu-popup-item-submenu');
                    this.destroyChildren();
                    this.subMenuWindow.destroy();
                    this.subMenuWindow = null;
                    this._items = [];
                }
            }
        }, {
            key: "destroyChildren",
            value: function destroyChildren() {
                if (this.subMenuWindow) {
                    var children = this.subMenuWindow.getMenuItems();

                    for (var i = 0; i < children.length; i++) {
                        children[i].destroySubMenu();
                    }
                }
            }
        }, {
            key: "adjustSubMenu",
            value: function adjustSubMenu() {
                if (!this.subMenuWindow || !this.layout.item) {
                    return;
                }

                var popupWindow = this.subMenuWindow.getPopupWindow();
                var itemRect = this.layout.item.getBoundingClientRect();
                var offsetLeft = itemRect.width + this.subMenuOffsetX;
                var offsetTop = itemRect.height + this.getPopupPadding();
                var angleOffset = itemRect.height / 2 - this.getPopupPadding();
                var anglePosition = 'left';
                var popupWidth = popupWindow.getPopupContainer().offsetWidth;
                var popupHeight = popupWindow.getPopupContainer().offsetHeight;
                var popupBottom = itemRect.top + popupHeight;
                var clientWidth = document.documentElement.clientWidth;
                var clientHeight = document.documentElement.clientHeight; // let's try to fit a submenu to the browser viewport

                var exceeded = popupBottom - clientHeight;

                if (exceeded > 0) {
                    var roundOffset = Math.ceil(exceeded / itemRect.height) * itemRect.height;

                    if (roundOffset > itemRect.top) {
                        // it cannot be higher than the browser viewport.
                        roundOffset -= Math.ceil((roundOffset - itemRect.top) / itemRect.height) * itemRect.height;
                    }

                    if (itemRect.bottom > popupBottom - roundOffset) {
                        // let's sync bottom boundaries.
                        roundOffset -= itemRect.bottom - (popupBottom - roundOffset) + this.getPopupPadding();
                    }

                    offsetTop += roundOffset;
                    angleOffset += roundOffset;
                }

                if (itemRect.left + offsetLeft + popupWidth > clientWidth) {
                    var left = itemRect.left - popupWidth - this.subMenuOffsetX;

                    if (left > 0) {
                        offsetLeft = -popupWidth - this.subMenuOffsetX;
                        anglePosition = 'right';
                    }
                }

                popupWindow.setBindElement(this.layout.item);
                popupWindow.setOffset({
                    offsetLeft: offsetLeft,
                    offsetTop: -offsetTop
                });
                popupWindow.setAngle({
                    position: anglePosition,
                    offset: angleOffset
                });
                popupWindow.adjustPosition();
            }
        }, {
            key: "getPopupPadding",
            value: function getPopupPadding() {
                if (!main_core.Type.isNumber(this.popupPadding)) {
                    if (this.subMenuWindow) {
                        var menuContainer = this.subMenuWindow.layout.menuContainer;
                        this.popupPadding = parseInt(main_core.Dom.style(menuContainer, 'paddingTop'), 10);
                    } else {
                        this.popupPadding = 0;
                    }
                }

                return this.popupPadding;
            }
        }, {
            key: "getSubMenu",
            value: function getSubMenu() {
                return this.subMenuWindow;
            }
        }, {
            key: "getId",
            value: function getId() {
                return this.id;
            }
        }, {
            key: "setMenuWindow",
            value: function setMenuWindow(menu) {
                this.menuWindow = menu;
            }
        }, {
            key: "getMenuWindow",
            value: function getMenuWindow() {
                return this.menuWindow;
            }
        }, {
            key: "getMenuShowDelay",
            value: function getMenuShowDelay() {
                return this.menuShowDelay;
            }
        }, {
            key: "enable",
            value: function enable() {
                this.disabled = false;
                this.getContainer().classList.remove('menu-popup-item-disabled');
            }
        }, {
            key: "disable",
            value: function disable() {
                this.disabled = true;
                this.closeSubMenu();
                this.getContainer().classList.add('menu-popup-item-disabled');
            }
        }, {
            key: "isDisabled",
            value: function isDisabled() {
                return this.disabled;
            }
        }, {
            key: "setCacheable",
            value: function setCacheable(cacheable) {
                this.cacheable = cacheable !== false;
            }
        }, {
            key: "isCacheable",
            value: function isCacheable() {
                return this.cacheable;
            }
            /**
             * @private
             */

        }, {
            key: "onItemClick",
            value: function onItemClick(event) {
                this.onclick.call(this.menuWindow, event, this); //compatibility
            }
            /**
             * @private
             */

        }, {
            key: "onItemMouseEnter",
            value: function onItemMouseEnter(event) {
                if (this.isDisabled()) {
                    return;
                }

                main_core_events.EventEmitter.emit(this, 'onMouseEnter', undefined, {
                    thisArg: this
                });
                this.clearSubMenuTimeout();

                if (this.hasSubMenu()) {
                    this.subMenuTimeout = setTimeout(function () {
                        this.showSubMenu();
                    }.bind(this), this.menuShowDelay);
                } else {
                    this.subMenuTimeout = setTimeout(function () {
                        this.closeSiblings();
                    }.bind(this), this.menuShowDelay);
                }
            }
            /**
             * @private
             */

        }, {
            key: "onItemMouseLeave",
            value: function onItemMouseLeave(event) {
                if (this.isDisabled()) {
                    return;
                }

                main_core_events.EventEmitter.emit(this, 'onMouseLeave', undefined, {
                    thisArg: this
                });
                this.clearSubMenuTimeout();
            }
            /**
             * @private
             */

        }, {
            key: "clearSubMenuTimeout",
            value: function clearSubMenuTimeout() {
                if (this.subMenuTimeout) {
                    clearTimeout(this.subMenuTimeout);
                }

                this.subMenuTimeout = null;
            }
            /**
             * @private
             */

        }, {
            key: "handleSubMenuDestroy",
            value: function handleSubMenuDestroy() {
                this.subMenuWindow = null;
            }
        }]);
        return MenuItem;
    }(main_core_events.EventEmitter);

    function _templateObject2$1() {
        var data = babelHelpers.taggedTemplateLiteral(["\n\t\t\t<div class=\"menu-popup\">", "</div>\n\t\t"]);

        _templateObject2$1 = function _templateObject2() {
            return data;
        };

        return data;
    }

    function _templateObject$2() {
        var data = babelHelpers.taggedTemplateLiteral(["\n\t\t\t<div class=\"menu-popup-items\">", "</div>\n\t\t"]);

        _templateObject$2 = function _templateObject() {
            return data;
        };

        return data;
    }

    /**
     * @memberof BX.Main
     */
    var Menu = /*#__PURE__*/function () {
        function Menu(options) {
            babelHelpers.classCallCheck(this, Menu);

            var _arguments = Array.prototype.slice.call(arguments),
                id = _arguments[0],
                bindElement = _arguments[1],
                menuItems = _arguments[2],
                params = _arguments[3];

            if (main_core.Type.isPlainObject(options) && !bindElement && !menuItems && !params) {
                params = options;
                params.compatibleMode = false;
                id = options.id;
                bindElement = options.bindElement;
                menuItems = options.items;

                if (!main_core.Type.isStringFilled(id)) {
                    id = 'menu-popup-' + main_core.Text.getRandom();
                }
            }

            this.id = id;
            this.bindElement = bindElement;
            /**
             *
             * @type {MenuItem[]}
             */

            this.menuItems = [];
            this.itemsContainer = null;
            this.params = params && babelHelpers.typeof(params) === 'object' ? params : {};
            this.parentMenuWindow = null;
            this.parentMenuItem = null;

            if (menuItems && main_core.Type.isArray(menuItems)) {
                for (var i = 0; i < menuItems.length; i++) {
                    this.addMenuItemInternal(menuItems[i], null);
                }
            }

            this.layout = {
                menuContainer: null,
                itemsContainer: null
            };
            this.popupWindow = this.__createPopup();
        }
        /**
         * @private
         */


        babelHelpers.createClass(Menu, [{
            key: "__createPopup",
            value: function __createPopup() {
                var domItems = [];

                for (var i = 0; i < this.menuItems.length; i++) {
                    var item = this.menuItems[i];
                    var itemLayout = item.getLayout();
                    domItems.push(itemLayout.item);
                }

                var defaults = {
                    closeByEsc: false,
                    angle: false,
                    autoHide: true,
                    offsetTop: 1,
                    offsetLeft: 0,
                    animation: 'fading'
                };
                var options = Object.assign(defaults, this.params); //Override user params

                options.noAllPaddings = true;
                options.darkMode = false;
                options.autoHideHandler = this.handleAutoHide.bind(this);
                this.layout.itemsContainer = main_core.Tag.render(_templateObject$2(), domItems);
                this.layout.menuContainer = main_core.Tag.render(_templateObject2$1(), this.layout.itemsContainer);
                this.itemsContainer = this.layout.itemsContainer;
                options.content = this.layout.menuContainer; //Make internal event handlers first in the queue.

                options.events = {
                    onClose: this.handlePopupClose.bind(this),
                    onDestroy: this.handlePopupDestroy.bind(this)
                };
                var id = options.compatibleMode === false ? this.getId() : 'menu-popup-' + this.getId();
                var popup = new Popup(id, this.bindElement, options);

                if (this.params && this.params.events) {
                    popup.subscribeFromOptions(this.params.events);
                }

                return popup;
            }
        }, {
            key: "getPopupWindow",
            value: function getPopupWindow() {
                return this.popupWindow;
            }
        }, {
            key: "show",
            value: function show() {
                this.getPopupWindow().show();
            }
        }, {
            key: "close",
            value: function close() {
                this.getPopupWindow().close();
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.getPopupWindow().destroy();
            }
        }, {
            key: "toggle",
            value: function toggle() {
                if (this.getPopupWindow().isShown()) {
                    this.close();
                } else {
                    this.show();
                }
            }
        }, {
            key: "getId",
            value: function getId() {
                return this.id;
            }
            /**
             * @private
             */

        }, {
            key: "handlePopupClose",
            value: function handlePopupClose() {
                for (var i = 0; i < this.menuItems.length; i++) {
                    var item = this.menuItems[i];
                    item.closeSubMenu();
                }
            }
            /**
             * @private
             */

        }, {
            key: "handlePopupDestroy",
            value: function handlePopupDestroy() {
                for (var i = 0; i < this.menuItems.length; i++) {
                    var item = this.menuItems[i];
                    item.destroySubMenu();
                }
            }
            /**
             * @private
             */

        }, {
            key: "handleAutoHide",
            value: function handleAutoHide(event) {
                return !this.containsTarget(event.target);
            }
            /**
             * @private
             */

        }, {
            key: "containsTarget",
            value: function containsTarget(target) {
                var el = this.getPopupWindow().getPopupContainer();

                if (this.getPopupWindow().isShown() && (target === el || el.contains(target))) {
                    return true;
                }

                return this.getMenuItems().some(function (item) {
                    return item.getSubMenu() && item.getSubMenu().containsTarget(target);
                });
            }
        }, {
            key: "setParentMenuWindow",
            value: function setParentMenuWindow(parentMenu) {
                if (parentMenu instanceof Menu) {
                    this.parentMenuWindow = parentMenu;
                }
            }
        }, {
            key: "getParentMenuWindow",
            value: function getParentMenuWindow() {
                return this.parentMenuWindow;
            }
        }, {
            key: "getRootMenuWindow",
            value: function getRootMenuWindow() {
                var root = null;
                var parent = this.getParentMenuWindow();

                while (parent !== null) {
                    root = parent;
                    parent = parent.getParentMenuWindow();
                }

                return root;
            }
        }, {
            key: "setParentMenuItem",
            value: function setParentMenuItem(parentItem) {
                if (parentItem instanceof MenuItem) {
                    this.parentMenuItem = parentItem;
                }
            }
        }, {
            key: "getParentMenuItem",
            value: function getParentMenuItem() {
                return this.parentMenuItem;
            }
        }, {
            key: "addMenuItem",
            value: function addMenuItem(menuItemJson, targetItemId) {
                var menuItem = this.addMenuItemInternal(menuItemJson, targetItemId);

                if (!menuItem) {
                    return null;
                }

                var itemLayout = menuItem.getLayout();
                var targetItem = this.getMenuItem(targetItemId);

                if (targetItem !== null) {
                    var targetLayout = targetItem.getLayout();
                    this.itemsContainer.insertBefore(itemLayout.item, targetLayout.item);
                } else {
                    this.itemsContainer.appendChild(itemLayout.item);
                }

                return menuItem;
            }
            /**
             * @private
             */

        }, {
            key: "addMenuItemInternal",
            value: function addMenuItemInternal(menuItemJson, targetItemId) {
                if (!menuItemJson || !menuItemJson.delimiter && !main_core.Type.isStringFilled(menuItemJson.text) || menuItemJson.id && this.getMenuItem(menuItemJson.id) !== null) {
                    return null;
                }

                if (main_core.Type.isNumber(this.params.menuShowDelay)) {
                    menuItemJson.menuShowDelay = this.params.menuShowDelay;
                }

                var menuItem = new MenuItem(menuItemJson);
                menuItem.setMenuWindow(this);
                var position = this.getMenuItemPosition(targetItemId);

                if (position >= 0) {
                    this.menuItems.splice(position, 0, menuItem);
                } else {
                    this.menuItems.push(menuItem);
                }

                return menuItem;
            }
        }, {
            key: "removeMenuItem",
            value: function removeMenuItem(itemId) {
                var item = this.getMenuItem(itemId);

                if (!item) {
                    return;
                }

                for (var position = 0; position < this.menuItems.length; position++) {
                    if (this.menuItems[position] === item) {
                        item.destroySubMenu();
                        this.menuItems.splice(position, 1);
                        break;
                    }
                }

                if (!this.menuItems.length) {
                    var menuWindow = item.getMenuWindow();

                    if (menuWindow) {
                        var parentMenuItem = menuWindow.getParentMenuItem();

                        if (parentMenuItem) {
                            parentMenuItem.destroySubMenu();
                        } else {
                            menuWindow.destroy();
                        }
                    }
                }

                item.layout.item.parentNode.removeChild(item.layout.item);
                item.layout = {
                    item: null,
                    text: null
                };
            }
        }, {
            key: "getMenuItem",
            value: function getMenuItem(itemId) {
                for (var i = 0; i < this.menuItems.length; i++) {
                    if (this.menuItems[i].id && this.menuItems[i].id === itemId) {
                        return this.menuItems[i];
                    }
                }

                return null;
            }
        }, {
            key: "getMenuItems",
            value: function getMenuItems() {
                return this.menuItems;
            }
        }, {
            key: "getMenuItemPosition",
            value: function getMenuItemPosition(itemId) {
                if (itemId) {
                    for (var i = 0; i < this.menuItems.length; i++) {
                        if (this.menuItems[i].id && this.menuItems[i].id === itemId) {
                            return i;
                        }
                    }
                }

                return -1;
            }
        }, {
            key: "getMenuContainer",
            value: function getMenuContainer() {
                return this.getPopupWindow().getPopupContainer();
            }
        }]);
        return Menu;
    }();

    var MenuManager = /*#__PURE__*/function () {
        /**
         * @private
         */

        /**
         * @private
         */
        function MenuManager() {
            babelHelpers.classCallCheck(this, MenuManager);
            throw new Error('You cannot make an instance of MenuManager.');
        }

        babelHelpers.createClass(MenuManager, null, [{
            key: "show",
            value: function show() {
                if (this.currentItem !== null) {
                    this.currentItem.popupWindow.close();
                }

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }

                this.currentItem = this.create.apply(this, args);
                this.currentItem.popupWindow.show();
            }
        }, {
            key: "create",
            value: function create(options) {
                var menuId = null; //Compatibility

                var bindElement = arguments[1];
                var menuItems = arguments[2];
                var params = arguments[3];

                if (main_core.Type.isPlainObject(options) && !bindElement && !menuItems && !params) {
                    menuId = options.id;

                    if (!main_core.Type.isStringFilled(menuId)) {
                        throw new Error('BX.Main.Menu.create: "id" parameter is required.');
                    }
                } else {
                    menuId = options;
                }

                if (!this.Data[menuId]) {
                    var menu = new Menu(options, bindElement, menuItems, params);
                    menu.getPopupWindow().subscribe('onDestroy', function () {
                        MenuManager.destroy(menuId);
                    });
                    this.Data[menuId] = menu;
                }

                return this.Data[menuId];
            }
        }, {
            key: "getCurrentMenu",
            value: function getCurrentMenu() {
                return this.currentItem;
            }
        }, {
            key: "getMenuById",
            value: function getMenuById(id) {
                return this.Data[id] ? this.Data[id] : null;
            }
            /**
             * compatibility
             * @private
             */

        }, {
            key: "onPopupDestroy",
            value: function onPopupDestroy(popupMenuWindow) {
                this.destroy(popupMenuWindow.id);
            }
        }, {
            key: "destroy",
            value: function destroy(id) {
                var menu = this.getMenuById(id);

                if (menu) {
                    if (this.currentItem === menu) {
                        this.currentItem = null;
                    }

                    delete this.Data[id];
                    menu.getPopupWindow().destroy();
                }
            }
        }]);
        return MenuManager;
    }();

    babelHelpers.defineProperty(MenuManager, "Data", {});
    babelHelpers.defineProperty(MenuManager, "currentItem", null);

    /**
     * @deprecated use Popup class instead: import { Popup } from 'main.popup'
     */

    var PopupWindow = /*#__PURE__*/function (_Popup) {
        babelHelpers.inherits(PopupWindow, _Popup);

        function PopupWindow() {
            babelHelpers.classCallCheck(this, PopupWindow);
            return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(PopupWindow).apply(this, arguments));
        }

        return PopupWindow;
    }(Popup);

    /**
     * @deprecated use BX.UI.Button
     */

    var PopupWindowButton = /*#__PURE__*/function (_Button) {
        babelHelpers.inherits(PopupWindowButton, _Button);

        function PopupWindowButton() {
            babelHelpers.classCallCheck(this, PopupWindowButton);
            return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(PopupWindowButton).apply(this, arguments));
        }

        return PopupWindowButton;
    }(Button);

    /**
     * @deprecated use BX.UI.Button
     */

    var ButtonLink = /*#__PURE__*/function (_Button) {
        babelHelpers.inherits(ButtonLink, _Button);

        function ButtonLink(params) {
            var _this;

            babelHelpers.classCallCheck(this, ButtonLink);
            _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(ButtonLink).call(this, params));
            _this.buttonNode = main_core.Dom.create('span', {
                props: {
                    className: 'popup-window-button popup-window-button-link' + (_this.className.length > 0 ? ' ' + _this.className : ''),
                    id: _this.id
                },
                text: _this.text,
                events: _this.contextEvents
            });
            return _this;
        }

        return ButtonLink;
    }(Button);

    /**
     * @deprecated use BX.UI.Button
     */

    var PopupWindowButtonLink = /*#__PURE__*/function (_ButtonLink) {
        babelHelpers.inherits(PopupWindowButtonLink, _ButtonLink);

        function PopupWindowButtonLink() {
            babelHelpers.classCallCheck(this, PopupWindowButtonLink);
            return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(PopupWindowButtonLink).apply(this, arguments));
        }

        return PopupWindowButtonLink;
    }(ButtonLink);

    /**
     * @deprecated use BX.UI.Button
     */

    var CustomButton = /*#__PURE__*/function (_Button) {
        babelHelpers.inherits(CustomButton, _Button);

        function CustomButton(params) {
            var _this;

            babelHelpers.classCallCheck(this, CustomButton);
            _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(CustomButton).call(this, params));
            _this.buttonNode = main_core.Dom.create('span', {
                props: {
                    className: _this.className.length > 0 ? _this.className : '',
                    id: _this.id
                },
                events: _this.contextEvents,
                text: _this.text
            });
            return _this;
        }

        return CustomButton;
    }(Button);

    /**
     * @deprecated use BX.UI.Button
     */

    var PopupWindowCustomButton = /*#__PURE__*/function (_CustomButton) {
        babelHelpers.inherits(PopupWindowCustomButton, _CustomButton);

        function PopupWindowCustomButton() {
            babelHelpers.classCallCheck(this, PopupWindowCustomButton);
            return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(PopupWindowCustomButton).apply(this, arguments));
        }

        return PopupWindowCustomButton;
    }(CustomButton);

    /**
     * @deprecated use Menu class instead: import { Menu } from 'main.popup'
     */

    var PopupMenuWindow = /*#__PURE__*/function (_Menu) {
        babelHelpers.inherits(PopupMenuWindow, _Menu);

        function PopupMenuWindow() {
            babelHelpers.classCallCheck(this, PopupMenuWindow);
            return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(PopupMenuWindow).apply(this, arguments));
        }

        return PopupMenuWindow;
    }(Menu);

    /**
     * @deprecated use Menu.Item class instead: import { MenuItem } from 'main.popup'
     */

    var PopupMenuItem = /*#__PURE__*/function (_MenuItem) {
        babelHelpers.inherits(PopupMenuItem, _MenuItem);

        function PopupMenuItem() {
            babelHelpers.classCallCheck(this, PopupMenuItem);
            return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(PopupMenuItem).apply(this, arguments));
        }

        return PopupMenuItem;
    }(MenuItem);

    /**
     * @deprecated
     */

    var InputPopup = /*#__PURE__*/function () {
        function InputPopup(params) {
            babelHelpers.classCallCheck(this, InputPopup);
            this.id = params.id || 'bx-inp-popup-' + Math.round(Math.random() * 1000000);
            this.handler = params.handler || false;
            this.values = params.values || false;
            this.pInput = params.input;
            this.bValues = !!this.values;
            this.defaultValue = params.defaultValue || '';
            this.openTitle = params.openTitle || '';
            this.className = params.className || '';
            this.noMRclassName = params.noMRclassName || 'ec-no-rm';
            this.emptyClassName = params.noMRclassName || 'ec-label';

            var _this = this;

            this.curInd = false;

            if (this.bValues) {
                this.pInput.onfocus = this.pInput.onclick = function (e) {
                    if (this.value == _this.defaultValue) {
                        this.value = '';
                        this.className = _this.className;
                    }

                    _this.ShowPopup();

                    return e.preventDefault();
                };

                this.pInput.onblur = function () {
                    if (_this.bShowed) {
                        setTimeout(function () {
                            _this.ClosePopup(true);
                        }, 200);
                    }

                    _this.OnChange();
                };
            } else {
                this.pInput.className = this.noMRclassName;
                this.pInput.onblur = this.OnChange.bind(this);
            }
        }

        babelHelpers.createClass(InputPopup, [{
            key: "ShowPopup",
            value: function ShowPopup() {
                if (this.bShowed) {
                    return;
                }

                var _this = this;

                if (!this.oPopup) {
                    var pWnd = main_core.Dom.create('DIV', {
                        props: {
                            className: 'bxecpl-loc-popup ' + this.className
                        }
                    });

                    for (var i = 0, l = this.values.length; i < l; i++) {
                        var pRow = pWnd.appendChild(main_core.Dom.create('DIV', {
                            props: {
                                id: 'bxecmr_' + i
                            },
                            text: this.values[i].NAME,
                            events: {
                                mouseover: function mouseover() {
                                    main_core.Dom.addClass(this, 'bxecplloc-over');
                                },
                                mouseout: function mouseout() {
                                    main_core.Dom.removeClass(this, 'bxecplloc-over');
                                },
                                click: function click() {
                                    var ind = this.id.substr('bxecmr_'.length);
                                    _this.pInput.value = _this.values[ind].NAME;
                                    _this.curInd = ind;

                                    _this.OnChange();

                                    _this.ClosePopup(true);
                                }
                            }
                        }));

                        if (this.values[i].DESCRIPTION) {
                            pRow.title = this.values[i].DESCRIPTION;
                        }

                        if (this.values[i].CLASS_NAME) {
                            main_core.Dom.addClass(pRow, this.values[i].CLASS_NAME);
                        }

                        if (this.values[i].URL) {
                            pRow.appendChild(main_core.Dom.create('a', {
                                props: {
                                    href: this.values[i].URL,
                                    className: 'bxecplloc-view',
                                    target: '_blank',
                                    title: this.openTitle
                                }
                            }));
                        }
                    }

                    this.oPopup = new Popup(this.id, this.pInput, {
                        autoHide: true,
                        offsetTop: 1,
                        offsetLeft: 0,
                        lightShadow: true,
                        closeByEsc: true,
                        content: pWnd,
                        events: {
                            onClose: this.ClosePopup.bind(this)
                        }
                    });
                }

                this.oPopup.show();
                this.pInput.select();
                this.bShowed = true;
                main_core_events.EventEmitter.emit(this, 'onInputPopupShow', new main_core_events.BaseEvent({
                    compatData: [this]
                }));
            }
        }, {
            key: "ClosePopup",
            value: function ClosePopup(bClosePopup) {
                this.bShowed = false;

                if (this.pInput.value === '') {
                    this.OnChange();
                }

                main_core_events.EventEmitter.emit(this, 'onInputPopupClose', new main_core_events.BaseEvent({
                    compatData: [this]
                }));

                if (bClosePopup === true) {
                    this.oPopup.close();
                }
            }
        }, {
            key: "OnChange",
            value: function OnChange() {
                var val = this.pInput.value;

                if (this.bValues) {
                    if (this.pInput.value == '' || this.pInput.value == this.defaultValue) {
                        this.pInput.value = this.defaultValue;
                        this.pInput.className = this.emptyClassName;
                        val = '';
                    } else {
                        this.pInput.className = '';
                    }
                }

                if (isNaN(parseInt(this.curInd)) || this.curInd !== false && val != this.values[this.curInd].NAME) {
                    this.curInd = false;
                } else {
                    this.curInd = parseInt(this.curInd);
                }

                main_core_events.EventEmitter.emit(this, 'onInputPopupChanged', new main_core_events.BaseEvent({
                    compatData: [this, this.curInd, val]
                }));

                if (this.handler && typeof this.handler == 'function') {
                    this.handler({
                        ind: this.curInd,
                        value: val
                    });
                }
            }
        }, {
            key: "Set",
            value: function Set(ind, val, bOnChange) {
                this.curInd = ind;

                if (this.curInd !== false) {
                    this.pInput.value = this.values[this.curInd].NAME;
                } else {
                    this.pInput.value = val;
                }

                if (bOnChange !== false) {
                    this.OnChange();
                }
            }
        }, {
            key: "Get",
            value: function Get(ind) {
                var id = false;

                if (typeof ind == 'undefined') {
                    ind = this.curInd;
                }

                if (ind !== false && this.values[ind]) {
                    id = this.values[ind].ID;
                }

                return id;
            }
        }, {
            key: "GetIndex",
            value: function GetIndex(id) {
                for (var i = 0, l = this.values.length; i < l; i++) {
                    if (this.values[i].ID == id) {
                        return i;
                    }
                }

                return false;
            }
        }, {
            key: "Deactivate",
            value: function Deactivate(bDeactivate) {
                if (this.pInput.value == '' || this.pInput.value == this.defaultValue) {
                    if (bDeactivate) {
                        this.pInput.value = '';
                        this.pInput.className = this.noMRclassName;
                    } else if (this.oEC.bUseMR) {
                        this.pInput.value = this.defaultValue;
                        this.pInput.className = this.emptyClassName;
                    }
                }

                this.pInput.disabled = bDeactivate;
            }
        }]);
        return InputPopup;
    }();

    /*

	//ES6
	import { Popup, PopupManager } from 'main.popup';
	const popup = new Popup();
	PopupManager.create();

	//ES5
	var popup = new BX.Main.Popup();
	BX.Main.PopupManager.create();

	//ES6
	import { Menu, MenuItem, MenuManager } from 'main.popup';
	const menu = new Menu();
	const item = new MenuItem();
	MenuManager.create();

	//ES5
	var menu = new BX.Main.Menu();
	var item = new BX.Main.MenuItem();
	BX.Main.MenuManager.create();

	 */
    var BX = main_core.Reflection.namespace('BX');
    /** @deprecated use BX.Main.Popup or import { Popup } from 'main.popup' */

    BX.PopupWindow = Popup;
    /** @deprecated use BX.Main.PopupManager or import { PopupManager } from 'main.popup' */

    BX.PopupWindowManager = PopupManager;
    /** @deprecated use BX.Main.Menu or import { Menu } from 'main.popup' */

    BX.PopupMenuWindow = Menu;
    /** @deprecated use BX.Main.MenuManager or import { MenuManager } from 'main.popup' */

    BX.PopupMenu = MenuManager;
    /** @deprecated use BX.Main.MenuItem or import { MenuItem } from 'main.popup' */

    BX.PopupMenuItem = MenuItem;
    /** @deprecated use BX.UI.Button */

    BX.PopupWindowButton = Button;
    /** @deprecated use BX.UI.Button */

    BX.PopupWindowButtonLink = ButtonLink;
    /** @deprecated use BX.UI.Button */

    BX.PopupWindowCustomButton = CustomButton;
    /** @deprecated use another API */

    window.BXInputPopup = InputPopup;

    exports.Popup = Popup;
    exports.Menu = Menu;
    exports.MenuItem = MenuItem;
    exports.PopupManager = PopupManager;
    exports.MenuManager = MenuManager;
    exports.PopupWindow = PopupWindow;
    exports.PopupMenuWindow = PopupMenuWindow;
    exports.PopupMenuItem = PopupMenuItem;
    exports.PopupWindowManager = PopupManager;
    exports.PopupMenu = MenuManager;
    exports.PopupWindowButton = PopupWindowButton;
    exports.PopupWindowButtonLink = PopupWindowButtonLink;
    exports.PopupWindowCustomButton = PopupWindowCustomButton;

}((this.BX.Main = this.BX.Main || {}),BX.Event,BX));

/*! jCarousel - v0.3.1 - 2014-04-26
* http://sorgalla.com/jcarousel
* Copyright (c) 2014 Jan Sorgalla; Licensed MIT */
(function(t){"use strict";var i=t.jCarousel={};i.version="0.3.1";var s=/^([+\-]=)?(.+)$/;i.parseTarget=function(t){var i=!1,e="object"!=typeof t?s.exec(t):null;return e?(t=parseInt(e[2],10)||0,e[1]&&(i=!0,"-="===e[1]&&(t*=-1))):"object"!=typeof t&&(t=parseInt(t,10)||0),{target:t,relative:i}},i.detectCarousel=function(t){for(var i;t.length>0;){if(i=t.filter("[data-jcarousel]"),i.length>0)return i;if(i=t.find("[data-jcarousel]"),i.length>0)return i;t=t.parent()}return null},i.base=function(s){return{version:i.version,_options:{},_element:null,_carousel:null,_init:t.noop,_create:t.noop,_destroy:t.noop,_reload:t.noop,create:function(){return this._element.attr("data-"+s.toLowerCase(),!0).data(s,this),!1===this._trigger("create")?this:(this._create(),this._trigger("createend"),this)},destroy:function(){return!1===this._trigger("destroy")?this:(this._destroy(),this._trigger("destroyend"),this._element.removeData(s).removeAttr("data-"+s.toLowerCase()),this)},reload:function(t){return!1===this._trigger("reload")?this:(t&&this.options(t),this._reload(),this._trigger("reloadend"),this)},element:function(){return this._element},options:function(i,s){if(0===arguments.length)return t.extend({},this._options);if("string"==typeof i){if(s===void 0)return this._options[i]===void 0?null:this._options[i];this._options[i]=s}else this._options=t.extend({},this._options,i);return this},carousel:function(){return this._carousel||(this._carousel=i.detectCarousel(this.options("carousel")||this._element),this._carousel||t.error('Could not detect carousel for plugin "'+s+'"')),this._carousel},_trigger:function(i,e,r){var n,o=!1;return r=[this].concat(r||[]),(e||this._element).each(function(){n=t.Event((s+":"+i).toLowerCase()),t(this).trigger(n,r),n.isDefaultPrevented()&&(o=!0)}),!o}}},i.plugin=function(s,e){var r=t[s]=function(i,s){this._element=t(i),this.options(s),this._init(),this.create()};return r.fn=r.prototype=t.extend({},i.base(s),e),t.fn[s]=function(i){var e=Array.prototype.slice.call(arguments,1),n=this;return"string"==typeof i?this.each(function(){var r=t(this).data(s);if(!r)return t.error("Cannot call methods on "+s+" prior to initialization; "+'attempted to call method "'+i+'"');if(!t.isFunction(r[i])||"_"===i.charAt(0))return t.error('No such method "'+i+'" for '+s+" instance");var o=r[i].apply(r,e);return o!==r&&o!==void 0?(n=o,!1):void 0}):this.each(function(){var e=t(this).data(s);e instanceof r?e.reload(i):new r(this,i)}),n},r}})(jQuery),function(t,i){"use strict";var s=function(t){return parseFloat(t)||0};t.jCarousel.plugin("jcarousel",{animating:!1,tail:0,inTail:!1,resizeTimer:null,lt:null,vertical:!1,rtl:!1,circular:!1,underflow:!1,relative:!1,_options:{list:function(){return this.element().children().eq(0)},items:function(){return this.list().children()},animation:400,transitions:!1,wrap:null,vertical:null,rtl:null,center:!1},_list:null,_items:null,_target:null,_first:null,_last:null,_visible:null,_fullyvisible:null,_init:function(){var t=this;return this.onWindowResize=function(){t.resizeTimer&&clearTimeout(t.resizeTimer),t.resizeTimer=setTimeout(function(){t.reload()},100)},this},_create:function(){this._reload(),t(i).on("resize.jcarousel",this.onWindowResize)},_destroy:function(){t(i).off("resize.jcarousel",this.onWindowResize)},_reload:function(){this.vertical=this.options("vertical"),null==this.vertical&&(this.vertical=this.list().height()>this.list().width()),this.rtl=this.options("rtl"),null==this.rtl&&(this.rtl=function(i){if("rtl"===(""+i.attr("dir")).toLowerCase())return!0;var s=!1;return i.parents("[dir]").each(function(){return/rtl/i.test(t(this).attr("dir"))?(s=!0,!1):void 0}),s}(this._element)),this.lt=this.vertical?"top":"left",this.relative="relative"===this.list().css("position"),this._list=null,this._items=null;var i=this._target&&this.index(this._target)>=0?this._target:this.closest();this.circular="circular"===this.options("wrap"),this.underflow=!1;var s={left:0,top:0};return i.length>0&&(this._prepare(i),this.list().find("[data-jcarousel-clone]").remove(),this._items=null,this.underflow=this._fullyvisible.length>=this.items().length,this.circular=this.circular&&!this.underflow,s[this.lt]=this._position(i)+"px"),this.move(s),this},list:function(){if(null===this._list){var i=this.options("list");this._list=t.isFunction(i)?i.call(this):this._element.find(i)}return this._list},items:function(){if(null===this._items){var i=this.options("items");this._items=(t.isFunction(i)?i.call(this):this.list().find(i)).not("[data-jcarousel-clone]")}return this._items},index:function(t){return this.items().index(t)},closest:function(){var i,e=this,r=this.list().position()[this.lt],n=t(),o=!1,l=this.vertical?"bottom":this.rtl&&!this.relative?"left":"right";return this.rtl&&this.relative&&!this.vertical&&(r+=this.list().width()-this.clipping()),this.items().each(function(){if(n=t(this),o)return!1;var a=e.dimension(n);if(r+=a,r>=0){if(i=a-s(n.css("margin-"+l)),!(0>=Math.abs(r)-a+i/2))return!1;o=!0}}),n},target:function(){return this._target},first:function(){return this._first},last:function(){return this._last},visible:function(){return this._visible},fullyvisible:function(){return this._fullyvisible},hasNext:function(){if(!1===this._trigger("hasnext"))return!0;var t=this.options("wrap"),i=this.items().length-1;return i>=0&&!this.underflow&&(t&&"first"!==t||i>this.index(this._last)||this.tail&&!this.inTail)?!0:!1},hasPrev:function(){if(!1===this._trigger("hasprev"))return!0;var t=this.options("wrap");return this.items().length>0&&!this.underflow&&(t&&"last"!==t||this.index(this._first)>0||this.tail&&this.inTail)?!0:!1},clipping:function(){return this._element["inner"+(this.vertical?"Height":"Width")]()},dimension:function(t){return t["outer"+(this.vertical?"Height":"Width")](!0)},scroll:function(i,s,e){if(this.animating)return this;if(!1===this._trigger("scroll",null,[i,s]))return this;t.isFunction(s)&&(e=s,s=!0);var r=t.jCarousel.parseTarget(i);if(r.relative){var n,o,l,a,h,u,c,f,d=this.items().length-1,_=Math.abs(r.target),p=this.options("wrap");if(r.target>0){var g=this.index(this._last);if(g>=d&&this.tail)this.inTail?"both"===p||"last"===p?this._scroll(0,s,e):t.isFunction(e)&&e.call(this,!1):this._scrollTail(s,e);else if(n=this.index(this._target),this.underflow&&n===d&&("circular"===p||"both"===p||"last"===p)||!this.underflow&&g===d&&("both"===p||"last"===p))this._scroll(0,s,e);else if(l=n+_,this.circular&&l>d){for(f=d,h=this.items().get(-1);l>f++;)h=this.items().eq(0),u=this._visible.index(h)>=0,u&&h.after(h.clone(!0).attr("data-jcarousel-clone",!0)),this.list().append(h),u||(c={},c[this.lt]=this.dimension(h),this.moveBy(c)),this._items=null;this._scroll(h,s,e)}else this._scroll(Math.min(l,d),s,e)}else if(this.inTail)this._scroll(Math.max(this.index(this._first)-_+1,0),s,e);else if(o=this.index(this._first),n=this.index(this._target),a=this.underflow?n:o,l=a-_,0>=a&&(this.underflow&&"circular"===p||"both"===p||"first"===p))this._scroll(d,s,e);else if(this.circular&&0>l){for(f=l,h=this.items().get(0);0>f++;){h=this.items().eq(-1),u=this._visible.index(h)>=0,u&&h.after(h.clone(!0).attr("data-jcarousel-clone",!0)),this.list().prepend(h),this._items=null;var v=this.dimension(h);c={},c[this.lt]=-v,this.moveBy(c)}this._scroll(h,s,e)}else this._scroll(Math.max(l,0),s,e)}else this._scroll(r.target,s,e);return this._trigger("scrollend"),this},moveBy:function(t,i){var e=this.list().position(),r=1,n=0;return this.rtl&&!this.vertical&&(r=-1,this.relative&&(n=this.list().width()-this.clipping())),t.left&&(t.left=e.left+n+s(t.left)*r+"px"),t.top&&(t.top=e.top+n+s(t.top)*r+"px"),this.move(t,i)},move:function(i,s){s=s||{};var e=this.options("transitions"),r=!!e,n=!!e.transforms,o=!!e.transforms3d,l=s.duration||0,a=this.list();if(!r&&l>0)return a.animate(i,s),void 0;var h=s.complete||t.noop,u={};if(r){var c=a.css(["transitionDuration","transitionTimingFunction","transitionProperty"]),f=h;h=function(){t(this).css(c),f.call(this)},u={transitionDuration:(l>0?l/1e3:0)+"s",transitionTimingFunction:e.easing||s.easing,transitionProperty:l>0?function(){return n||o?"all":i.left?"left":"top"}():"none",transform:"none"}}o?u.transform="translate3d("+(i.left||0)+","+(i.top||0)+",0)":n?u.transform="translate("+(i.left||0)+","+(i.top||0)+")":t.extend(u,i),r&&l>0&&a.one("transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd",h),a.css(u),0>=l&&a.each(function(){h.call(this)})},_scroll:function(i,s,e){if(this.animating)return t.isFunction(e)&&e.call(this,!1),this;if("object"!=typeof i?i=this.items().eq(i):i.jquery===void 0&&(i=t(i)),0===i.length)return t.isFunction(e)&&e.call(this,!1),this;this.inTail=!1,this._prepare(i);var r=this._position(i),n=this.list().position()[this.lt];if(r===n)return t.isFunction(e)&&e.call(this,!1),this;var o={};return o[this.lt]=r+"px",this._animate(o,s,e),this},_scrollTail:function(i,s){if(this.animating||!this.tail)return t.isFunction(s)&&s.call(this,!1),this;var e=this.list().position()[this.lt];this.rtl&&this.relative&&!this.vertical&&(e+=this.list().width()-this.clipping()),this.rtl&&!this.vertical?e+=this.tail:e-=this.tail,this.inTail=!0;var r={};return r[this.lt]=e+"px",this._update({target:this._target.next(),fullyvisible:this._fullyvisible.slice(1).add(this._visible.last())}),this._animate(r,i,s),this},_animate:function(i,s,e){if(e=e||t.noop,!1===this._trigger("animate"))return e.call(this,!1),this;this.animating=!0;var r=this.options("animation"),n=t.proxy(function(){this.animating=!1;var t=this.list().find("[data-jcarousel-clone]");t.length>0&&(t.remove(),this._reload()),this._trigger("animateend"),e.call(this,!0)},this),o="object"==typeof r?t.extend({},r):{duration:r},l=o.complete||t.noop;return s===!1?o.duration=0:t.fx.speeds[o.duration]!==void 0&&(o.duration=t.fx.speeds[o.duration]),o.complete=function(){n(),l.call(this)},this.move(i,o),this},_prepare:function(i){var e,r,n,o,l=this.index(i),a=l,h=this.dimension(i),u=this.clipping(),c=this.vertical?"bottom":this.rtl?"left":"right",f=this.options("center"),d={target:i,first:i,last:i,visible:i,fullyvisible:u>=h?i:t()};if(f&&(h/=2,u/=2),u>h)for(;;){if(e=this.items().eq(++a),0===e.length){if(!this.circular)break;if(e=this.items().eq(0),i.get(0)===e.get(0))break;if(r=this._visible.index(e)>=0,r&&e.after(e.clone(!0).attr("data-jcarousel-clone",!0)),this.list().append(e),!r){var _={};_[this.lt]=this.dimension(e),this.moveBy(_)}this._items=null}if(o=this.dimension(e),0===o)break;if(h+=o,d.last=e,d.visible=d.visible.add(e),n=s(e.css("margin-"+c)),u>=h-n&&(d.fullyvisible=d.fullyvisible.add(e)),h>=u)break}if(!this.circular&&!f&&u>h)for(a=l;;){if(0>--a)break;if(e=this.items().eq(a),0===e.length)break;if(o=this.dimension(e),0===o)break;if(h+=o,d.first=e,d.visible=d.visible.add(e),n=s(e.css("margin-"+c)),u>=h-n&&(d.fullyvisible=d.fullyvisible.add(e)),h>=u)break}return this._update(d),this.tail=0,f||"circular"===this.options("wrap")||"custom"===this.options("wrap")||this.index(d.last)!==this.items().length-1||(h-=s(d.last.css("margin-"+c)),h>u&&(this.tail=h-u)),this},_position:function(t){var i=this._first,s=i.position()[this.lt],e=this.options("center"),r=e?this.clipping()/2-this.dimension(i)/2:0;return this.rtl&&!this.vertical?(s-=this.relative?this.list().width()-this.dimension(i):this.clipping()-this.dimension(i),s+=r):s-=r,!e&&(this.index(t)>this.index(i)||this.inTail)&&this.tail?(s=this.rtl&&!this.vertical?s-this.tail:s+this.tail,this.inTail=!0):this.inTail=!1,-s},_update:function(i){var s,e=this,r={target:this._target||t(),first:this._first||t(),last:this._last||t(),visible:this._visible||t(),fullyvisible:this._fullyvisible||t()},n=this.index(i.first||r.first)<this.index(r.first),o=function(s){var o=[],l=[];i[s].each(function(){0>r[s].index(this)&&o.push(this)}),r[s].each(function(){0>i[s].index(this)&&l.push(this)}),n?o=o.reverse():l=l.reverse(),e._trigger(s+"in",t(o)),e._trigger(s+"out",t(l)),e["_"+s]=i[s]};for(s in i)o(s);return this}})}(jQuery,window),function(t){"use strict";t.jcarousel.fn.scrollIntoView=function(i,s,e){var r,n=t.jCarousel.parseTarget(i),o=this.index(this._fullyvisible.first()),l=this.index(this._fullyvisible.last());if(r=n.relative?0>n.target?Math.max(0,o+n.target):l+n.target:"object"!=typeof n.target?n.target:this.index(n.target),o>r)return this.scroll(r,s,e);if(r>=o&&l>=r)return t.isFunction(e)&&e.call(this,!1),this;for(var a,h=this.items(),u=this.clipping(),c=this.vertical?"bottom":this.rtl?"left":"right",f=0;;){if(a=h.eq(r),0===a.length)break;if(f+=this.dimension(a),f>=u){var d=parseFloat(a.css("margin-"+c))||0;f-d!==u&&r++;break}if(0>=r)break;r--}return this.scroll(r,s,e)}}(jQuery),function(t){"use strict";t.jCarousel.plugin("jcarouselControl",{_options:{target:"+=1",event:"click",method:"scroll"},_active:null,_init:function(){this.onDestroy=t.proxy(function(){this._destroy(),this.carousel().one("jcarousel:createend",t.proxy(this._create,this))},this),this.onReload=t.proxy(this._reload,this),this.onEvent=t.proxy(function(i){i.preventDefault();var s=this.options("method");t.isFunction(s)?s.call(this):this.carousel().jcarousel(this.options("method"),this.options("target"))},this)},_create:function(){this.carousel().one("jcarousel:destroy",this.onDestroy).on("jcarousel:reloadend jcarousel:scrollend",this.onReload),this._element.on(this.options("event")+".jcarouselcontrol",this.onEvent),this._reload()},_destroy:function(){this._element.off(".jcarouselcontrol",this.onEvent),this.carousel().off("jcarousel:destroy",this.onDestroy).off("jcarousel:reloadend jcarousel:scrollend",this.onReload)},_reload:function(){var i,s=t.jCarousel.parseTarget(this.options("target")),e=this.carousel();if(s.relative)i=e.jcarousel(s.target>0?"hasNext":"hasPrev");else{var r="object"!=typeof s.target?e.jcarousel("items").eq(s.target):s.target;i=e.jcarousel("target").index(r)>=0}return this._active!==i&&(this._trigger(i?"active":"inactive"),this._active=i),this}})}(jQuery),function(t){"use strict";t.jCarousel.plugin("jcarouselPagination",{_options:{perPage:null,item:function(t){return'<a href="#'+t+'">'+t+"</a>"},event:"click",method:"scroll"},_carouselItems:null,_pages:{},_items:{},_currentPage:null,_init:function(){this.onDestroy=t.proxy(function(){this._destroy(),this.carousel().one("jcarousel:createend",t.proxy(this._create,this))},this),this.onReload=t.proxy(this._reload,this),this.onScroll=t.proxy(this._update,this)},_create:function(){this.carousel().one("jcarousel:destroy",this.onDestroy).on("jcarousel:reloadend",this.onReload).on("jcarousel:scrollend",this.onScroll),this._reload()},_destroy:function(){this._clear(),this.carousel().off("jcarousel:destroy",this.onDestroy).off("jcarousel:reloadend",this.onReload).off("jcarousel:scrollend",this.onScroll),this._carouselItems=null},_reload:function(){var i=this.options("perPage");if(this._pages={},this._items={},t.isFunction(i)&&(i=i.call(this)),null==i)this._pages=this._calculatePages();else for(var s,e=parseInt(i,10)||0,r=this._getCarouselItems(),n=1,o=0;;){if(s=r.eq(o++),0===s.length)break;this._pages[n]=this._pages[n]?this._pages[n].add(s):s,0===o%e&&n++}this._clear();var l=this,a=this.carousel().data("jcarousel"),h=this._element,u=this.options("item"),c=this._getCarouselItems().length;t.each(this._pages,function(i,s){var e=l._items[i]=t(u.call(l,i,s));e.on(l.options("event")+".jcarouselpagination",t.proxy(function(){var t=s.eq(0);if(a.circular){var e=a.index(a.target()),r=a.index(t);parseFloat(i)>parseFloat(l._currentPage)?e>r&&(t="+="+(c-e+r)):r>e&&(t="-="+(e+(c-r)))}a[this.options("method")](t)},l)),h.append(e)}),this._update()},_update:function(){var i,s=this.carousel().jcarousel("target");t.each(this._pages,function(t,e){return e.each(function(){return s.is(this)?(i=t,!1):void 0}),i?!1:void 0}),this._currentPage!==i&&(this._trigger("inactive",this._items[this._currentPage]),this._trigger("active",this._items[i])),this._currentPage=i},items:function(){return this._items},reloadCarouselItems:function(){return this._carouselItems=null,this},_clear:function(){this._element.empty(),this._currentPage=null},_calculatePages:function(){for(var t,i=this.carousel().data("jcarousel"),s=this._getCarouselItems(),e=i.clipping(),r=0,n=0,o=1,l={};;){if(t=s.eq(n++),0===t.length)break;l[o]=l[o]?l[o].add(t):t,r+=i.dimension(t),r>=e&&(o++,r=0)}return l},_getCarouselItems:function(){return this._carouselItems||(this._carouselItems=this.carousel().jcarousel("items")),this._carouselItems}})}(jQuery),function(t){"use strict";t.jCarousel.plugin("jcarouselAutoscroll",{_options:{target:"+=1",interval:3e3,autostart:!0},_timer:null,_init:function(){this.onDestroy=t.proxy(function(){this._destroy(),this.carousel().one("jcarousel:createend",t.proxy(this._create,this))},this),this.onAnimateEnd=t.proxy(this.start,this)},_create:function(){this.carousel().one("jcarousel:destroy",this.onDestroy),this.options("autostart")&&this.start()},_destroy:function(){this.stop(),this.carousel().off("jcarousel:destroy",this.onDestroy)},start:function(){return this.stop(),this.carousel().one("jcarousel:animateend",this.onAnimateEnd),this._timer=setTimeout(t.proxy(function(){this.carousel().jcarousel("scroll",this.options("target"))},this),this.options("interval")),this},stop:function(){return this._timer&&(this._timer=clearTimeout(this._timer)),this.carousel().off("jcarousel:animateend",this.onAnimateEnd),this}})}(jQuery);
if (window){

    window.imageClassicV1 = {

        resizeVerticalBlock: function(){

            var $maxHeight = [];
            var $maxElementHeight = [];

            elementBlock = ['image', 'name'];
            elemenID = '.bxr-classic-image-v1[data-resize=1]';

            for (i=0; i<elementBlock.length; i++){

                $maxElementHeight = [];

                $(elemenID).each(function(){

                    uid = $(this).data('uid');

                    $nameContainer = $(this).children('.bxr-element-container').children('.bxr-element-'+elementBlock[i]);

                    if (!(uid in $maxElementHeight)) {
                        $maxElementHeight[uid] = 0;
                    }

                    if ($nameContainer.height() > $maxElementHeight[uid]) $maxElementHeight[uid] = $nameContainer.height();

                });

                $(elemenID).each(function(){

                    uid = $(this).data('uid');
                    $nameContainer = $(this).children('.bxr-element-container').children('.bxr-element-'+elementBlock[i]);
                    $nameContainer.height($maxElementHeight[uid]);
                });

            }

            // resize container

            $('.bxr-classic-image-v1[data-resize=1]').each(function(){

                uid = $(this).data('uid');
                if (!(uid in $maxHeight)) {
                    $maxHeight[uid] = 0;
                }
                if ($(this).height()>$maxHeight[uid]) $maxHeight[uid] = $(this).height();
                //console.log($(this));
            });

            $('.bxr-classic-image-v1[data-resize=1]').each(function(){

                uid = $(this).data('uid');
                $(this).children('.bxr-element-container').height($maxHeight[uid]);
                $(this).height($maxHeight[uid]);
            });

        }
    }


    $(window).on('load',function(){

        imageClassicV1.resizeVerticalBlock();

    });

    $(window).resize(function(){
        imageClassicV1.resizeVerticalBlock();
    });
}
var delayClick = false;


$(document).ready(function(){
    $('.btn-callback-header').click(function(){
        yaCounter11338723.reachGoal('zakazat-zvonok-click');
        console.log('zakazat-zvonok-click');
        setTimeout(function(){
            $('form#iblockForm10 input[type="submit"]').click(function(){
                if( $('input[name="PROPERTY[48][0]"]').val()!=""){
                    yaCounter11338723.reachGoal('zakazat-zvonok-otpravka');
                    console.log('zakazat-zvonok-otpravka');
                }
                else console.log('zakazat-zvonok-otpravka no');

            });
        }, 1000);
    })

    $('.footer-btn-call').click(function(){
        yaCounter11338723.reachGoal('napishite-click');
        console.log('napishite-click');
        setTimeout(function(){
            $('form#iblockForm31 input[type="submit"]').click(function(){
                if( $('input[name="PROPERTY[292][0]"]').val()!="" || $('input[name="PROPERTY[293][0]"]').val()!="" || $('input[name="PROPERTY[294][0]"]').val()!=""){
                    yaCounter11338723.reachGoal('napishite-otpravka');
                    console.log('napishite-otpravka');
                }
                else console.log('napishite-otpravka no');

            });
        }, 1000);
    })

    if($('.row').is('#iblockForm35')){
        $('form#iblockForm35 input[type="submit"]').click(function(){
            if( $('input[name="PROPERTY[305][0]"]').val()!="" || $('input[name="PROPERTY[306][0]"]').val()!=""){
                yaCounter11338723.reachGoal('obratnaya-svyaz');
                console.log('obratnaya-svyaz');
            }
            else console.log('obratnaya-svyaz no');

        });
    }

    $('form#iblockForm35 input[type="submit"]').click(function(){
        if( $('input[name="PROPERTY[305][0]"]').val()!="" || $('input[name="PROPERTY[306][0]"]').val()!=""){
            yaCounter11338723.reachGoal('obratnaya-svyaz');
            console.log('obratnaya-svyaz');
        }
        else console.log('obratnaya-svyaz no');

    });

    $('.bxr-one-click-buy').click(function(){
        yaCounter11338723.reachGoal('one-click-click');
        console.log('one-click-click');
        setTimeout(function(){
            $('form#iblockForm9 input[type="submit"]').click(function(){
                if( $('input[name="PROPERTY[43][0]"').val()!="" || $('input[name="PROPERTY[44][0]"').val()!="" || $('input[name="PROPERTY[45][0]"').val()!=""|| $('input[name="captcha_word"').val()!=""){
                    yaCounter11338723.reachGoal('one-click-otpravka');
                    console.log('one-click-otpravka');
                }
                else console.log('one-click-otpravka no');

            });
        }, 1000);
    })

    $('.bxr-basket-add').click(function(){
        yaCounter11338723.reachGoal('v-korzinu');
        console.log('v-korzinu');
    })



});

$(document).ready(function () {


    function isTouchDevice() {
        try {
            document.createEvent('TouchEvent');
            return true;
        } catch (e) {
            return false;
        }
    };


    if (!isTouchDevice()) {
        prevBtn = '<button type="button" class="bxr-color-button slick-prev hidden-arrow"></button>';
        nextBtn = '<button type="button" class="bxr-color-button slick-next hidden-arrow"></button>';
    }
    if (isTouchDevice()) {
        prevBtn = '<button type="button" class="bxr-color-button slick-prev"></button>';
        nextBtn = '<button type="button" class="bxr-color-button slick-next"></button>';
    }

    $('#sl_18782').slick({
        dots: true,
        infinite: false,
        speed: 300,

        slidesToShow: 4,
        slidesToScroll: 1,
        prevArrow: prevBtn,
        nextArrow: nextBtn,
        responsive: [
            {
                breakpoint: 768,
                settings: "unslick"

            },
            {
                breakpoint: 1199,
                settings: {
                    slidesToShow: 4,
                    slidesToScroll: 1
                }
            },
            {
                breakpoint: 991,
                settings: {
                    slidesToShow: 3,
                    slidesToScroll: 1
                }
            }
        ]
    });

    $('#sl_18781').slick({
        dots: true,
        infinite: false,
        speed: 300,

        slidesToShow: 4,
        slidesToScroll: 1,
        prevArrow: prevBtn,
        nextArrow: nextBtn,
        responsive: [
            {
                breakpoint: 768,
                settings: "unslick"

            },
            {
                breakpoint: 1199,
                settings: {
                    slidesToShow: 4,
                    slidesToScroll: 1
                }
            },
            {
                breakpoint: 991,
                settings: {
                    slidesToShow: 3,
                    slidesToScroll: 1
                }
            }
        ]
    });


    /*$(window).resize(function () {
        $('.bxr-bestseller-list').each(function () {
            if ($(window).width() > 766 && $('#sl_' + $(this).data('slider')).data('slideset') == 1)
                initBestsellerSlider($(this).data('slider'));
        });
    });*/


});